<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Staff Command Center v3.8 (Smart Rotation)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- PDF Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.29/jspdf.plugin.autotable.min.js"></script>

    <!-- Bootstrap: make rosterSystem accessible to module scripts -->
    <script>
      window.rosterSystem = window.rosterSystem || {};
      // Promise resolved when main rosterSystem object (methods) is ready
      window.__rosterReady = new Promise((res)=>{ window.__resolveRosterReady = res; });
    </script>

    <!-- Firebase SDKs -->
    <script>
      // iOS/WebView: ensure these identifiers exist even inside embedded frames
      var fireauth = null;
      var firedb = null;
      var firebaseApp = null;
    </script>
<script>
  // Suppress known iOS WebView/Files internal iframe console errors that are not caused by this app.
  window.addEventListener('error', function(ev){
    try{
      var msg = String(ev && ev.message || '');
      if (msg.includes('Invalid URI scheme in origin: about') || msg.includes("Can't find variable: fireauth") || msg === 'Script error.') {
        ev.preventDefault();
        return true;
      }
    }catch(e){}
    return false;
  }, true);
  window.addEventListener('unhandledrejection', function(ev){
    try{
      var msg = String(ev && (ev.reason && ev.reason.message || ev.reason) || '');
      if (msg.includes('Invalid URI scheme in origin: about') || msg.includes("Can't find variable: fireauth")) {
        ev.preventDefault();
        return true;
      }
    }catch(e){}
    return false;
  });
</script>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, collection, doc, setDoc, getDoc, addDoc, updateDoc, deleteDoc, onSnapshot, query, writeBatch, serverTimestamp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

        const firebaseConfig = {
          apiKey: "AIzaSyAP7b4KcwRYPMZjNc2TWsNqMvC3ywImhOM",
          authDomain: "roster-4a997.firebaseapp.com",
          projectId: "roster-4a997",
          storageBucket: "roster-4a997.firebasestorage.app",
          messagingSenderId: "901381868881",
          appId: "1:901381868881:web:92930481d6c1c85fedd770"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        // Expose for inline handlers / embedded contexts (iOS iframe/webview)
        window.fireauth = auth;
        window.firedb = db;
        window.firebaseApp = app;

        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'custom-roster-app';
        
        const COLLECTION_STAFF = 'employees'; 
        const COLLECTION_TEAMS = 'teams';
        const COLLECTION_ROSTERS = 'rosters';

        let currentUser = null;
        let staffList = [];
        let lockedCellsData = {};
        
        const initAuth = async () => {
            try {
                const statusEl = document.getElementById('db-status');
                if(statusEl) statusEl.innerText = 'Connecting...';
                await signInAnonymously(auth);
            } catch (error) {
                console.error("Auth Failed:", error);
                document.getElementById('error-display').innerHTML = `<div class="bg-red-100 text-red-800 p-4 rounded mb-4">Auth Error: ${error.message}</div>`;
            }
        };

        onAuthStateChanged(auth, async (user) => {
            await window.__rosterReady;
            if (user) {
                currentUser = user;
                const statusEl = document.getElementById('db-status');
                if(statusEl) statusEl.innerHTML = '<span class="flex items-center gap-1 text-green-600 font-bold text-[10px]"><span class="w-1.5 h-1.5 bg-green-500 rounded-full animate-pulse"></span> ONLINE</span>';
                subscribeToData();
                rosterSystem.initializeDate(); 
            }
        });

        function subscribeToData() {
            if (!currentUser) return;
            const staffPath = collection(db, 'artifacts', appId, 'public', 'data', COLLECTION_STAFF);
            const staffQuery = query(staffPath);
            onSnapshot(staffQuery, (snapshot) => {
                staffList = snapshot.docs.map(doc => ({ firebaseId: doc.id, ...doc.data() }));
                staffList.sort((a, b) => (a.staffId || "").localeCompare(b.staffId || ""));
                rosterSystem.staffDataCache = staffList; 
                rosterSystem.renderStaffCards(staffList); 
                rosterSystem.updateStats();
                rosterSystem.updateStaffDatalist();
            }, (error) => console.error("Staff Read Error: " + error.message));

            const settingsDocRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_TEAMS, 'roster_settings');
            onSnapshot(settingsDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    lockedCellsData = data.lockedCells || {};
                    rosterSystem.durations = data.locationDurations || {}; 
                    rosterSystem.breakDuration = data.breakDuration || 60; 
                    rosterSystem.applyPadlocksVisuals();
                    if(rosterSystem.generatedRoster) rosterSystem.validateAllCells(); 
                }
            });
        }

        window.firebaseOperations = {
            addStaff: async (staffData) => {
                if (!currentUser) return alert("Not connected!");
                try {
                    await addDoc(collection(db, 'artifacts', appId, 'public', 'data', COLLECTION_STAFF), staffData);
                    rosterSystem.showToast("Staff added", "success");
                } catch (e) {
                    console.error("Write Failed: " + e.message);
                    rosterSystem.showToast("Failed to save", "error");
                }
            },
            updateStaff: async (firebaseId, data) => {
                if (!currentUser || !firebaseId) return;
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_STAFF, firebaseId);
                await updateDoc(docRef, data);
            },
            deleteStaff: async (firebaseId) => {
                if (!currentUser || !firebaseId) return;
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_STAFF, firebaseId);
                await deleteDoc(docRef);
                rosterSystem.showToast("Staff removed", "success");
            },
            toggleLock: async (key) => {
                if (!currentUser) return;
                const newLocks = { ...lockedCellsData };
                if (newLocks[key]) delete newLocks[key]; else newLocks[key] = true;
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_TEAMS, 'roster_settings');
                await setDoc(docRef, { lockedCells: newLocks }, { merge: true });
            },
            saveSettings: async (settingsData) => {
                 if (!currentUser) return;
                 const docRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_TEAMS, 'roster_settings');
                 await setDoc(docRef, settingsData, { merge: true });
            },
            batchUpdateStaff: async (updates) => {
                if (!currentUser || updates.length === 0) return;
                const batch = writeBatch(db);
                updates.forEach(update => {
                    const docRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_STAFF, update.id);
                    batch.update(docRef, update.data);
                });
                await batch.commit();
            },
            saveRoster: async (dateStr, rosterData) => {
                if (!currentUser || dateStr == null || dateStr === '') return;
                try {
                    // Firestore doc IDs must be strings (SDK will throw if a number/Date is passed)
                    const safeDateId = String(dateStr).trim();
                    const docRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_ROSTERS, safeDateId);
                    await setDoc(docRef, { roster: rosterData, updatedAt: serverTimestamp() }, { merge: true });
                } catch (e) {
                    console.error("Save Error:", e);
                    alert(`Failed to save roster: ${e.message}`);
                }
            },
            subscribeToRoster: (dateStr, callback) => {
                if (!currentUser || dateStr == null || dateStr === '') return null;
                const safeDateId = String(dateStr).trim();
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_ROSTERS, safeDateId);
                return onSnapshot(docRef, (doc) => {
                    if (doc.exists()) {
                        callback(doc.data().roster);
                    } else {
                        callback(null);
                    }
                }, (error) => {
                    console.error("Subscription Error:", error);
                    callback(null);
                });
            },
            
            getLocks: () => lockedCellsData,

            // ===== Blueprint storage (optional cloud) =====
            saveBlueprint: async (blueprintObj, updatedAtIso) => {
                if (!currentUser) return;
                const payload = {
                    blueprint: blueprintObj || null,
                    schema: (blueprintObj && (blueprintObj.schema || blueprintObj.version)) || null,
                    updatedAt: updatedAtIso || new Date().toISOString()
                };
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'blueprints', 'active');
                await setDoc(docRef, payload, { merge: true });
            },
            loadBlueprint: async () => {
                try {
                    const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'blueprints', 'active');
                    const snap = await getDoc(docRef);
                    if (!snap.exists()) return null;
                    return snap.data();
                } catch (e) {
                    return null;
                }
            },
            clearBlueprint: async () => {
                if (!currentUser) return;
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'blueprints', 'active');
                await setDoc(docRef, { blueprint: null, updatedAt: new Date().toISOString() }, { merge: true });
            }
        };


        initAuth();
    </script>

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f1f5f9; color: #0f172a; font-size: 14px; }
        .card-panel { background: #ffffff; border: 1px solid #e2e8f0; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); }
        .staff-card { transition: all 0.15s ease; position: relative; background: white; border: 1px solid #cbd5e1; }
        .staff-card:hover { border-color: #6366f1; background-color: #f8fafc; transform: translateY(-1px); z-index: 10; }
        .staff-card.inactive { background-color: #f8fafc; opacity: 0.75; border-style: dashed; border-color: #cbd5e1; }
        .staff-card.inactive .avatar { filter: grayscale(1); opacity: 0.5; }
        
        .styled-table { border-collapse: separate; border-spacing: 0; width: max-content; min-width: 100%; table-layout: auto; }
        .styled-table thead th { background-color: #f8fafc; color: #64748b; font-size: 0.7rem; text-transform: uppercase; border-bottom: 2px solid #e2e8f0; font-weight: 700; padding: 6px 4px; min-width: 85px; width: 85px; position: sticky; top: 0; z-index: 20; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .styled-table td { border-bottom: 1px solid #e2e8f0; padding: 0; vertical-align: top; min-width: 85px; width: 85px; }
        .styled-table tbody tr:hover td { background-color: #f8fafc; }
        .styled-table thead th:first-child, .styled-table tbody td:first-child { position: sticky; left: 0; z-index: 30; background-color: #ffffff; border-right: 2px solid #e2e8f0; min-width: 100px; width: 100px; }
        .styled-table thead th:first-child { z-index: 40; }

        .roster-input { background: transparent; color: #0f172a; border: none; width: 100%; text-align: center; font-size: 0.85rem; height: 32px; font-weight: 700; padding: 0 2px; }
        .roster-input:focus { outline: 2px solid #6366f1; background: #fff; z-index: 5; position: relative; }
        .roster-input:hover { background: #f1f5f9; }
        
        .predefined-cell { background-color: #eff6ff !important; }
        .predefined-cell .roster-input { color: #1d4ed8; font-weight: 800; }
        .predefined-icon { position: absolute; top: 1px; right: 1px; width: 8px; height: 8px; color: #3b82f6; z-index: 4; pointer-events: none; }

        .not-applicable { background-color: #f8fafc; background-image: repeating-linear-gradient(45deg, transparent, transparent 5px, #e2e8f0 5px, #e2e8f0 6px); }
        .conflict-cell { background-color: #fee2e2 !important; box-shadow: inset 0 0 0 1px #ef4444; }
        
        .scroll-container { overflow: auto; -webkit-overflow-scrolling: touch; overscroll-behavior: contain; touch-action: pan-x pan-y; }
        #rosterContainer { overflow-x: auto; overflow-y: auto; position: relative; }
        #rosterContainer table { width: max-content; min-width: 100%; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        .avatar-bg-0 { background-color: #ef4444; } .avatar-bg-1 { background-color: #f97316; } .avatar-bg-2 { background-color: #eab308; } .avatar-bg-3 { background-color: #22c55e; } .avatar-bg-4 { background-color: #06b6d4; } .avatar-bg-5 { background-color: #3b82f6; } .avatar-bg-6 { background-color: #a855f7; } .avatar-bg-7 { background-color: #ec4899; }
        .filter-chip { transition: all 0.2s; } .filter-chip.active { background-color: #e0e7ff; color: #4338ca; border-color: #c7d2fe; }
        .modal { transition: opacity 0.2s ease-in-out; } .modal.hidden { pointer-events: none; opacity: 0; } .modal.flex { pointer-events: auto; opacity: 1; }

        .roster-panel.fullscreen { position: fixed !important; inset: 0; width: 100vw; height: 100dvh; z-index: 9999; margin: 0; border: none; border-radius: 0; background-color: #f8fafc; display: flex; flex-direction: column; }
        .roster-panel.fullscreen .controls-bar { flex-shrink: 0; z-index: 50; }
        .roster-panel.fullscreen .roster-content-wrapper { flex: 1; overflow: hidden; display: flex; flex-direction: column; padding: 0 !important; }
        .roster-panel.fullscreen .roster-inner-card { flex: 1; height: 100%; border-radius: 0; border: none; display: flex; flex-direction: column; }
        .roster-panel.fullscreen #rosterContainer { flex: 1; width: 100%; height: 100%; overflow: scroll; -webkit-overflow-scrolling: touch; padding-bottom: 80px; }
        .roster-panel.fullscreen #rosterActionsContainer { position: fixed; bottom: 20px; right: 20px; z-index: 100; }
    
        @media (orientation: landscape) and (max-height: 520px) {
            #leftPanel { display: none !important; }
            #rosterPanel { width: 100% !important; }
            .roster-content-wrapper { padding: 6px !important; }
            .controls-bar { padding-left: calc(env(safe-area-inset-left) + 8px) !important; padding-right: calc(env(safe-area-inset-right) + 12px) !important; flex-wrap: wrap; }
        }

        .controls-bar { padding-left: max(8px, env(safe-area-inset-left)); padding-right: max(10px, env(safe-area-inset-right)); }
        #rosterContainer { overflow-x: scroll; -webkit-overflow-scrolling: touch; }
        #rosterContainer table { width: max-content !important; min-width: 100% !important; }

        .saved-indicator { font-size: 10px; font-weight: 600; color: #10b981; opacity: 0; transition: opacity 0.5s; }
        .saved-indicator.visible { opacity: 1; }


/* --- ROSTER VISIBILITY TOGGLE --- */
body.roster-hidden #rosterPanel { display: none !important; }
body.roster-hidden #leftPanel { 
  width: 100% !important; 
  max-width: none !important; 
  flex: 1 1 auto !important; 
}
body.roster-hidden #mainSplit { flex-direction: column !important; }
@media (min-width: 768px){
  body.roster-hidden #mainSplit { flex-direction: row !important; }
}



/* === Break Timeline Start Guide === */
#breakTimelineRoot .bt-guide{
  position:absolute;
  top:0;
  bottom:0;
  width:0;
  border-left:2px dotted rgba(100,116,139,0.8);
  pointer-events:none;
}

/* Make drag stable on iOS (avoid page scroll while sliding break bars) */
#breakTimelineRoot{
  /* Allow normal vertical scrolling; horizontal drift is prevented by drag logic */
  touch-action: pan-y;
  overscroll-behavior: auto;
}
/* === Break Timeline Drag Handles === */
#breakTimelineRoot .bt-seg { touch-action: pan-y; cursor: grab; }
#breakTimelineRoot .bt-seg:active { cursor: grabbing; }
#breakTimelineRoot .bt-handle {
  position: absolute;
  top: -4px;
  width: 12px;
  height: calc(100% + 8px);
  border-radius: 6px;
  background: rgba(255,255,255,0.75);
  border: 1px solid rgba(15,23,42,0.15);
  box-shadow: 0 1px 2px rgba(0,0,0,0.08);
}
#breakTimelineRoot .bt-handle-l { left: -6px; cursor: ew-resize; }
#breakTimelineRoot .bt-handle-r { right: -6px; cursor: ew-resize; }


        /* --- Command Center: mobile vertical stack + scroll (ACTIVE tab friendly) --- */
        @media (max-width: 640px) {
            /* Keep list scroll vertical (no horizontal swipe) */
            .scroll-container { overflow-x: hidden !important; overflow-y: auto !important; -webkit-overflow-scrolling: touch; }

            /* Stack cards top-to-bottom and show 1 card per row */
            #staffGrid {
                display: grid !important;
                grid-template-columns: 1fr !important;
                gap: 10px !important;
                overflow: visible !important; /* wrapper handles scrolling */
                padding-bottom: 8px;
            }

            /* Make card wide enough for ID + location + time + VP control */
            .staff-card { width: 100% !important; }

            /* Prevent important details from being clipped */
            .staff-card .truncate { white-space: normal !important; overflow: visible !important; text-overflow: clip !important; }
            .staff-card .cc-location-badge, .staff-card .cc-loc-badge {
                max-width: 100% !important;
                overflow: visible !important;
                text-overflow: clip !important;
                white-space: nowrap;
            }
        }

    
/* === Command Center footer always visible in FILTER mode (mobile) === */
#ccFooter{ position: sticky; bottom: 0; z-index: 30; }
@media (max-width: 768px){
  /* Keep Command Center as a self-contained panel with internal scrolling */
  #leftPanel{ max-height: 58vh; overflow: hidden; }
  /* Ensure the staff list scrolls and never hides the footer */
  #leftPanel .scroll-container{ padding-bottom: 72px; }
  /* Avoid badge truncation */
  .staff-card .truncate{ white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
}


/* Manual override badge */
.override-badge{position:absolute;top:4px;right:6px;font-size:10px;line-height:1;padding:2px 6px;border-radius:999px;background:rgba(245,158,11,0.18);color:#b45309;border:1px solid rgba(245,158,11,0.35);font-weight:700;}


/* Insights â“˜ popover */
  #insightsInfoBtn{ flex: 0 0 auto; }
  #insightsInfoPopover.insights-popover{
    position: absolute;
    top: calc(100% + 8px);
    left: 0;
    width: min(420px, 78vw);
    background: #ffffff;
    border: 1px solid #e2e8f0;
    border-radius: 12px;
    box-shadow: 0 16px 40px rgba(15, 23, 42, .18);
    padding: 10px 12px;
    z-index: 60;
  }
  #insightsInfoPopover::before{
    content: "";
    position: absolute;
    top: -8px;
    left: 18px;
    width: 14px;
    height: 14px;
    background: #fff;
    border-left: 1px solid #e2e8f0;
    border-top: 1px solid #e2e8f0;
    transform: rotate(45deg);
  }
  .insights-popover-title{
    font-size: 12px;
    font-weight: 700;
    color: #0f172a;
    margin-bottom: 6px;
  }
  .insights-popover-body{
    font-size: 11.5px;
    color: #334155;
    line-height: 1.35;
  }
  .insights-popover-body ul{
    padding-left: 18px;
    margin: 0;
  }
  .insights-popover-body li{ margin: 4px 0; }
  .insights-popover-tip{
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px dashed #e2e8f0;
    color: #475569;
  }

</style>

<style>
  /* iOS/Safari: allow scrolling inside modal while body is locked */
  #insightsModal .insights-card { max-height: 85vh; }
  #insightsBody { -webkit-overflow-scrolling: touch; }
</style>
</head>
<body class="min-h-screen bg-slate-50 flex flex-col h-screen overflow-hidden">

<nav class="h-12 bg-white border-b border-slate-200 flex items-center shrink-0 z-20 shadow-sm">
    <div class="w-full px-4 flex items-center justify-between">
        <div class="flex items-center gap-2">
            <div class="w-6 h-6 rounded bg-indigo-600 flex items-center justify-center">
                <i data-lucide="shield" class="w-3.5 h-3.5 text-white"></i>
            </div>
            <h1 class="text-sm font-bold text-slate-800 uppercase tracking-wide">Command Center</h1>
            <button onclick="rosterSystem.openSettings()" class="ml-2 text-slate-400 hover:text-indigo-600 transition-colors p-1 rounded hover:bg-slate-100" title="Configuration">
                <i data-lucide="settings" class="w-4 h-4"></i>
            </button>
            <button id="toggleRosterBtn" onclick="toggleRosterVisibility()" class="ml-1 text-slate-400 hover:text-indigo-600 transition" title="Hide roster panel">
                <i data-lucide="eye-off" class="w-4 h-4"></i>
            </button>
        </div>
        <div class="hidden md:flex items-center gap-6">
            <div class="flex items-center gap-2 text-xs">
                <span class="text-slate-400 font-medium">POOL</span>
                <span class="font-bold text-slate-700"><span id="stat-present">0</span>/<span id="stat-total">0</span></span>
            </div>
            <div class="flex items-center gap-2 text-xs">
                <span class="text-slate-400 font-medium">HHMD</span>
                <span class="font-bold text-purple-600" id="stat-hhmd">0</span>
            </div>
        </div>
        <div class="flex md:hidden items-center gap-2 text-[10px] font-mono bg-slate-100 px-2 py-0.5 rounded">
            <span class="font-bold text-slate-700" id="stat-present-m">0</span> active
        </div>
    </div>
</nav>

<div id="mainSplit" class="flex-1 flex flex-col md:flex-row overflow-hidden">
    <!-- LEFT PANEL -->
    <div id="leftPanel" class="w-full md:w-[380px] lg:w-[420px] h-[40%] md:h-full bg-white border-b md:border-b-0 md:border-r border-slate-200 flex flex-col shrink-0 z-10 shadow-lg md:shadow-none">
        <div class="p-2 border-b border-slate-100 flex gap-2 items-center bg-slate-50/50 shrink-0">
            <div class="flex-1 flex bg-white border border-slate-200 rounded-md p-0.5" id="filterContainer">
                <button class="filter-chip active flex-1 py-1 text-[10px] font-bold text-slate-600 rounded" data-filter="all">ALL</button>
                <button class="filter-chip flex-1 py-1 text-[10px] font-bold text-slate-400 rounded hover:text-slate-600" data-filter="present">ACTIVE</button>
                <button class="filter-chip flex-1 py-1 text-[10px] font-bold text-slate-400 rounded hover:text-slate-600" data-filter="hhmd">HHMD</button>
            </div>
            <button onclick="rosterSystem.openAddModal()" class="w-8 h-8 rounded bg-indigo-600 text-white flex items-center justify-center hover:bg-indigo-700 shadow-sm"><i data-lucide="plus" class="w-4 h-4"></i></button>
        </div>
        <div class="flex-1 overflow-y-auto p-2 scroll-container">
            <div id="staffGrid" class="grid grid-cols-1 gap-2 cc-staffgrid">
                <div class="col-span-1 text-center py-8 text-xs text-slate-400">Loading...</div>
            </div>
        </div>
        <div id="ccFooter" class="p-2 border-t border-slate-200 bg-slate-50 flex justify-between items-center text-xs shrink-0">
            <div class="flex gap-2">
                <button onclick="rosterSystem.shuffleBreaks()" class="text-purple-600 hover:text-purple-800 font-semibold flex items-center gap-1 px-2 py-1 rounded hover:bg-purple-50"><i data-lucide="shuffle" class="w-3 h-3"></i> Shuffle</button>
                <button onclick="rosterSystem.shuffleFirstHourDeploy()" class="text-indigo-600 hover:text-indigo-800 font-semibold flex items-center gap-1 px-2 py-1 rounded hover:bg-indigo-50" title="Shuffle 20:00 start locations (excludes Vertical Patrol)"><i data-lucide="sparkles" class="w-3 h-3"></i> 1st Hr</button>
                <button onclick="rosterSystem.openBlueprintManager()" class="px-2 py-1 rounded bg-white border border-slate-200 hover:bg-slate-50 flex items-center gap-1">
                    <i data-lucide="file-json" class="w-3 h-3"></i> Blueprints
                </button>
                <button onclick="rosterSystem.openInsights()" class="text-slate-600 hover:text-slate-800 font-semibold flex items-center gap-1 px-2 py-1 rounded hover:bg-slate-50">
                    <i data-lucide="bar-chart-3" class="w-3 h-3"></i> Insights
                </button>
                <button onclick="rosterSystem.clearAssignments()" class="text-red-600 hover:text-red-800 font-semibold flex items-center gap-1 px-2 py-1 rounded hover:bg-red-50"><i data-lucide="eraser" class="w-3 h-3"></i> Clear</button>
            </div>
            <div id="db-status" class="text-[10px] font-mono text-slate-400">Connecting...</div>
        </div>
    </div>

    <!-- RIGHT PANEL (Roster) -->
    <div id="rosterPanel" class="roster-panel flex-1 flex flex-col bg-slate-50 overflow-hidden relative min-h-0">
        <div class="controls-bar min-h-12 border-b border-slate-200 bg-white px-4 py-1 flex items-center justify-between shrink-0 gap-2 overflow-x-auto">
            <div class="flex items-center gap-3 shrink-0">
                <div class="flex items-center gap-1">
                    <i data-lucide="calendar" class="w-3.5 h-3.5 text-slate-400"></i>
                    <input type="date" id="rosterDate" class="text-xs font-semibold bg-transparent border-none focus:ring-0 text-slate-700 p-0 w-24 cursor-pointer">
                </div>
                <select id="rosterDay" class="text-xs font-bold text-slate-700 bg-transparent border-none focus:ring-0 cursor-pointer w-24" disabled><option>Monday</option><option>Tuesday</option><option>Wednesday</option><option>Thursday</option><option>Friday</option><option>Saturday</option><option>Sunday</option></select>
                <button id="blueprintToggleBtn" onclick="rosterSystem.toggleBlueprint()"
                        class="ml-2 px-2 py-1 rounded border text-xs bg-white hover:bg-slate-50 border-slate-200 flex items-center gap-1"
                        title="Enable/disable Blueprint pattern enforcement">
                  <i data-lucide="layers" class="w-3.5 h-3.5"></i>
                  <span>Blueprint</span>
                  <span id="blueprintToggleState" class="font-semibold text-slate-600">OFF</span>
                </button>

                <div id="loadingIndicator" class="hidden text-slate-400"><i data-lucide="loader-2" class="w-3 h-3 animate-spin"></i></div>
                <span id="saveIndicator" class="saved-indicator flex items-center gap-1"><i data-lucide="cloud-check" class="w-3 h-3"></i> Saved</span>
            </div>
            <div class="flex items-center gap-2 shrink-0">
                <button id="fillGapsBtn" onclick="rosterSystem.fillRosterGaps()" class="bg-blue-600 hover:bg-blue-700 text-white p-1.5 rounded shadow-sm transition-all" title="Fill Empty Slots"><i data-lucide="paint-bucket" class="w-3.5 h-3.5"></i></button>
                <button id="shuffleRosterBtn" onclick="rosterSystem.smartShuffleOrGenerate(true)" class="bg-purple-600 hover:bg-purple-700 text-white p-1.5 rounded shadow-sm transition-all" title="Shuffle Roster"><i data-lucide="shuffle" class="w-3.5 h-3.5"></i></button>
                <select id="shuffleModeSel" class="ml-2 border border-slate-200 rounded px-2 py-1 text-xs bg-white"
                        title="Shuffle mode">
                  <option value="random">Random</option>
                  <option value="rotate">Rotate</option>
                  <option value="balanced">Balanced</option>
                </select>

                <button id="generateRosterBtn" class="bg-emerald-600 hover:bg-emerald-700 text-white text-xs font-bold py-1.5 px-3 md:px-4 rounded shadow-sm flex items-center gap-2 transition-transform active:scale-95 whitespace-nowrap"><i data-lucide="zap" class="w-3.5 h-3.5"></i> <span class="hidden md:inline">GENERATE</span><span class="md:hidden">GO</span></button>
                <button id="toggleFullscreenBtn" onclick="rosterSystem.toggleFullscreen()" class="bg-slate-800 hover:bg-slate-700 text-white p-1.5 rounded shadow-sm transition-all" title="Full Screen"><i data-lucide="maximize" class="w-3.5 h-3.5"></i></button>
            </div>
        </div>
        
        <div class="roster-content-wrapper flex-1 overflow-hidden relative p-0 md:p-4">
             <div class="roster-inner-card bg-white border border-slate-200 rounded shadow-sm h-full flex flex-col">
                <div id="rosterContainer" class="scroll-container h-full w-full">
                    <div class="flex flex-col items-center justify-center h-40 text-slate-400">
                        <i data-lucide="layout-template" class="w-10 h-10 mb-2 opacity-20"></i>
                        <p class="text-xs">Roster View</p>
                    </div>
                </div>
            </div>
            <div id="rosterActionsContainer" class="hidden absolute bottom-4 right-4 flex gap-2 z-20">
                <button id="copyTSVBtn" class="bg-white border border-slate-300 text-slate-600 hover:text-slate-800 hover:border-slate-400 p-2 rounded-full shadow-lg flex items-center justify-center w-10 h-10 transition-all" title="Copy TSV"><i data-lucide="copy" class="w-4 h-4"></i></button>
                <button id="downloadPDFBtn" type="button" class="bg-rose-600 hover:bg-rose-700 text-white p-2 rounded-full shadow-lg flex items-center justify-center w-10 h-10 transition-all" title="Export PDF"><i data-lucide="file-down" class="w-4 h-4"></i></button>
            </div>
        </div>
    </div>
</div>

<div id="toast-container" class="fixed top-4 right-1/2 translate-x-1/2 z-[1000] flex flex-col gap-2 pointer-events-none w-max max-w-[90vw]"></div>

<!-- Staff Modal -->
<div id="staffModal" class="modal hidden fixed inset-0 z-[1001] bg-black/40 backdrop-blur-[1px] items-center justify-center">
    <div class="bg-white rounded-lg w-full max-w-sm shadow-2xl border border-slate-200 m-4">
        <div class="flex justify-between items-center p-3 border-b border-slate-100 bg-slate-50 rounded-t-lg">
            <h3 class="text-sm font-bold text-slate-800" id="modalTitle">Edit Staff</h3>
            <button onclick="rosterSystem.closeModal()" class="text-slate-400 hover:text-slate-700"><i data-lucide="x" class="w-4 h-4"></i></button>
        </div>
        <div class="p-4 space-y-3">
            <input type="hidden" id="modalFirebaseId">
            <div class="flex gap-3">
                <div class="w-1/3"><label class="text-[10px] font-bold text-slate-400 uppercase">ID</label><input type="text" id="modalStaffId" class="w-full mt-1 bg-slate-50 border border-slate-300 rounded px-2 py-1 text-xs font-mono focus:border-indigo-500 focus:outline-none"></div>
                <div class="w-2/3"><label class="text-[10px] font-bold text-slate-400 uppercase">Name</label><input type="text" id="modalName" class="w-full mt-1 bg-slate-50 border border-slate-300 rounded px-2 py-1 text-xs focus:border-indigo-500 focus:outline-none"></div>
            </div>
            <div class="bg-slate-50 p-3 rounded border border-slate-100">
                <label class="text-[10px] font-bold text-indigo-600 uppercase mb-1 block">Break Time</label>
                <div class="flex items-center gap-2">
                    <input type="time" id="modalBreakStart" class="bg-white border border-slate-300 rounded px-2 py-1 text-xs w-full text-center"><span class="text-slate-300 text-[10px]">&rarr;</span><input type="time" id="modalBreakEnd" class="bg-white border border-slate-300 rounded px-2 py-1 text-xs w-full text-center">
                </div>
            </div>
            <div class="grid grid-cols-2 gap-3">
                <div class="bg-slate-50 p-3 rounded border border-slate-100"><label class="text-[10px] font-bold text-slate-500 uppercase mb-1 block">First Hour (20:00)</label><select id="modalStartLoc" class="w-full bg-white border border-slate-300 rounded px-2 py-1 text-xs font-medium text-slate-700 focus:border-indigo-500 focus:outline-none"><option value="">Any</option></select></div>
                <div class="bg-slate-50 p-3 rounded border border-slate-100"><label class="text-[10px] font-bold text-blue-600 uppercase mb-1 block">Vertical Patrol</label><select id="modalVPSlot" class="w-full bg-white border border-slate-300 rounded px-2 py-1 text-xs font-medium text-slate-700 focus:border-indigo-500 focus:outline-none"><option value="">None</option></select></div>
            </div>
            <div class="flex items-center justify-between pt-1"><label class="flex items-center gap-2 cursor-pointer select-none"><input type="checkbox" id="modalHHMD" class="w-4 h-4 text-purple-600 border-slate-300 rounded focus:ring-purple-500"><span class="text-xs font-semibold text-slate-700">HHMD Qualified</span></label></div>
            <div class="flex gap-2 pt-3 border-t border-slate-100 mt-2"><button id="modalDeleteBtn" onclick="rosterSystem.deleteCurrentStaff()" class="hidden px-3 py-1.5 text-xs font-bold text-red-600 bg-red-50 hover:bg-red-100 rounded">Remove</button><div class="flex-1"></div><button onclick="rosterSystem.saveStaffFromModal()" class="px-6 py-1.5 text-xs font-bold text-white bg-indigo-600 hover:bg-indigo-700 rounded shadow-sm">Save</button></div>
        </div>
    </div>
</div>

<div id="settingsModal" class="modal hidden fixed inset-0 z-[1001] bg-black/40 backdrop-blur-[1px] items-center justify-center">
    <div class="bg-white rounded-lg w-full max-w-sm shadow-2xl border border-slate-200 m-4 flex flex-col max-h-[80vh]">
        <div class="flex justify-between items-center p-3 border-b border-slate-100 bg-slate-50 rounded-t-lg shrink-0"><h3 class="text-sm font-bold text-slate-800 flex items-center gap-2"><i data-lucide="settings" class="w-4 h-4"></i> Configuration</h3><button onclick="rosterSystem.closeSettings()" class="text-slate-400 hover:text-slate-700"><i data-lucide="x" class="w-4 h-4"></i></button></div>
        <div class="p-4 overflow-y-auto flex-1">
            <div class="mb-5 pb-5 border-b border-slate-100"><h4 class="text-xs font-bold text-slate-500 uppercase mb-3">Global Settings</h4><div class="flex items-center justify-between bg-slate-50 p-3 rounded border border-slate-200"><div class="flex flex-col"><span class="text-xs font-bold text-slate-700">Standard Break Duration</span><span class="text-[9px] text-slate-400">Updates all staff break end times</span></div><div class="flex items-center gap-1"><input type="number" id="settingBreakDuration" class="w-16 text-center text-xs border border-slate-300 rounded px-1 py-1 font-mono" min="0" step="15" value="60"><span class="text-[10px] text-slate-400 font-bold">mins</span></div></div></div>
            <h4 class="text-xs font-bold text-slate-500 uppercase mb-3">Duty Durations</h4><p class="text-[10px] text-slate-400 mb-3 italic">Set the credit (in minutes) a staff member receives for one slot at each location.</p><div id="settingsList" class="space-y-3"></div>
        </div>
        <div class="p-3 border-t border-slate-100 bg-slate-50 rounded-b-lg shrink-0 flex justify-end"><button onclick="rosterSystem.saveSettings()" class="px-6 py-1.5 text-xs font-bold text-white bg-indigo-600 hover:bg-indigo-700 rounded shadow-sm">Save Configuration</button></div>
    </div>
</div>

<div id="pdfModal" class="modal hidden fixed inset-0 z-50 bg-black/50 backdrop-blur-sm items-center justify-center p-4">
    <div class="bg-white rounded w-full max-w-5xl h-[85vh] flex flex-col shadow-2xl">
        <div class="flex justify-between items-center p-3 border-b bg-slate-50 rounded-t"><h3 class="text-sm font-bold text-slate-700">PDF Preview</h3><div class="flex gap-2"><a id="pdfDownloadLink" href="#" download="roster.pdf" class="bg-slate-800 text-white px-3 py-1 rounded text-xs font-bold hover:bg-black">Download</a><button onclick="rosterSystem.closePdfModal()" class="text-slate-400 hover:text-slate-800"><i data-lucide="x" class="w-5 h-5"></i></button></div></div>
        <div id="pdfPreview" class="flex-1 w-full bg-slate-200 flex items-center justify-center text-slate-600 text-sm px-4 text-center">PDF preview is disabled on iOS to avoid iframe/WebView errors. Please tap <b>Download</b> to open the PDF.</div>
    </div>
</div>

<datalist id="staff-id-list"></datalist>

<script>
const rosterSystem = {
    ROSTER_TIMES: ["20:00", "21:00", "22:00", "23:00", "00:00", "01:00", "02:00", "03:00", "04:00", "05:00", "06:00", "07:00"],
    LOCATIONS: [ { name: "Pass Counter", needed: 2 }, { name: "KIOSK", needed: 1 }, { name: "Lobby", needed: 1 }, { name: "HHMD", needed: 1 }, { name: "Guard House", needed: 1 }, { name: "Report Room", needed: 1 }, { name: "Vertical Patrol", needed: 1 }, { name: "Tango Papa", needed: 1 } ],
    OUTPUT_ORDER: ["Pass Counter", "KIOSK", "Lobby", "HHMD", "Guard House", "Report Room", "Vertical Patrol", "Tango Papa"],
    CRITICAL_DUTIES: { "Vertical Patrol": ["20:00", "23:00", "01:00", "04:00", "06:00"], "Report Room": ["20:00", "21:00"], "Tango Papa": ["07:00"] },
    VP_CYCLES: { "VP-2030": { time: "20:00", label: "20:30" }, "VP-2300": { time: "23:00", label: "23:00" }, "VP-0130": { time: "01:00", label: "01:30" }, "VP-0400": { time: "04:00", label: "04:00" }, "VP-0630": { time: "06:00", label: "06:30" } },
    STANDING_LOCATIONS: ["Lobby", "KIOSK"], // Smart Fatigue Logic
    
    generatedRoster: null, staffDataCache: [], currentFilter: 'all', isFullscreen: false,
    shuffleMode: 'random', _forcedSeed: null, _lastSeed: null, _suppressSave: false, _lastBalancedScore: null,
    durations: {}, breakDuration: 60, currentDateStr: "", rosterUnsubscribe: null,

    init() { 
        lucide.createIcons();
        this.bindModalBreakAutoCalc(); 
        this.setupUI();
        this.initBlueprint();

        // Keep Command Center "current location" badges in sync as time advances
        if (this._ccLocTimer) { try { clearInterval(this._ccLocTimer); } catch(e){} }
        this._ccLocTimer = setInterval(() => {
            if (!this.staffDataCache || !this.staffDataCache.length) return;
            this.renderStaffCards(this.staffDataCache);
        }, 60 * 1000);
    },

    setupUI() {
        document.getElementById("generateRosterBtn").addEventListener("click", () => this.runRosterGeneration());
        document.getElementById("copyTSVBtn").addEventListener("click", () => this.copyTSV());
        // Robust PDF download handler (works even if UI re-renders on mobile)
        document.addEventListener("click", (ev) => {
            const btn = ev.target.closest && ev.target.closest("#downloadPDFBtn");
            if (!btn) return;
            ev.preventDefault();
            ev.stopPropagation();
            this.downloadPDF();
        }, { passive: false });
        document.getElementById("modalStartLoc").addEventListener("change", (e) => this.handleStartLocChange(e));
        const dateInput = document.getElementById("rosterDate");
        dateInput.addEventListener("change", (e) => { this.handleDateChange(e.target.value); });
        document.getElementById("modalBreakStart").addEventListener("change", (e) => {
            const start = e.target.value; if(start) document.getElementById("modalBreakEnd").value = this.calculateEndTime(start, this.breakDuration);
        });
        document.querySelectorAll('.filter-chip').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.filter-chip').forEach(b => { b.classList.remove('active', 'bg-indigo-50', 'text-indigo-700'); b.classList.add('text-slate-400'); });
                e.target.classList.remove('text-slate-400'); e.target.classList.add('active');
                this.currentFilter = e.target.dataset.filter; this.renderStaffCards(this.staffDataCache);
            });
        });
    },

    // --- Command Center: current deployment label (for quick verification) ---
    // Picks the roster time-slot that matches the current clock time (20:00 -> 07:00 shift).
    getCurrentShiftSlotTime() {
        const now = new Date();
        const nowMin = now.getHours() * 60 + now.getMinutes();
        const shiftStart = 20 * 60; // 20:00
        let rel = nowMin - shiftStart;
        if (rel < 0) rel += 24 * 60; // after midnight
        const idx = Math.max(0, Math.min(this.ROSTER_TIMES.length - 1, Math.floor(rel / 60)));
        return this.ROSTER_TIMES[idx];
    },
    // Return the location name for a given staffId at a given roster time (if roster exists)
    getStaffLocationAtTime(roster, staffId, time) {
        if (!roster || !staffId || !time) return "";
        for (const locName of (this.OUTPUT_ORDER || [])) {
            const slots = roster?.[locName]?.[time];
            if (Array.isArray(slots) && slots.includes(staffId)) return locName;
        }
        for (const [locName, timesObj] of Object.entries(roster || {})) {
            const slots = timesObj?.[time];
            if (Array.isArray(slots) && slots.includes(staffId)) return locName;
        }
        return "";
    },
    // The label we show on each ACTIVE staff card
    getDisplayLocationForStaff(staff) {
        // Show FIRST HOUR (20:00) deployment on cards (not "current slot"),
        // so clearing First Hour instantly clears the badge.
        if (!staff || staff.attendance !== 'Yes') return "";
        const time = "20:00";
        const fromRoster = this.getStaffLocationAtTime(this.generatedRoster, staff.staffId, time);
        if (fromRoster) return fromRoster;
        return staff.startLoc || "";
    },


    initializeDate() { 
        const today = new Date(); const year = today.getFullYear(); const month = String(today.getMonth() + 1).padStart(2, '0'); const day = String(today.getDate()).padStart(2, '0'); const dateStr = `${year}-${month}-${day}`;
        document.getElementById("rosterDate").value = dateStr; this.handleDateChange(dateStr);
    },

    async handleDateChange(dateStr) {
        this.currentDateStr = dateStr; if (!dateStr) return;
        const parts = dateStr.split('-'); const dateObj = new Date(parts[0], parts[1] - 1, parts[2]); const dayName = dateObj.toLocaleDateString('en-US', { weekday: 'long' });
        document.getElementById("rosterDay").value = dayName;
        if (this.rosterUnsubscribe) { this.rosterUnsubscribe(); this.rosterUnsubscribe = null; }
        document.getElementById('loadingIndicator').classList.remove('hidden');
        document.getElementById("rosterContainer").innerHTML = `<div class="flex flex-col items-center justify-center h-40 text-slate-400"><i data-lucide="loader-2" class="w-8 h-8 mb-2 animate-spin"></i><p class="text-xs">Loading Roster...</p></div>`;
        this.rosterUnsubscribe = window.firebaseOperations.subscribeToRoster(dateStr, (rosterData) => {
             document.getElementById('loadingIndicator').classList.add('hidden');
             if (rosterData) { this.generatedRoster = rosterData; this.enforceHHMDOnly(this.generatedRoster, { source: 'load' });
                 this.enforceGuardHouseMax2(this.generatedRoster, { source: 'load' }); this.displayRoster(this.generatedRoster); document.getElementById('rosterActionsContainer').classList.remove('hidden'); } 
             else { this.generatedRoster = null; document.getElementById("rosterContainer").innerHTML = `<div class="flex flex-col items-center justify-center h-40 text-slate-400"><i data-lucide="calendar" class="w-10 h-10 mb-2 opacity-20"></i><p class="text-xs">No roster for ${dateStr}</p><p class="text-[10px] mt-1">Click GENERATE to create one</p></div>`; document.getElementById('rosterActionsContainer').classList.add('hidden'); lucide.createIcons(); }
        });
    },
    
    toggleFullscreen() {
        this.isFullscreen = !this.isFullscreen; const panel = document.getElementById("rosterPanel");
        if (this.isFullscreen) { panel.classList.add("fullscreen"); document.querySelector('#toggleFullscreenBtn i').setAttribute('data-lucide', 'minimize'); } else { panel.classList.remove("fullscreen"); document.querySelector('#toggleFullscreenBtn i').setAttribute('data-lucide', 'maximize'); } lucide.createIcons();
    },

    calculateEndTime(startTimeStr, durationMins) {
        if (!startTimeStr) return ""; const [h, m] = startTimeStr.split(':').map(Number); let totalMins = h * 60 + m + parseInt(durationMins); let newH = Math.floor(totalMins / 60) % 24; let newM = totalMins % 60; return `${String(newH).padStart(2, '0')}:${String(newM).padStart(2, '0')}`;
    },

    // Apply global break duration change to all staff cards (updates break END times)
    async applyGlobalBreakDurationToStaff(durationMins) {
        try {
            const staffList = Array.isArray(this.staffDataCache) ? this.staffDataCache : [];
            const updates = [];
            staffList.forEach(staff => {
                const start = staff.breakStart;
                if (!start) return;
                const newEnd = this.calculateEndTime(start, durationMins);
                if (newEnd && staff.breakEnd !== newEnd) {
                    staff.breakEnd = newEnd; // update local cache immediately
                    if (staff.firebaseId) {
                        updates.push(window.firebaseOperations.updateStaff(staff.firebaseId, { breakEnd: newEnd }));
                    }
                }
            });
            if (updates.length) await Promise.all(updates);
            // Re-render cards + break table so UI reflects the new time-out
            this.renderStaffCards(this.staffDataCache);
            this.syncOpenEditModalBreakFields();
            if (this.generatedRoster) this.displayRoster(this.generatedRoster);
        } catch (e) {
            console.error("applyGlobalBreakDurationToStaff failed:", e);
            this.showToast("Failed to apply break duration", "error");
        }
    },


    renderOptions(currentStaffId) {
        const startSelect = document.getElementById("modalStartLoc"); const vpSelect = document.getElementById("modalVPSlot");
        startSelect.innerHTML = '<option value="">Any</option>'; vpSelect.innerHTML = '<option value="">None</option>';
        const usage = { start: {}, vp: {} };
        this.staffDataCache.forEach(s => { if (s.attendance === 'Yes' && s.firebaseId !== currentStaffId) { if (s.startLoc) usage.start[s.startLoc] = (usage.start[s.startLoc] || 0) + 1; if (s.vpSlot) usage.vp[s.vpSlot] = (usage.vp[s.vpSlot] || 0) + 1; } });
        this.LOCATIONS.forEach(loc => { if (loc.name !== "Vertical Patrol") { const count = usage.start[loc.name] || 0; const isFull = count >= loc.needed; const option = document.createElement("option"); option.value = loc.name; option.text = `${loc.name} ${isFull ? '(Full)' : `(${count}/${loc.needed})`}`; if (isFull) { option.disabled = true; option.classList.add('text-slate-400', 'italic'); } startSelect.appendChild(option); } });
        for (const [key, config] of Object.entries(this.VP_CYCLES)) { const count = usage.vp[key] || 0; const isFull = count >= 1; const option = document.createElement("option"); option.value = key; option.text = `${config.label} ${isFull ? '(Taken)' : ''}`; if (isFull) { option.disabled = true; option.classList.add('text-slate-400', 'italic'); } vpSelect.appendChild(option); }
    },

    handleStartLocChange(e) {
        const vpSelect = document.getElementById("modalVPSlot"); Array.from(vpSelect.options).forEach(opt => opt.disabled = opt.text.includes('(Taken)')); 
        if (e.target.value !== "") { const vp2030Opt = Array.from(vpSelect.options).find(o => o.value === "VP-2030"); if (vp2030Opt) vp2030Opt.disabled = true; if (vpSelect.value === "VP-2030") vpSelect.value = ""; }
    },

    renderStaffCards(staffList) {
        const grid = document.getElementById('staffGrid'); grid.innerHTML = ''; let filteredList = staffList;
        if (this.currentFilter === 'present') filteredList = staffList.filter(s => s.attendance === 'Yes'); if (this.currentFilter === 'hhmd') filteredList = staffList.filter(s => s.hhmd === 'Yes');
        if (filteredList.length === 0) { grid.innerHTML = `<div class="col-span-2 text-center py-6 text-xs text-slate-400 italic">No staff found.</div>`; return; }
        filteredList.forEach(staff => {
            const isPresent = staff.attendance === 'Yes';
            const initials = staff.name.split(' ').map(n => n[0]).join('').slice(0, 2).toUpperCase();
            const colorIndex = (staff.staffId.charCodeAt(staff.staffId.length - 1) || 0) % 8;

            const locLabel = this.getDisplayLocationForStaff(staff);
            const locBadge = locLabel ? `<div class="flex items-center gap-1 text-slate-500 font-semibold bg-slate-50 px-1.5 py-0.5 rounded border border-slate-100 max-w-[110px]" title="First hour (20:00) deployment">
                <i data-lucide="map-pin" class="w-3 h-3 text-slate-400"></i>
                <span class="truncate">${locLabel}</span>
            </div>` : "";


            let indicators = "";
            if (staff.startLoc) indicators += `<div class="w-2 h-2 bg-indigo-500 rounded-full shadow-sm ring-1 ring-white"></div>`;
            if (staff.vpSlot) indicators += `<div class="w-2 h-2 bg-blue-500 rounded-full shadow-sm ring-1 ring-white"></div>`;
            if (indicators) indicators = `<div class="absolute -top-1 -right-1 flex gap-0.5">${indicators}</div>`;

            // Quick VP assignment options (advance assignment from Command Center)
            const vpOptionsHTML = [
                `<option value="">VP: None</option>`,
                ...Object.entries(this.VP_CYCLES).map(([key, cfg]) => {
                    const isTakenByOther = this.staffDataCache.some(s => s.vpSlot === key && s.firebaseId !== staff.firebaseId);
                    const selected = (staff.vpSlot === key) ? 'selected' : '';
                    const disabled = isTakenByOther ? 'disabled' : '';
                    const takenTxt = isTakenByOther ? ' (Taken)' : '';
                    return `<option value="${key}" ${selected} ${disabled}>VP ${cfg.label}${takenTxt}</option>`;
                })
            ].join('');

            const card = document.createElement('div');
            card.className = `staff-card h-16 rounded flex items-center pr-2 pl-2 gap-3 ${!isPresent ? 'inactive' : ''}`;

            card.innerHTML =
`<button onclick="rosterSystem.toggleAttendance('${staff.firebaseId}', '${staff.attendance}')" class="w-8 h-8 rounded-full flex items-center justify-center transition-all shrink-0 ${isPresent ? 'bg-green-100 text-green-600 hover:bg-green-200' : 'bg-slate-100 text-slate-300 hover:bg-slate-200'}"><i data-lucide="power" class="w-4 h-4"></i></button>
<div class="relative w-10 h-10 rounded shrink-0 avatar-bg-${colorIndex} flex items-center justify-center text-white font-bold text-xs cursor-pointer avatar shadow-sm" onclick="rosterSystem.openEditModal('${staff.firebaseId}')">${initials}${indicators}</div>
<div class="flex flex-col min-w-0 flex-1 cursor-pointer justify-center" onclick="rosterSystem.openEditModal('${staff.firebaseId}')">
  <div class="flex items-center gap-1.5 mb-0.5">
    <span class="text-sm font-bold text-slate-800 truncate leading-tight">${staff.name}</span>
    ${staff.hhmd === 'Yes' ? `<div class="w-2 h-2 rounded-full bg-purple-500 ring-2 ring-white" title="HHMD Qualified"></div>` : ''}
  </div>
  <div class="flex items-center justify-between text-xs w-full">
    <span class="font-mono font-bold text-slate-600 bg-slate-100 px-1 rounded">${staff.staffId}</span>
    <div class="flex items-center gap-1.5">
      ${locBadge}
      <div class="flex items-center gap-1 text-slate-500 font-semibold bg-slate-50 px-1.5 py-0.5 rounded border border-slate-100">
        <i data-lucide="clock" class="w-3 h-3 text-slate-400"></i>
        <span>${staff.breakStart}-${staff.breakEnd}</span>
      </div>
      <select class="vp-quick text-[10px] font-bold bg-white border border-slate-200 rounded px-1 py-0.5 text-slate-700 max-w-[92px]" data-fbid="${staff.firebaseId}" title="Advance Vertical Patrol assignment">
        ${vpOptionsHTML}
      </select>
    </div>
  </div>
</div>`;
            grid.appendChild(card);
        });

// Bind quick VP assignment events (prevent modal open when interacting with select)
grid.querySelectorAll('.vp-quick').forEach(sel => {
            sel.addEventListener('click', (e) => e.stopPropagation());
            sel.addEventListener('mousedown', (e) => e.stopPropagation());
            sel.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
            sel.addEventListener('change', (e) => {
                e.stopPropagation();
                rosterSystem.setVPSlotQuick(e.target.dataset.fbid, e.target.value);
            });
        });
        lucide.createIcons();
    },
    
    // Quick advance assignment for Vertical Patrol (Command Center card level)
    async setVPSlotQuick(firebaseId, newSlot) {
        const staff = this.staffDataCache.find(s => s.firebaseId === firebaseId);
        if (!staff) return;

        // No change
        if ((staff.vpSlot || "") === (newSlot || "")) return;

        // If assigning a VP slot that is already taken by someone else, offer to swap
        if (newSlot) {
            const other = this.staffDataCache.find(s => s.vpSlot === newSlot && s.firebaseId !== firebaseId);
            if (other) {
                const label = this.VP_CYCLES?.[newSlot]?.label || newSlot;
                const ok = confirm(`VP ${label} is already assigned to ${other.name} (${other.staffId}).\n\nSwap it to ${staff.name} (${staff.staffId})?`);
                if (!ok) {
                    // Re-render to revert the dropdown selection
                    this.renderStaffCards(this.staffDataCache);
                    return;
                }
                // Optimistic update
                other.vpSlot = "";
                await window.firebaseOperations.updateStaff(other.firebaseId, { vpSlot: "" });
            }
        }

        // Optimistic update for immediate UI
        staff.vpSlot = newSlot || "";
        await window.firebaseOperations.updateStaff(firebaseId, { vpSlot: newSlot || "" });

        this.showToast("Vertical Patrol updated", "success");
        this.renderStaffCards(this.staffDataCache);
        // If roster already generated, re-validate / reflect predefined VP assignments
        if (this.generatedRoster) this.validateAllCells();
    },

    updateStats() {
        const total = this.staffDataCache.length; const present = this.staffDataCache.filter(s => s.attendance === 'Yes').length; const hhmd = this.staffDataCache.filter(s => s.hhmd === 'Yes' && s.attendance === 'Yes').length;
        document.getElementById('stat-total').textContent = total; document.getElementById('stat-present').textContent = present; document.getElementById('stat-hhmd').textContent = hhmd; document.getElementById('stat-present-m').textContent = present;
    },
    updateStaffDatalist() {
        const datalist = document.getElementById('staff-id-list'); if (!datalist) return; const presentStaff = this.staffDataCache.filter(s => s.attendance === 'Yes'); 
        this.currentPoolCount = presentStaff.length;
datalist.innerHTML = presentStaff.map(s => `<option value="${s.staffId}"></option>`).join('');
    },
    getActiveStaffOptionsHtml(selectedId='') {
        const presentStaff = this.staffDataCache.filter(s => s.attendance === 'Yes');
        const sid = String(selectedId ?? '').trim();
        const opts = ['<option value="">--</option>'];
        presentStaff.forEach(s => {
            const v = String(s.staffId ?? '').trim();
            if (!v) return;
            const sel = (v === sid) ? ' selected' : '';
            opts.push(`<option value="${v}"${sel}>${v}</option>`);
        });
        return opts.join('');
    },

// ---- Break time utilities (used by cards + edit modal + break table) ----
timeToMinutesHHMM(t) {
    if (!t || typeof t !== 'string' || !t.includes(':')) return NaN;
    const [h, m] = t.split(':').map(n => parseInt(n, 10));
    if (Number.isNaN(h) || Number.isNaN(m)) return NaN;
    return (h * 60) + m;
},
minutesToHHMM(totalMin) {
    let m = totalMin % (24 * 60);
    if (m < 0) m += 24 * 60;
    const hh = String(Math.floor(m / 60)).padStart(2, '0');
    const mm = String(m % 60).padStart(2, '0');
    return `${hh}:${mm}`;
},
addMinutesToHHMM(startHHMM, addMins) {
    const base = this.timeToMinutesHHMM(startHHMM);
    if (Number.isNaN(base)) return "00:00";
    return this.minutesToHHMM(base + (parseInt(addMins, 10) || 0));
},
computeBreakEndFromStart(startHHMM) {
    return this.addMinutesToHHMM(startHHMM, this.breakDuration || 60);
},
syncOpenEditModalBreakFields() {
    const modal = document.getElementById('staffModal');
    if (!modal || modal.classList.contains('hidden')) return;
    const fbId = document.getElementById('modalFirebaseId')?.value;
    if (!fbId) return;
    const staff = this.staffDataCache.find(s => s.firebaseId === fbId);
    if (!staff) return;

    const startEl = document.getElementById('modalBreakStart');
    const endEl = document.getElementById('modalBreakEnd');
    if (!startEl || !endEl) return;

    // Keep the user's selected start time, but always sync end time from latest staff record.
    startEl.value = staff.breakStart || startEl.value || "22:00";
    endEl.value = staff.breakEnd || this.computeBreakEndFromStart(startEl.value);
},
bindModalBreakAutoCalc() {
    const startEl = document.getElementById('modalBreakStart');
    const endEl = document.getElementById('modalBreakEnd');
    if (!startEl || !endEl) return;

    // Whenever break START changes in the edit modal, auto recompute END using global break duration.
    startEl.addEventListener('change', () => {
        endEl.value = this.computeBreakEndFromStart(startEl.value);
    });
    startEl.addEventListener('input', () => {
        // lightweight live update (helps iOS picker)
        endEl.value = this.computeBreakEndFromStart(startEl.value);
    });
},

    
// --- HHMD Post-Generation Enforcement (Hard Rule) ---
isHHMDQualified(staffMember) {
  const raw = (staffMember?.hhmd ?? staffMember?.hhmdQualified ?? staffMember?.isHHMD ?? staffMember?.HHMD ?? '').toString().trim().toLowerCase();
  if (raw === 'yes' || raw === 'y' || raw === 'true' || raw === '1' || raw === 'hhmd') return true;
  // Some datasets store HHMD as boolean
  if (staffMember?.hhmd === true || staffMember?.hhmdQualified === true || staffMember?.isHHMD === true) return true;
  return false;
},

enforceHHMDOnly(roster, opts = {}) {
  try {
    if (!roster || !roster.HHMD) return { fixed: 0, invalid: [] };

    const invalid = [];
    let fixed = 0;

    for (const time of this.ROSTER_TIMES || []) {
      const cell = roster.HHMD?.[time];
      if (!cell || !Array.isArray(cell)) continue;

      for (let i = 0; i < cell.length; i++) {
        const id = cell[i];
        if (!id) continue;

        const staff = this.staffDataCache?.find(s => {
          const keys = [s?.id, s?.empId, s?.staffId];
          return keys.some(v => v != null && v.toString() === id.toString());
        });
        if (!this.isHHMDQualified(staff)) {
          invalid.push({ time, id });
          cell[i] = '';
          fixed++;
        }
      }
    }

    // Optional: show a warning toast (non-blocking)
    if (fixed > 0 && !opts.silent) {
      this.toast?.(`HHMD enforcement: removed ${fixed} non-HHMD assignment(s)`, 'warn');
    }

    return { fixed, invalid };
  } catch (e) {
    console.warn('enforceHHMDOnly failed', e);
    return { fixed: 0, invalid: [] };
  }
},

toggleAttendance(id, currentStatus) { window.firebaseOperations.updateStaff(id, { attendance: currentStatus === 'Yes' ? 'No' : 'Yes' }); },
    openAddModal() {
        document.getElementById('modalTitle').innerText = "Add Staff"; document.getElementById('modalFirebaseId').value = ""; document.getElementById('modalStaffId').value = `S${Math.floor(Math.random()*9000)+1000}`; document.getElementById('modalName').value = ""; document.getElementById('modalBreakStart').value = "22:00"; document.getElementById('modalBreakEnd').value = this.computeBreakEndFromStart("22:00"); this.renderOptions(null); document.getElementById('modalStartLoc').value = ""; document.getElementById('modalVPSlot').value = ""; document.getElementById('modalHHMD').checked = false; document.getElementById('modalDeleteBtn').classList.add('hidden'); document.getElementById('staffModal').classList.remove('hidden'); document.getElementById('staffModal').classList.add('flex');
    },
    // === Break Timeline: Drag to adjust break start/end ===
    initBreakTimelineDrag() {
    if (this._btDragInit) return;
    this._btDragInit = true;

    this._btDragState = { active: false };

    const DRAG_THRESHOLD_PX = 6; // direction-lock threshold (mobile friendly)

    document.addEventListener('pointerdown', (e) => {
        const root = document.getElementById('breakTimelineRoot');
        if (!root || !root.contains(e.target)) return;

        const seg = e.target.closest('.bt-seg');
        if (!seg) return;

        // If we are already dragging, ignore new pointers.
        if (this._btDragState.active) return;

        const track = seg.parentElement; // relative bar track
        const trackRect = track.getBoundingClientRect();

        const shiftStart = 20 * 60;
        const shiftEnd = (24 + 8) * 60;
        const total = shiftEnd - shiftStart;
        const snap = 30; // minutes

        const toShiftMin = (hhmm) => {
            const base = this.timeToMinutesHHMM(hhmm);
            if (Number.isNaN(base)) return NaN;
            return (base < shiftStart) ? (base + 24 * 60) : base;
        };
        const fromShiftMin = (m) => {
            let mm = m;
            if (mm >= 24 * 60) mm -= 24 * 60;
            return this.minutesToHHMM(mm);
        };
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const snapMin = (v) => Math.round(v / snap) * snap;

        const fixedDur = Number(this.breakDuration || 60);

        // current mins
        let startMin = toShiftMin(seg.getAttribute('data-break-start') || '00:00');
        if (!Number.isFinite(startMin)) startMin = shiftStart;

        // enforce fixed duration
        startMin = clamp(startMin, shiftStart, shiftEnd - fixedDur);
        let endMin = startMin + fixedDur;

        const renderSeg = (sMin, eMin) => {
            const leftPct = ((sMin - shiftStart) / total) * 100;
            const widthPct = ((eMin - sMin) / total) * 100;
            seg.style.left = `${leftPct}%`;
            seg.style.width = `${Math.max(0.5, widthPct)}%`;

            const row = seg.closest('.bt-row');
            if (row) {
                const guide = row.querySelector('.bt-guide');
                if (guide) guide.style.left = `${leftPct}%`;

                const lab = row.querySelector('.bt-range');
                if (lab) lab.textContent = `${fromShiftMin(sMin)}â€“${fromShiftMin(eMin)}`;
            }
        };

        const pointerId = e.pointerId;
        const downX = e.clientX;
        const downY = e.clientY;
        let decided = false;

        const cleanupDecision = () => {
            document.removeEventListener('pointermove', onDecideMove);
            document.removeEventListener('pointerup', onDecideUp);
            document.removeEventListener('pointercancel', onDecideUp);
        };

        const onDecideMove = (ev) => {
            if (ev.pointerId !== pointerId) return;

            const dx = ev.clientX - downX;
            const dy = ev.clientY - downY;

            // Wait until user movement is clear enough
            if (!decided && (Math.abs(dx) + Math.abs(dy) < DRAG_THRESHOLD_PX)) return;

            if (!decided) {
                decided = true;

                // If user is scrolling vertically, do NOT hijack the gesture.
                if (Math.abs(dy) > Math.abs(dx)) {
                    cleanupDecision();
                    return; // allow normal vertical scroll
                }

                // User intends horizontal drag -> start drag mode
                cleanupDecision();

                this._btDragState.active = true;

                // capture pointer so it won't "slip" off the seg while dragging
                try { seg.setPointerCapture(pointerId); } catch (_) {}

                ev.preventDefault();

                const startStart = startMin;
                const startX2 = ev.clientX;

                const pxToMin = (dx2) => (dx2 / trackRect.width) * total;

                const onMove = (mv) => {
                    if (mv.pointerId !== pointerId) return;
                    // Prevent horizontal scroll while dragging, but vertical scroll was already rejected at decision phase.
                    mv.preventDefault();

                    const dx3 = mv.clientX - startX2;
                    const deltaMin = pxToMin(dx3);

                    let s = snapMin(startStart + deltaMin);
                    s = clamp(s, shiftStart, shiftEnd - fixedDur);
                    startMin = s;
                    endMin = s + fixedDur;
                    renderSeg(startMin, endMin);
                };

                const onUp = async (up) => {
                    if (up.pointerId !== pointerId) return;
                    document.removeEventListener('pointermove', onMove);
                    document.removeEventListener('pointerup', onUp);
                    document.removeEventListener('pointercancel', onUp);

                    try { seg.releasePointerCapture(pointerId); } catch (_) {}

                    this._btDragState.active = false;

                    const breakStart = fromShiftMin(startMin);
                    const breakEnd = fromShiftMin(endMin);

                    await this.setStaffBreakByStaffId(seg.getAttribute('data-staff-id'), breakStart, breakEnd, true);

                    this.renderStaffCards(this.staffDataCache);
                    this.syncOpenEditModalBreakFields();
                    if (this.generatedRoster) this.displayRoster(this.generatedRoster);
                };

                document.addEventListener('pointermove', onMove, { passive: false });
                document.addEventListener('pointerup', onUp, { passive: false });
                document.addEventListener('pointercancel', onUp, { passive: false });

                return;
            }
        };

        const onDecideUp = (ev) => {
            if (ev.pointerId !== pointerId) return;
            cleanupDecision();
        };

        document.addEventListener('pointermove', onDecideMove, { passive: false });
        document.addEventListener('pointerup', onDecideUp, { passive: true });
        document.addEventListener('pointercancel', onDecideUp, { passive: true });
    }, { passive: false });
},

    async setStaffBreakByStaffId(staffId, breakStart, breakEnd, persist = true) {
        const staff = this.staffDataCache.find(s => String(s.staffId) === String(staffId));
        if (!staff) return;

        staff.breakStart = breakStart;
        staff.breakEnd = breakEnd;

        // If modal is open for this staff, sync fields immediately
        const fbId = staff.firebaseId;
        if (persist && fbId && window.firebaseOperations?.updateStaff) {
            try {
                await window.firebaseOperations.updateStaff(fbId, { breakStart, breakEnd });
                this.showToast(`Break updated: ${staffId}`, "success");
            } catch (e) {
                console.error("Failed to persist break update:", e);
                this.showToast("Failed to save break time", "error");
            }
        }
    },

    openEditModal(id) {
        const staff = this.staffDataCache.find(s => s.firebaseId === id); if(!staff) return;
        document.getElementById('modalTitle').innerText = "Edit Staff"; document.getElementById('modalFirebaseId').value = staff.firebaseId; document.getElementById('modalStaffId').value = staff.staffId; document.getElementById('modalName').value = staff.name; document.getElementById('modalBreakStart').value = staff.breakStart || "22:00"; const __bs = document.getElementById('modalBreakStart').value; const __beRaw = (staff.breakEnd || "").trim(); const __be = (!__beRaw || (__beRaw === "00:00" && __bs !== "00:00")) ? this.computeBreakEndFromStart(__bs) : __beRaw; document.getElementById('modalBreakEnd').value = __be; this.renderOptions(staff.firebaseId); document.getElementById('modalStartLoc').value = staff.startLoc || ""; document.getElementById('modalVPSlot').value = staff.vpSlot || ""; document.getElementById('modalHHMD').checked = staff.hhmd === 'Yes'; document.getElementById('modalDeleteBtn').classList.remove('hidden'); document.getElementById('staffModal').classList.remove('hidden'); document.getElementById('staffModal').classList.add('flex');
        this.handleStartLocChange({target: {value: staff.startLoc || ""}});
    },
    closeModal() { document.getElementById('staffModal').classList.add('hidden'); document.getElementById('staffModal').classList.remove('flex'); },
    
    async saveStaffFromModal() {
        const id = document.getElementById('modalFirebaseId').value;

        const staffIdVal = document.getElementById('modalStaffId').value;
        const startLocVal = document.getElementById('modalStartLoc').value || "";
        const vpSlotVal = document.getElementById('modalVPSlot').value || "";

        const data = {
            staffId: staffIdVal,
            name: document.getElementById('modalName').value || "Unknown",
            breakStart: document.getElementById('modalBreakStart').value,
            breakEnd: document.getElementById('modalBreakEnd').value,
            hhmd: document.getElementById('modalHHMD').checked ? 'Yes' : 'No',
            startLoc: startLocVal,
            vpSlot: vpSlotVal,
            attendance: 'Yes'
        };

        if (!data.breakEnd) data.breakEnd = this.computeBreakEndFromStart(data.breakStart);

        // Helper: sync roster (20:00) on screen so clears/changes are immediately visible.
        const syncStartLocToRoster20 = (staffId, newLoc) => {
            if (!this.generatedRoster) return;
            const time = "20:00";

            const getNeeded = (locName) => {
                const cfg = (this.LOCATIONS || []).find(l => l.name === locName);
                return Number(cfg?.needed || 0);
            };

            // Ensure 20:00 arrays exist with correct length, then remove staffId from all
            for (const locName of (this.OUTPUT_ORDER || [])) {
                if (!this.generatedRoster[locName]) this.generatedRoster[locName] = {};
                if (!Array.isArray(this.generatedRoster[locName][time])) {
                    this.generatedRoster[locName][time] = new Array(getNeeded(locName)).fill('');
                }
                this.generatedRoster[locName][time] = this.generatedRoster[locName][time].map(v => (String(v) === String(staffId) ? '' : v));
            }

            // Add back if a new location is selected
            if (newLoc) {
                if (!this.generatedRoster[newLoc]) this.generatedRoster[newLoc] = {};
                if (!Array.isArray(this.generatedRoster[newLoc][time])) {
                    this.generatedRoster[newLoc][time] = new Array(getNeeded(newLoc)).fill('');
                }
                const arr = this.generatedRoster[newLoc][time];
                let idx = arr.findIndex(x => !x);
                if (idx === -1) idx = arr.length;
                arr[idx] = staffId;
            }

            this.displayRoster(this.generatedRoster);
            if (typeof this.validateAllCells === "function") this.validateAllCells();
        };

        try {
            if (id) {
                delete data.attendance;

                // Capture old values for UI sync
                const staff = (this.staffDataCache || []).find(s => s.firebaseId === id);
                const oldStart = staff?.startLoc || "";
                const oldVp = staff?.vpSlot || "";

                await window.firebaseOperations.updateStaff(id, data);

                // Update local cache immediately
                if (staff) {
                    staff.staffId = data.staffId;
                    staff.name = data.name;
                    staff.breakStart = data.breakStart;
                    staff.breakEnd = data.breakEnd;
                    staff.hhmd = data.hhmd;
                    staff.startLoc = data.startLoc;
                    staff.vpSlot = data.vpSlot;
                }

                // If startLoc changed OR cleared, sync roster 20:00 immediately
                if (oldStart !== data.startLoc) {
                    syncStartLocToRoster20(data.staffId, data.startLoc);
                }

                this.renderStaffCards(this.staffDataCache);
                this.showToast("Saved", "success");
            } else {
                await window.firebaseOperations.addStaff(data);
                this.showToast("Added", "success");
            }
        } catch (e) {
            console.error("saveStaffFromModal error:", e);
            this.showToast("Save failed", "error");
        }

        this.closeModal();
    },

    deleteCurrentStaff() { const id = document.getElementById('modalFirebaseId').value; if(confirm("Remove?")) { window.firebaseOperations.deleteStaff(id); this.closeModal(); } },
    
    openSettings() {
        document.getElementById('settingBreakDuration').value = this.breakDuration; const list = document.getElementById('settingsList');
        list.innerHTML = this.OUTPUT_ORDER.map(locName => { const currentDur = this.durations[locName] || (locName === 'Vertical Patrol' ? 90 : 60); return `<div class="flex items-center justify-between bg-slate-50 p-2 rounded border border-slate-200"><span class="text-xs font-bold text-slate-700">${locName}</span><div class="flex items-center gap-1"><input type="number" id="dur-${locName.replace(/\s+/g, '-')}" value="${currentDur}" class="w-16 text-center text-xs border border-slate-300 rounded px-1 py-1 font-mono" min="0" step="15"><span class="text-[10px] text-slate-400 font-bold">mins</span></div></div>`; }).join('');
        document.getElementById('settingsModal').classList.remove('hidden'); document.getElementById('settingsModal').classList.add('flex');
    },
    closeSettings() { document.getElementById('settingsModal').classList.add('hidden'); document.getElementById('settingsModal').classList.remove('flex'); },
    async saveSettings() {
        const newBreakDur = parseInt(document.getElementById('settingBreakDuration').value) || 60;
        const newDurations = {};
        this.OUTPUT_ORDER.forEach(locName => {
            const val = document.getElementById(`dur-${locName.replace(/\s+/g, '-')}`).value;
            newDurations[locName] = parseInt(val) || 60;
        });

        // 1) Save settings (durations + global break duration)
        await window.firebaseOperations.saveSettings({ locationDurations: newDurations, breakDuration: newBreakDur });
        this.durations = newDurations;
        this.breakDuration = newBreakDur;

        // 2) IMPORTANT: Apply the new global break duration to staff break END times
        //    so the Staff Command Center cards reflect the updated "time out".
        await this.applyGlobalBreakDurationToStaff(newBreakDur);
        this.syncOpenEditModalBreakFields();

        this.showToast("Saved", "success");
        this.closeSettings();
        if (this.generatedRoster) this.validateAllCells();
    },

    shuffleBreaks() {
        const present = this.staffDataCache.filter(s => s.attendance === 'Yes'); if (present.length < 2) return this.showToast("Need more staff", "warning");
        let times = present.map(s => ({ s: s.breakStart, e: s.breakEnd })); for (let i = times.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [times[i], times[j]] = [times[j], times[i]]; }
        present.forEach((staff, idx) => { window.firebaseOperations.updateStaff(staff.firebaseId, { breakStart: times[idx].s, breakEnd: times[idx].e }); }); this.showToast("Breaks shuffled", "success");
    },

    // Shuffle first-hour (20:00) START location assignments, excluding Vertical Patrol.
    // This updates staff.startLoc in Firestore and immediately refreshes Command Center cards.
        // Shuffle 20:00 (1st hour) deployment in Command Center.
    // - Omits Vertical Patrol from the shuffle pool
    // - Keeps your existing constraints (HHMD qualification, Lobby rule when pool<=6, skip Report Room on weekend)
    // - Updates both Firestore (staff.startLoc) AND the currently displayed generated roster (20:00 column) so user sees the effect immediately.
        async shuffleFirstHourDeploy() {
        const time = "20:00";
        const present = (this.staffDataCache || []).filter(s => s.attendance === 'Yes');
        if (present.length === 0) return this.showToast("No active staff", "warning");

        const dayVal = document.getElementById('rosterDay')?.value || "";
        const isWeekend = ['Saturday', 'Sunday'].includes(dayVal);

        // Build slot targets from LOCATION config (needed counts), omitting Vertical Patrol.
        const slots = [];
        for (const locName of (this.OUTPUT_ORDER || [])) {
            if (locName === 'Vertical Patrol') continue;

            // If CRITICAL_DUTIES exists, only include locations that operate at 20:00
            if (this.CRITICAL_DUTIES?.[locName] && !this.CRITICAL_DUTIES[locName].includes(time)) continue;

            if (locName === "Report Room" && isWeekend) continue;
            // RULE: When POOL <= 6, Lobby must remain empty
            if (locName === "Lobby" && present.length <= 6) continue;

            const locCfg = (this.LOCATIONS || []).find(l => l.name === locName);
            if (!locCfg) continue;

            const needed = Number(locCfg.needed || 0);
            for (let i = 0; i < needed; i++) slots.push(locName);
        }

        // If VP is omitted, we can end up with fewer slots than staff.
        // Fill remaining staff into a sensible fallback (non-VP) so EVERY active staff gets a start location.
        const pickFallbackLoc = () => {
            const candidates = ["Tango Papa", "Pass Counter", "KIOSK", "Guard House", "HHMD", "Lobby", "Report Room"];
            for (const name of candidates) {
                if (name === "Lobby" && present.length <= 6) continue;
                if (name === "Report Room" && isWeekend) continue;
                if (!(this.OUTPUT_ORDER || []).includes(name)) continue;
                if (!(this.LOCATIONS || []).some(l => l.name === name)) continue;
                if (this.CRITICAL_DUTIES?.[name] && !this.CRITICAL_DUTIES[name].includes(time)) continue;
                return name;
            }
            return (this.OUTPUT_ORDER || []).find(x => x !== "Vertical Patrol") || "";
        };

        const fallbackLoc = pickFallbackLoc();
        while (slots.length < present.length && fallbackLoc) slots.push(fallbackLoc);

        if (slots.length === 0) return this.showToast("No start-hour slots to shuffle", "warning");

        const shuffleInPlace = (arr) => {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        };

        // Randomize staff order + slot order
        const staffOrder = shuffleInPlace(present.slice());
        const slotOrder = shuffleInPlace(slots.slice());

        const assignments = new Map(); // fbId -> locationName
        const used = new Set();

        let cursor = 0;
        for (const loc of slotOrder) {
            let chosen = null;

            for (let step = 0; step < staffOrder.length; step++) {
                const cand = staffOrder[(cursor + step) % staffOrder.length];
                if (!cand?.firebaseId) continue;
                if (used.has(cand.firebaseId)) continue;

                // HHMD requires qualification
                if (loc === "HHMD" && cand.hhmd !== "Yes") continue;

                chosen = cand;
                cursor = (cursor + step + 1) % staffOrder.length;
                break;
            }

            if (!chosen) continue;
            used.add(chosen.firebaseId);
            assignments.set(chosen.firebaseId, loc);
        }

        // If any staff still unassigned (edge case), drop them into fallback too
        for (const s of present) {
            if (!s?.firebaseId) continue;
            if (!assignments.has(s.firebaseId)) assignments.set(s.firebaseId, fallbackLoc || "");
        }

        // Persist to Firestore + update cache
        const tasks = [];
        for (const [fbId, loc] of assignments.entries()) {
            const staff = (this.staffDataCache || []).find(x => x.firebaseId === fbId);
            if (staff) staff.startLoc = loc;

            if (window.firebaseOperations?.updateStaff) {
                tasks.push(window.firebaseOperations.updateStaff(fbId, { startLoc: loc }));
            }
        }

        try {
            await Promise.all(tasks);
        } catch (e) {
            console.error("shuffleFirstHourDeploy update errors:", e);
            this.showToast("Some start-hour updates failed", "warning");
        }

        // Reflect immediately in the generated roster (20:00 column) if a roster is already on screen
        if (this.generatedRoster) {
            const getNeeded = (locName) => {
                const cfg = (this.LOCATIONS || []).find(l => l.name === locName);
                return Number(cfg?.needed || 0);
            };

            // 1) Clear current 20:00 placements (keep correct array length so displayRoster overwrites properly)
            for (const locName of (this.OUTPUT_ORDER || [])) {
                if (!this.generatedRoster[locName]) this.generatedRoster[locName] = {};
                const needed = getNeeded(locName);
                this.generatedRoster[locName][time] = new Array(needed).fill('');
            }

            // 2) Apply new placements: push into next empty slot
            const placeInLoc = (locName, staffId) => {
                if (!locName || !staffId) return;
                if (locName === "Vertical Patrol") return; // explicitly omit
                if (!this.generatedRoster[locName]) this.generatedRoster[locName] = {};
                if (!Array.isArray(this.generatedRoster[locName][time])) {
                    this.generatedRoster[locName][time] = new Array(getNeeded(locName)).fill('');
                }
                const arr = this.generatedRoster[locName][time];
                let idx = arr.findIndex(x => !x);
                if (idx === -1) idx = arr.length; // overflow (should be rare)
                arr[idx] = staffId;
            };

            for (const [fbId, locName] of assignments.entries()) {
                const staff = (this.staffDataCache || []).find(x => x.firebaseId === fbId);
                const staffId = staff?.staffId;
                if (!staffId) continue;
                placeInLoc(locName, staffId);
            }

            this.displayRoster(this.generatedRoster);
            if (typeof this.validateAllCells === "function") this.validateAllCells();
        }

        this.renderStaffCards(this.staffDataCache);
        this.showToast("1st hour shuffled (Vertical Patrol omitted)", "success");
        this.syncOpenEditModalBreakFields();
    },

        clearAssignments() {
        if(!confirm("Clear FIRST HOUR (20:00) + VP selections? (HHMD qualification is NOT changed)")) return;

        const present = (this.staffDataCache || []).filter(s => s.attendance === 'Yes');
        const updatesTasks = [];

        // Clear selections in cache + Firestore
        (this.staffDataCache || []).forEach(staff => {
            if (!staff?.firebaseId) return;

            const updates = {};
            let changed = false;

            if (staff.startLoc) { updates.startLoc = ""; staff.startLoc = ""; changed = true; }
            if (staff.vpSlot) { updates.vpSlot = ""; staff.vpSlot = ""; changed = true; }

            if (changed && window.firebaseOperations?.updateStaff) {
                updatesTasks.push(window.firebaseOperations.updateStaff(staff.firebaseId, updates));
            }
        });

        Promise.allSettled(updatesTasks).then(() => {
            // Also clear on-screen 20:00 placements immediately so user sees it.
            if (this.generatedRoster) {
                const time = "20:00";
                const getNeeded = (locName) => {
                    const cfg = (this.LOCATIONS || []).find(l => l.name === locName);
                    return Number(cfg?.needed || 0);
                };
                for (const locName of (this.OUTPUT_ORDER || [])) {
                    if (!this.generatedRoster[locName]) this.generatedRoster[locName] = {};
                    this.generatedRoster[locName][time] = new Array(getNeeded(locName)).fill('');
                }
                this.displayRoster(this.generatedRoster);
                if (typeof this.validateAllCells === "function") this.validateAllCells();
            }

            this.renderStaffCards(this.staffDataCache);
            this.syncOpenEditModalBreakFields();
            this.showToast("Cleared first-hour + VP selections", "success");
        });
    },

    // --- FILL GAPS ---
    fillRosterGaps() {
        if (!this.generatedRoster) return this.showToast("No roster to fill", "warning");
        const presentStaff = this.staffDataCache.filter(s => s.attendance === 'Yes');
        
        this.currentPoolCount = presentStaff.length;
const roster = JSON.parse(JSON.stringify(this.generatedRoster)); 
        
        const assignmentsByStaff = Object.fromEntries(presentStaff.map(s => [s.staffId, []]));
        const staffMap = Object.fromEntries(presentStaff.map(s => [s.staffId, s]));
        const verticalPatrolTracker = new Set();
        
        this.OUTPUT_ORDER.forEach(locName => {
            this.ROSTER_TIMES.forEach(time => {
                const slots = roster[locName]?.[time] || [];
                slots.forEach(sId => {
                    if (sId && staffMap[sId]) {
                        if (!assignmentsByStaff[sId]) assignmentsByStaff[sId] = [];
                        assignmentsByStaff[sId].push(time);
                        if (locName === 'Vertical Patrol' || locName === 'Tango Papa') verticalPatrolTracker.add(sId);
                    }
                });
            });
        });

        let filledCount = 0;
        this.ROSTER_TIMES.forEach(time => {
            this.OUTPUT_ORDER.forEach(locName => {
                if (this.CRITICAL_DUTIES[locName] && !this.CRITICAL_DUTIES[locName].includes(time)) return;
                const isWeekend = ['Saturday', 'Sunday'].includes(document.getElementById('rosterDay').value);
                if (locName === "Report Room" && isWeekend) return;
                // RULE: When POOL <= 6, Lobby must remain empty
                if (locName === "Lobby" && presentStaff.length <= 6) { return; }

                
                const locConfig = this.LOCATIONS.find(l => l.name === locName);
                if (!roster[locName][time]) roster[locName][time] = new Array(locConfig.needed).fill('');

                for (let i = 0; i < locConfig.needed; i++) {
                    if (roster[locName][time][i] === '') {
                         const staffPool = presentStaff.map(s => s.staffId).sort(() => Math.random() - 0.5);

// Soft consecutive-location rule:
// Prefer candidates who have NOT already been in the same location for too many consecutive hours.
// If we cannot fill the slot otherwise, we will fall back to allowing it (last resort).
const preferred = [];
const fallback = [];

for (const sId of staffPool) {
    if (!this.canAssign(sId, time, locName, assignmentsByStaff, staffMap, verticalPatrolTracker, roster)) continue;
    if (this.wouldHitSoftConsecutiveLimit(sId, time, locName, roster)) fallback.push(sId);
    else preferred.push(sId);
}

const pickList = preferred.length ? preferred : fallback;

for (const sId of pickList) {
    roster[locName][time][i] = sId;
    assignmentsByStaff[sId].push(time);
    if (locName === 'Vertical Patrol' || locName === 'Tango Papa') verticalPatrolTracker.add(sId);
    filledCount++;
    break;
}
                    }
                }
            });
        });

        this.generatedRoster = roster;
        this.enforceHHMDOnly(roster, { source: 'generation' });
        this.enforceGuardHouseMax2(roster, { source: 'generation' });
        this.displayRoster(roster);
        this.enforceHHMDOnly(roster, { source: 'preSave', silent: true });
        this.enforceGuardHouseMax2(roster, { source: 'preSave', silent: true });
        window.firebaseOperations.saveRoster(this.currentDateStr, roster);
        this.showToast(`Filled ${filledCount} gaps`, "success");
    },
    // --- Seeded RNG support (for Shuffle modes) ---
    withSeededRandom: function(fn) {
        const __origRandom = Math.random;
        if (this._forcedSeed != null) {
            let __seed = (typeof this._forcedSeed === 'number' ? this._forcedSeed : Date.now()) >>> 0;
            Math.random = function() {
                __seed = (1664525 * __seed + 1013904223) >>> 0;
                return (__seed / 4294967296);
            };
        }
        try {
            return fn();
        } finally {
            Math.random = __origRandom;
        }
    },
    runRosterGeneration(isShuffle = false) {
        if (this.generatedRoster && !isShuffle) { if(!confirm("Overwrite existing roster for this date?")) return; }

        const presentStaff = this.staffDataCache.filter(s => s.attendance === 'Yes');
        if (presentStaff.length === 0) return this.showToast("No active staff!", 'error');
        const locks = window.firebaseOperations.getLocks(); const lockedValues = this.preserveLockedValues();
        const roster = Object.fromEntries(this.LOCATIONS.map(loc => [loc.name, Object.fromEntries(this.ROSTER_TIMES.map(t => [t, new Array(loc.needed).fill('')]))]));
        const assignmentsByStaff = Object.fromEntries(presentStaff.map(s => [s.staffId, []]));
        const staffMap = Object.fromEntries(presentStaff.map(s => [s.staffId, s]));
        const shortfalls = [];
        const isWeekend = ['Saturday', 'Sunday'].includes(document.getElementById('rosterDay').value);
        const verticalPatrolTracker = new Set();
        
        const specificAssignments = {}; 
        presentStaff.forEach(staff => {
            if (staff.startLoc) {
                if (!specificAssignments["20:00"]) specificAssignments["20:00"] = {}; if (!specificAssignments["20:00"][staff.startLoc]) specificAssignments["20:00"][staff.startLoc] = []; specificAssignments["20:00"][staff.startLoc].push(staff.staffId);
            }
            if (staff.vpSlot && this.VP_CYCLES[staff.vpSlot]) {
                const time = this.VP_CYCLES[staff.vpSlot].time; if (!specificAssignments[time]) specificAssignments[time] = {}; if (!specificAssignments[time]["Vertical Patrol"]) specificAssignments[time]["Vertical Patrol"] = []; specificAssignments[time]["Vertical Patrol"].push(staff.staffId);
            }
        });

        const attemptAssignment = (time, locName, positionIndex, forceStaffId = null) => {
            const lockKey = `${locName}-${time}`; let lockedId = lockedValues[lockKey] || (locks[lockKey] ? this.getStaffIdByLock(lockKey) : null);
            if (lockedId) { roster[locName][time][positionIndex] = lockedId; if (assignmentsByStaff[lockedId]) { assignmentsByStaff[lockedId].push(time); if (locName === 'Vertical Patrol' || locName === 'Tango Papa') verticalPatrolTracker.add(lockedId); } return true; }
            if (roster[locName][time][positionIndex] !== '') return true;

            if (forceStaffId) {
                const staff = staffMap[forceStaffId]; const isOverlapping = assignmentsByStaff[forceStaffId].includes(time); const isBreak = this.isOnBreak(staff, time); const isHHMD = (locName === 'HHMD' && staff.hhmd !== 'Yes');
                // HARD RULE: prevent Guard House <-> KIOSK switches across consecutive hours
                let isGuardKioskSwitch = false;
                const prevIdx = this.ROSTER_TIMES.indexOf(time) - 1;
                if (prevIdx >= 0) {
                    const prevTime = this.ROSTER_TIMES[prevIdx];
                    const prevLoc = this.findStaffLocation(roster, prevTime, forceStaffId);
                    isGuardKioskSwitch = ((prevLoc === 'Guard House' && locName === 'KIOSK') || (prevLoc === 'KIOSK' && locName === 'Guard House'));
                }
                if (!isOverlapping && !isBreak && !isHHMD && !isGuardKioskSwitch) { roster[locName][time][positionIndex] = forceStaffId; assignmentsByStaff[forceStaffId].push(time); if (locName === 'Vertical Patrol' || locName === 'Tango Papa') verticalPatrolTracker.add(forceStaffId); return true; } return false;
            }
            return false;
        };


// =========================
// Blueprint Template Rotation (Hard Enforcement for REQUIRED slots only)
// Blueprint acts as "place order" template: we preserve the pattern, but remap template IDs to a new set of staff IDs.
// IMPORTANT: Locations/times left blank in blueprint remain blank (e.g., Tango Papa only at 07:00).
// =========================
const bp = (this.blueprintEnabled && this.blueprintData && this.blueprintData.roster) ? this.blueprintData : null;

// Which slots are allowed/required by blueprint (blank cells should stay blank).
const bpAllowed = {};   // bpAllowed[loc][time] = boolean (true means generator may fill; false means must stay blank)
const bpPrefill = {};   // bpPrefill[loc][time] = array of ids (already remapped)
const bpRequired = {};  // bpRequired[loc][time] = boolean (true means must not be left blank)

if (bp) {
    // Seeded RNG so Shuffle/Generate produce stable-but-different remaps
    const seedBase = (this._forcedSeed != null ? this._forcedSeed : Date.now());
    const mulberry32 = (a) => () => {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
    const rng = mulberry32(Number(seedBase) >>> 0);
    const shuffle = (arr) => {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(rng() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
    };

    // 1) Collect unique template IDs from blueprint (non-empty)
    const templateIds = [];
    const seen = new Set();
    Object.keys(bp.roster || {}).forEach(locName => {
        Object.keys((bp.roster[locName] || {})).forEach(time => {
            const arr = bp.roster[locName][time] || [];
            arr.forEach(v => {
                const s = (v || "").toString().trim();
                if (s && !seen.has(s)) { seen.add(s); templateIds.push(s); }
            });
        });
    });

    // 2) Choose new staff IDs to map onto the template IDs.
    // Prefer "presentStaff" pool (attendance Yes). If pool smaller than template, we fall back to allowing reuse.
    const poolIds = presentStaff.map(s => s.staffId);
    const picked = shuffle(poolIds);
    const mapping = {};
    templateIds.forEach((tid, idx) => {
        mapping[tid] = picked[idx % picked.length]; // reuse only if necessary
    });

    // 3) Build allowed/required maps and prefill values (respect locked values)
    const bpTimes = Array.isArray(bp.times) && bp.times.length ? bp.times : this.ROSTER_TIMES;

    this.LOCATIONS.forEach(loc => {
        const locName = loc.name;
        bpAllowed[locName] = {};
        bpPrefill[locName] = {};
        bpRequired[locName] = {};

        bpTimes.forEach(time => {
            // Default: allowed = true (normal generation)
            bpAllowed[locName][time] = true;
            bpRequired[locName][time] = false;

            const tplArr = (bp.roster && bp.roster[locName] && bp.roster[locName][time]) ? bp.roster[locName][time] : null;

            if (tplArr) {
                // If blueprint explicitly provides an array for this loc/time:
                // - If ALL slots are blank => must remain blank (not allowed to fill)
                // - If ANY slot has a value => those slots are required/prefilled
                const normalized = new Array(loc.needed).fill('');
                for (let i = 0; i < Math.min(loc.needed, tplArr.length); i++) {
                    normalized[i] = (tplArr[i] || "").toString().trim();
                }
                const anyFilled = normalized.some(v => !!v);
                const allBlank = normalized.every(v => !v);

                if (allBlank) {
                    bpAllowed[locName][time] = false;   // keep empty
                    bpRequired[locName][time] = false;  // not required
                    bpPrefill[locName][time] = new Array(loc.needed).fill('');
                } else {
                    bpAllowed[locName][time] = true;
                    bpRequired[locName][time] = true;   // blueprint says pattern expects a duty here
                    bpPrefill[locName][time] = normalized.map((v, idx) => {
        if (!v) return '';
        const mapped = mapping[v];
        if (mapped) return mapped;

        // Hard rule: NEVER keep raw PatternKey as an assignment.
        // If mapping is missing (e.g., pool smaller / empty), fallback to an ACTIVE ID from today's pool.
        if (!poolIds || poolIds.length === 0) return '';
        const seed = String(locName) + '|' + String(time) + '|' + String(v) + '|' + String(idx);
        let h = 0;
        for (let i = 0; i < seed.length; i++) { h = ((h << 5) - h) + seed.charCodeAt(i); h |= 0; }
        return poolIds[Math.abs(h) % poolIds.length];
      });
                }
            } else {
                // If blueprint has no entry for this loc/time, leave as normal generation.
                bpPrefill[locName][time] = null;
            }
        });
    });

    // 4) Apply prefill into the roster now (respect locks)
    this.LOCATIONS.forEach(loc => {
        const locName = loc.name;
        this.ROSTER_TIMES.forEach(time => {
            const pre = bpPrefill?.[locName]?.[time];
            if (!pre) return;
            for (let i = 0; i < loc.needed; i++) {
                const key = `${locName}_${time}_${i}`;
                if (lockedValues[key]) {
                    roster[locName][time][i] = lockedValues[key];
                    continue;
                }
                if (pre[i]) {
                    roster[locName][time][i] = pre[i];
                    // record assignment
                    if (assignmentsByStaff[pre[i]]) assignmentsByStaff[pre[i]].push(time);
                    if (locName === "Vertical Patrol") verticalPatrolTracker.add(pre[i]);
                }
            }
        });
    });
}
        this.ROSTER_TIMES.forEach(time => {
            this.OUTPUT_ORDER.forEach(locName => {
                if (this.CRITICAL_DUTIES[locName] && !this.CRITICAL_DUTIES[locName].includes(time)) return;
                if (locName === "Report Room" && isWeekend) return;
                // RULE: When POOL <= 6, Lobby must remain empty
                if (locName === "Lobby" && presentStaff.length <= 6) { return; }


// Blueprint "place order" enforcement:
// - If blueprint explicitly marks this loc/time as not allowed, keep it empty and skip.
if (bp && bpAllowed[locName] && bpAllowed[locName][time] === false) {
    return; // keep blank as per blueprint (e.g., Tango Papa except 07:00)
}
                const needed = this.LOCATIONS.find(l => l.name === locName).needed;
                
                for (let i = 0; i < needed; i++) {

// If blueprint or lock already set this slot, do not overwrite.
if (roster[locName] && roster[locName][time] && roster[locName][time][i]) {
    continue;
}

                    let preAssignedId = null;
                    if (specificAssignments[time] && specificAssignments[time][locName] && specificAssignments[time][locName].length > 0) { preAssignedId = specificAssignments[time][locName].shift(); }
                    
                    // --- VP BUFFER LOGIC: Check previous VP and assign to Pass Counter Slot 1 ---
                    if (!preAssignedId && locName === "Pass Counter" && i === 1) { // i=1 is the Buffer Slot
                        const prevTimeIndex = this.ROSTER_TIMES.indexOf(time) - 1;
                        if (prevTimeIndex >= 0) {
                            const prevTime = this.ROSTER_TIMES[prevTimeIndex];
                            const vpStaffId = roster['Vertical Patrol']?.[prevTime]?.[0];
                            if (vpStaffId) preAssignedId = vpStaffId;
                        }
                    }
                    attemptAssignment(time, locName, i, preAssignedId);
                }
            });
        });

        // Smart Random Fill with Fatigue Check
        const fillRandomly = (time, locName, positionIndex) => {
            if (roster[locName][time][positionIndex] !== '') return true;
            let candidateId = null; let fallbackCandidateId = null;
            const staffPool = presentStaff.map(s => s.staffId).sort(() => Math.random() - 0.5);
            
            for (const sId of staffPool) { 
                let isReservedElsewhere = false;
                if (specificAssignments[time]) { for (const assignedLoc in specificAssignments[time]) { if (assignedLoc !== locName && specificAssignments[time][assignedLoc].includes(sId)) { isReservedElsewhere = true; break; } } }
                if (isReservedElsewhere) continue;

                if (this.canAssign(sId, time, locName, assignmentsByStaff, staffMap, verticalPatrolTracker, roster)) { 
                    // SOFT CONSTRAINTS (fundamental rotation)
// 1) Standing fatigue: avoid standing locations back-to-back (soft)
// 2) Rotation rule: prefer staff to move every hour (no same location consecutively).
//    Allow 2 consecutive hours only as LAST RESORT (when no other staff can fill).
const isStandingNow = this.STANDING_LOCATIONS.includes(locName);

// Count consecutive previous hours the staff has already been in *this same location*
const timeIdxNow = this.ROSTER_TIMES.indexOf(time);
let consecSameLoc = 0;
for (let tIdx = timeIdxNow - 1; tIdx >= 0; tIdx--) {
    const tPrev = this.ROSTER_TIMES[tIdx];
    const prevLocAny = this.findStaffLocation(roster, tPrev, sId);
    if (prevLocAny === locName) consecSameLoc++;
    else break;
}
// Hard cap: never allow 3+ consecutive hours at the same location
if (consecSameLoc >= 2) continue;

let isFatigued = false;
if (isStandingNow) {
    const prevTimeIndex = timeIdxNow - 1;
    if (prevTimeIndex >= 0) {
        const prevTime = this.ROSTER_TIMES[prevTimeIndex];
        const prevLoc = this.findStaffLocation(roster, prevTime, sId);
        if (prevLoc && this.STANDING_LOCATIONS.includes(prevLoc)) isFatigued = true;
    }
}

// PRIMARY: best candidate = not fatigued AND not consecutive in same location
// FALLBACK (last resort): allow 2nd consecutive hour in same location OR standing fatigue
const isPrimaryOK = (!isFatigued && consecSameLoc === 0);
if (isPrimaryOK) { candidateId = sId; break; }
else { if (!fallbackCandidateId) fallbackCandidateId = sId; }
                } 
            }
            
            const finalId = candidateId || fallbackCandidateId;
            if (finalId) { roster[locName][time][positionIndex] = finalId; assignmentsByStaff[finalId].push(time); if (locName === 'Vertical Patrol' || locName === 'Tango Papa') verticalPatrolTracker.add(finalId); return true; }
            return false;
        };

        this.ROSTER_TIMES.forEach(time => {
            this.OUTPUT_ORDER.forEach(locName => {
                if (this.CRITICAL_DUTIES[locName] && !this.CRITICAL_DUTIES[locName].includes(time)) return;
                if (locName === "Report Room" && isWeekend) return;
                // RULE: When POOL <= 6, Lobby must remain empty
                if (locName === "Lobby" && presentStaff.length <= 6) { return; }

                const needed = this.LOCATIONS.find(l => l.name === locName).needed;
                for (let i = 0; i < needed; i++) { if (!fillRandomly(time, locName, i)) { if(!shortfalls.includes(`Shortfall: ${locName} @ ${time}`)) shortfalls.push(`Shortfall: ${locName} @ ${time}`); } }
            });
        });


                // --- HARD COVERAGE: keep core posts filled (no blanks) ---
        // Priority: HHMD + Guard House + KIOSK must be filled every hour.
        // If staff is short, we allow:
        // - Pass Counter may run single-person (leave 2nd slot blank)
        // - Lobby is NOT auto-filled by HHMD (must be separate staff)
        const ESSENTIAL_LOCS = ["HHMD", "Guard House", "KIOSK"];
        const donorPriority = ["Lobby", "Pass Counter", "Report Room"];

        this.ROSTER_TIMES.forEach(time => {
            // 1) Ensure essential locations are filled by moving staff from non-essential posts (same hour).
            for (const essential of ESSENTIAL_LOCS) {
                const slotArr = roster[essential]?.[time];
                if (!slotArr) continue;
                if (slotArr[0] !== '') continue; // already filled

                let moved = false;

                const canMoveIntoEssential = (sId) => {
                    if (!sId) return false;
                    const staff = staffMap[sId];
                    if (!staff) return false;
                    // Do not move someone who is on break during this hour (strict mode uses overlap logic)
                    if (this.isOnBreak(staff, time)) return false;
                    // HHMD must only be filled by HHMD-qualified staff
                    if (essential === "HHMD" && staff.hhmd !== "Yes") return false;
                    return true;
                };

                const tryMoveFrom = (fromLoc) => {
                    const arr = roster[fromLoc]?.[time];
                    if (!arr) return false;
                    // Don't steal from essential locations
                    if (ESSENTIAL_LOCS.includes(fromLoc)) return false;
                    // Don't steal from a location that is critical at this time
                    if (this.CRITICAL_DUTIES[fromLoc] && this.CRITICAL_DUTIES[fromLoc].includes(time)) return false;

                    for (let i = 0; i < arr.length; i++) {
                        const sId = arr[i];
                        if (!sId) continue;
                        if (!canMoveIntoEssential(sId)) continue;

                        roster[essential][time][0] = sId;
                        arr[i] = '';
                        moved = true;
                        return true;
                    }
                    return false;
                };

                // First, try preferred donors in order
                for (const fromLoc of donorPriority) {
                    if (moved) break;
                    tryMoveFrom(fromLoc);
                }

                // Last resort: move from any other non-essential, non-critical location
                if (!moved) {
                    for (const fromLoc of this.OUTPUT_ORDER) {
                        if (moved) break;
                        tryMoveFrom(fromLoc);
                    }
                }

                // If still not moved, record a shortfall (do NOT place a non-HHMD into HHMD).
                if (!moved) {
                    if (!shortfalls.includes(`Shortfall: ${essential} @ ${time}`)) shortfalls.push(`Shortfall: ${essential} @ ${time}`);
                }
            }

            // 2) Critical-mode fallbacks to remove blanks (duplicates allowed by design)
            // Pass Counter managed by one person -> duplicate into missing slot
            const pc = roster["Pass Counter"]?.[time];
            if (pc && pc.length >= 2) {
                                if (!pc[0] && pc[1]) { pc[0] = pc[1]; pc[1] = ""; }
            }
});


// Final Blueprint hard-enforcement (REQUIRED slots only): do not allow blanks where blueprint expects duty.
if (bp) {
    this.LOCATIONS.forEach(loc => {
        const locName = loc.name;
        this.ROSTER_TIMES.forEach(time => {
            if (bpRequired[locName] && bpRequired[locName][time]) {
                for (let i = 0; i < loc.needed; i++) {
                    const key = `${locName}_${time}_${i}`;
                    if (lockedValues[key]) continue;
                    if (!roster[locName][time][i]) {
                        // Fallback: pick any present staff (even if reused) to avoid blank required slot
                        const fallback = presentStaff[(Math.floor((Math.random()) * presentStaff.length))].staffId;
                        roster[locName][time][i] = fallback;
                    }
                }
            }
        });
    });
}
this.generatedRoster = roster; this.displayRoster(roster); document.getElementById('rosterActionsContainer').classList.remove('hidden');
        this.enforceHHMDOnly(roster, { source: 'preSave', silent: true });
        window.firebaseOperations.saveRoster(this.currentDateStr, roster); this.triggerSaveIndicator();
        if (shortfalls.length > 0) this.showToast(`${shortfalls.length} Shortfalls`, 'warning'); else this.showToast("Roster Generated", "success");
    },
    

    // Count how many times a staff ID appears at a given location across the whole shift.
    // Used for Guard House cap enforcement.
    countAssignmentsInLocation(sId, locName, rosterRef) {
        if (!rosterRef || !rosterRef[locName]) return 0;
        let count = 0;
        for (const t of this.ROSTER_TIMES) {
            const cell = rosterRef[locName]?.[t];
            if (Array.isArray(cell)) {
                if (cell.includes(sId)) count += 1;
            } else if (cell === sId) {
                count += 1;
            }
        }
        return count;
    },

    // HARD RULE: Within the 12-hour shift, a staff can be assigned to Guard House at most twice.
    // If violated in existing data (manual edits / older rosters), we clear the extra assignments.
    // --- Manual Overrides (per-cell) ---
    isCellOverridden(rosterRef, locName, time, idx = 0) {
        try {
            return !!(rosterRef && rosterRef._manualOverrides && rosterRef._manualOverrides[locName] && rosterRef._manualOverrides[locName][time] && rosterRef._manualOverrides[locName][time][idx]);
        } catch (e) { return false; }
    },
    setCellOverride(rosterRef, locName, time, idx = 0, enabled = true) {
        try {
            if (!rosterRef) return;
            if (!rosterRef._manualOverrides) rosterRef._manualOverrides = {};
            if (!rosterRef._manualOverrides[locName]) rosterRef._manualOverrides[locName] = {};
            if (!rosterRef._manualOverrides[locName][time]) rosterRef._manualOverrides[locName][time] = {};
            if (enabled) {
                rosterRef._manualOverrides[locName][time][idx] = true;
            } else {
                if (rosterRef._manualOverrides[locName] && rosterRef._manualOverrides[locName][time]) {
                    delete rosterRef._manualOverrides[locName][time][idx];
                    if (Object.keys(rosterRef._manualOverrides[locName][time]).length === 0) delete rosterRef._manualOverrides[locName][time];
                    if (Object.keys(rosterRef._manualOverrides[locName]).length === 0) delete rosterRef._manualOverrides[locName];
                }
            }
        } catch (e) {}
    },

    enforceGuardHouseMax2(rosterRef, opts = {}) {
        try {
            if (!rosterRef || !rosterRef['Guard House']) return { fixed: 0, removed: [] };

            const poolCount = (opts.poolCount != null ? opts.poolCount : (typeof this.currentPoolCount === 'number' ? this.currentPoolCount : (this.staffDataCache ? this.staffDataCache.filter(s => s.attendance === 'Yes').length : 0)));
            const CAP = (poolCount <= 6 ? 3 : 2);
            const counts = {};
            const removed = [];
            let fixed = 0;

            // Walk time in order.
            // Rules:
            // 1) Guard House not back-to-back for same staff.
            // 2) CAP per staff across the shift (CAP=3 when pool<=6, else CAP=2).
            let prevStaff = null;
            for (const t of this.ROSTER_TIMES) {
                const arr = rosterRef['Guard House']?.[t];
                if (!Array.isArray(arr) || !arr.length) continue;

                const sId = arr[0];
                if (!sId) { prevStaff = null; continue; }

                const _isOverride = this.isCellOverridden(rosterRef, 'Guard House', t, 0);
                if (_isOverride) {
                    // Keep user-chosen value even if it breaks cap/back-to-back. We still count it so later slots can be adjusted.
                    counts[sId] = (counts[sId] || 0) + 1;
                    prevStaff = sId;
                    continue;
                }
                // Rule 1: no back-to-back Guard House for the same staff
                if (prevStaff && prevStaff === sId) {
                    rosterRef['Guard House'][t][0] = '';
                    fixed += 1;
                    removed.push({ time: t, staffId: sId, reason: 'back-to-back' });
                    // do not count this cleared slot; keep prevStaff as-is
                    continue;
                }

                counts[sId] = (counts[sId] || 0) + 1;
                if (counts[sId] > CAP) {
                    rosterRef['Guard House'][t][0] = '';
                    fixed += 1;
                    removed.push({ time: t, staffId: sId, reason: 'cap' });
                    // cleared slot breaks chain
                    prevStaff = null;
                    continue;
                }

                prevStaff = sId;
            }

            // Auto-replace cleared Guard House slots (best-effort) while obeying all existing rules.
            // This runs AFTER clearing violations (cap / back-to-back), so we never re-introduce them.
            if (opts.autoReplace !== false) {
                const presentStaff = this.staffDataCache.filter(s => s.attendance === 'Yes');
                const staffMap = Object.fromEntries(presentStaff.map(s => [s.staffId, s]));
                const assignmentsByStaff = Object.fromEntries(presentStaff.map(s => [s.staffId, []]));

                // Build current assignmentsByStaff from rosterRef (so canAssign() can enforce 1-location-per-hour).
                for (const loc of Object.keys(rosterRef)) {
                    const byTime = rosterRef[loc];
                    if (!byTime) continue;
                    for (const tt of this.ROSTER_TIMES) {
                        const arr2 = byTime[tt];
                        if (!Array.isArray(arr2)) continue;
                        for (const id2 of arr2) {
                            if (!id2) continue;
                            if (assignmentsByStaff[id2]) assignmentsByStaff[id2].push(tt);
                        }
                    }
                }

                const verticalPatrolTracker = {}; // not needed for Guard House enforcement, but required by canAssign()

                // Recompute Guard House counts after the clearing step, then fill blanks in order.
                const guardCounts = {};
                for (const tt of this.ROSTER_TIMES) {
                    const cur = rosterRef['Guard House']?.[tt]?.[0];
                    if (cur) guardCounts[cur] = (guardCounts[cur] || 0) + 1;
                }

                for (let i = 0; i < this.ROSTER_TIMES.length; i++) {
                    const tt = this.ROSTER_TIMES[i];
                    const slotArr = rosterRef['Guard House']?.[tt];
                    if (!Array.isArray(slotArr) || slotArr.length === 0) continue;

                    if (slotArr[0]) continue; // already filled

                    // Back-to-back guard check vs previous and next hour
                    const prevT = (i > 0 ? this.ROSTER_TIMES[i - 1] : null);
                    const nextT = (i < this.ROSTER_TIMES.length - 1 ? this.ROSTER_TIMES[i + 1] : null);
                    const prevId = (prevT ? rosterRef['Guard House']?.[prevT]?.[0] : null);
                    const nextId = (nextT ? rosterRef['Guard House']?.[nextT]?.[0] : null);

                    // Try candidates in a stable order (you can randomize if desired)
                    for (const cand of presentStaff) {
                        const cId = cand.staffId;
                        if (!cId) continue;

                        // Never allow back-to-back at Guard House
                        if ((prevId && prevId === cId) || (nextId && nextId === cId)) continue;

                        // Respect cap (CAP already computed based on pool size)
                        if ((guardCounts[cId] || 0) >= CAP) continue;

                        // Respect ALL existing assignment rules
                        if (!this.canAssign(cId, tt, 'Guard House', assignmentsByStaff, staffMap, verticalPatrolTracker, rosterRef)) continue;

                        // Assign
                        rosterRef['Guard House'][tt][0] = cId;
                        assignmentsByStaff[cId].push(tt);
                        guardCounts[cId] = (guardCounts[cId] || 0) + 1;
                        break;
                    }
                }
            }


            if (!opts.silent && fixed > 0) {
                this.showToast(`Guard House cap applied: cleared ${fixed} extra slot(s)`, 'warning');
            }
            return { fixed, removed };
        } catch (e) {
            console.warn('[enforceGuardHouseMax2] failed', e);
            return { fixed: 0, removed: [] };
        }
    },

    canAssign(sId, time, locName, assignmentsByStaff, staffMap, verticalPatrolTracker, rosterRef) {
        const staffMember = staffMap[sId];
        const isAlreadyAssigned = assignmentsByStaff[sId].includes(time);
        const isonBreak = this.isOnBreak(staffMember, time);
        const isHhmdMismatch = (locName === 'HHMD' && staffMember.hhmd !== 'Yes');
        // HARD RULE: Pass Counter cannot have duplicate ID in the same hour
        const isPassCounterDup = (locName === 'Pass Counter' && rosterRef && rosterRef['Pass Counter'] && Array.isArray(rosterRef['Pass Counter'][time]) && rosterRef['Pass Counter'][time].includes(sId));

        const poolCount = (typeof this.currentPoolCount === 'number' ? this.currentPoolCount : (this.staffDataCache ? this.staffDataCache.filter(s => s.attendance === 'Yes').length : 0));
        const GUARD_HOUSE_CAP = (poolCount <= 6 ? 3 : 2);
        const isGuardHouseCapExceeded = (locName === 'Guard House' && this.countAssignmentsInLocation(sId, 'Guard House', rosterRef) >= GUARD_HOUSE_CAP);

        // HARD RULE: prevent Guard House <-> KIOSK switches across consecutive hours
        let isGuardKioskSwitch = false;
        const prevIdx = this.ROSTER_TIMES.indexOf(time) - 1;
        if (prevIdx >= 0) {
            const prevTime = this.ROSTER_TIMES[prevIdx];
            const prevLoc = this.findStaffLocation(rosterRef, prevTime, sId);
            // HARD RULE: Guard House cannot be assigned back-to-back (even in shortfall)
            const isGuardHouseBackToBack = (locName === 'Guard House' && prevLoc === 'Guard House');
            if (isGuardHouseBackToBack) return false;
            isGuardKioskSwitch = ((prevLoc === 'Guard House' && locName === 'KIOSK') || (prevLoc === 'KIOSK' && locName === 'Guard House'));
        }

        const isPatrolDuplicate = ((locName === 'Vertical Patrol' || locName === 'Tango Papa') && verticalPatrolTracker.has(sId));
        if (isAlreadyAssigned || isonBreak || isHhmdMismatch || isPassCounterDup || isGuardHouseCapExceeded || isGuardKioskSwitch || isPatrolDuplicate) return false;
        return true;
    },

    // SOFT RULE: avoid placing the same staff at the same location for too many consecutive hours.
    // This is a "last resort" constraint: it is NOT enforced inside canAssign(); instead it is used
    // to rank candidates. If the roster cannot be filled otherwise, the generator may still use it.
    wouldHitSoftConsecutiveLimit(sId, time, locName, rosterRef) {
        const DEFAULT_MAX = 2; // prefer rotation after 2 consecutive hours (soft)
        const MAX_BY_LOC = {
            'Guard House': 2,
            'KIOSK': 2,
            'HHMD': 2,
            'Lobby': 2,
            'Report Room': 2,
            'Pass Counter': 2
        };
        const maxConsec = (MAX_BY_LOC[locName] ?? DEFAULT_MAX);
        if (!maxConsec || maxConsec <= 0) return false;

        let streak = 0;
        let tIdx = this.ROSTER_TIMES.indexOf(time) - 1;
        while (tIdx >= 0) {
            const tPrev = this.ROSTER_TIMES[tIdx];
            const prevLoc = this.findStaffLocation(rosterRef, tPrev, sId);
            if (prevLoc === locName) { streak++; tIdx--; }
            else break;
        }
        return (streak >= maxConsec);
    }
,
    
    findStaffLocation(roster, time, staffId) {
        for (const loc of this.OUTPUT_ORDER) {
            const slot = roster[loc]?.[time];
            if (slot && slot.includes(staffId)) return loc;
        }
        return null;
    },

    preserveLockedValues() {
        const lockedValues = {}; const locks = window.firebaseOperations.getLocks();
        document.querySelectorAll(".roster-input").forEach(input => { const loc = input.dataset.loc; const time = input.dataset.time; const key = `${loc}-${time}`; if(locks[key] && input.value.trim()) lockedValues[key] = input.value.trim(); });
        return lockedValues;
    },
    getStaffIdByLock(key) { return null; },
        // STRICT BREAK CHECK: true if ANY part of the duty hour overlaps the staff break window.
    // Works with half-hour breaks (e.g. 03:30â€“04:30) and midnight wrap.
    isOnBreak(staff, timeSlot, slotMins = 60) {
        if (!staff || !staff.breakStart || !staff.breakEnd) return false;

        const toShiftMins = (t) => {
            if (!t || typeof t !== 'string' || !t.includes(':')) return NaN;
            let [h, m] = t.split(':').map(Number);
            if (Number.isNaN(h) || Number.isNaN(m)) return NaN;
            // Our shift runs 20:00 â†’ 08:00 next day, so treat 00:00â€“11:59 as "next day"
            if (h < 12) h += 24;
            return (h * 60) + m;
        };

        let bStart = toShiftMins(staff.breakStart);
        let bEnd   = toShiftMins(staff.breakEnd);
        let sStart = toShiftMins(timeSlot);
        if (!Number.isFinite(bStart) || !Number.isFinite(bEnd) || !Number.isFinite(sStart)) return false;

        // If someone mistakenly sets an end earlier than start, assume it wraps midnight
        if (bEnd <= bStart) bEnd += 24 * 60;

        const sEnd = sStart + (parseInt(slotMins, 10) || 60);

        // Overlap test: [sStart,sEnd) intersects [bStart,bEnd)
        return (sStart < bEnd) && (sEnd > bStart);
    },

    enableRosterDragScroll() {
        const el = document.getElementById('rosterContainer'); if (!el) return; if (el.__dragScrollBound) return; el.__dragScrollBound = true;
        let isDown = false; let startX; let startScrollLeft;
        el.addEventListener('mousedown', (e) => { if(['INPUT','SELECT'].includes(e.target.tagName)) return; isDown = true; startX = e.pageX - el.offsetLeft; startScrollLeft = el.scrollLeft; });
        el.addEventListener('mouseleave', () => { isDown = false; });
        el.addEventListener('mouseup', () => { isDown = false; });
        el.addEventListener('mousemove', (e) => { if (!isDown) return; e.preventDefault(); const x = e.pageX - el.offsetLeft; const walk = (x - startX) * 2; el.scrollLeft = startScrollLeft - walk; });
    },

    isSlotApplicable(locName, time) {
        const isWeekend = ['Saturday', 'Sunday'].includes(document.getElementById('rosterDay').value);
        if (this.CRITICAL_DUTIES[locName] && !this.CRITICAL_DUTIES[locName].includes(time)) return false;
        if (locName === "Report Room" && isWeekend) return false;
        return true;
    },


    // Build a compact list of ACTIVE staff who are actually assigned anywhere in the roster (for the selected day)
    getAssignedActiveStaff(roster) {
        const assignedIds = new Set();
        this.OUTPUT_ORDER.forEach(loc => {
            this.ROSTER_TIMES.forEach(time => {
                const arr = roster?.[loc]?.[time] || [];
                arr.forEach(val => {
                    if (!val) return;
                    String(val).split(/[\s,\/|]+/).filter(Boolean).forEach(id => assignedIds.add(id));
                });
            });
        });

        const rows = [];
        assignedIds.forEach(id => {
            const staff = this.staffDataCache.find(s => s.staffId === id);
            if (!staff) return;
            if (staff.attendance !== 'Yes') return; // active only
            rows.push({
                staffId: staff.staffId || id,
                name: staff.name || '',
                breakStart: staff.breakStart || '',
                breakEnd: staff.breakEnd || '',
                vpSlot: staff.vpSlot || ''
            });
        });
        return rows;
    },

    renderBreakTable(roster) {
    const rows = this.getAssignedActiveStaff(roster);

    // Helpers for time math (night shift ordering)
    const timeToMinutes = (t) => {
        if (!t || typeof t !== 'string' || !t.includes(':')) return NaN;
        const [h, m] = t.split(':').map(n => parseInt(n, 10));
        if (Number.isNaN(h) || Number.isNaN(m)) return NaN;
        return (h * 60) + m;
    };
    const toShiftMinute = (t) => {
        const base = timeToMinutes(t);
        if (Number.isNaN(base)) return NaN;
        // Treat early morning as "next day" so 00:xx comes after 23:xx
        return (base < 12 * 60) ? (base + 24 * 60) : base;
    };

    const normalizeEnd = (startHHMM, endHHMM) => {
        const s = (startHHMM || "").trim();
        const e = (endHHMM || "").trim();
        if (!s) return e;
        // If end is missing OR still the default 00:00 while start is not 00:00,
        // compute it from the current global break duration so timeline/overlap stay correct.
        if (!e || (e === "00:00" && s !== "00:00")) return this.computeBreakEndFromStart(s);
        // If malformed, also compute.
        if (!e.includes(":")) return this.computeBreakEndFromStart(s);
        return e;
    };

    // Build interval metadata + detect overlaps
    const enriched = rows.map(r => {
        const startHHMM = (r.breakStart || '').trim();
        const endHHMM = normalizeEnd(startHHMM, r.breakEnd);
        const startMin = toShiftMinute(startHHMM);
        let endMin = toShiftMinute(endHHMM);
        let valid = !(Number.isNaN(startMin) || Number.isNaN(endMin));
        if (valid && endMin <= startMin) endMin += 24 * 60; // cross-midnight -> next day

        // --- VP overlay (red bar) ---
        // Uses rosterSystem.VP_CYCLES mapping (label preferred for true start like 20:30 / 01:30 etc).
        const vpCfg = (r.vpSlot && this.VP_CYCLES) ? this.VP_CYCLES[r.vpSlot] : null;

        // VP time for the red marker: prefer the *label* (e.g., "20:30", "01:30") if present.
        // Accepts "2030" style too and normalizes to "20:30".
        const normalizeHHMM = (t) => {
            if (!t) return "";
            const s = String(t).trim();
            if (s.includes(":")) return s;
            // If numeric 4-digits like 2030 -> 20:30
            const m = s.match(/^(\d{2})(\d{2})$/);
            return m ? `${m[1]}:${m[2]}` : s;
        };
        const vpHHMM = vpCfg ? (normalizeHHMM(vpCfg.label) || normalizeHHMM(vpCfg.time)) : "";
        const vpStartMin = vpHHMM ? toShiftMinute(vpHHMM) : NaN;
        const vpDur = 60; // minutes (visual only)
        const vpEndMin = (Number.isFinite(vpStartMin)) ? (vpStartMin + vpDur) : NaN;
        const vpValid = Number.isFinite(vpStartMin) && Number.isFinite(vpEndMin);

        return {
            ...r,
            breakStart: startHHMM,
            breakEnd: endHHMM,
            _startMin: startMin,
            _endMin: endMin,
            _valid: valid,
            _overlap: false,
            _vpStartMin: vpStartMin,
            _vpEndMin: vpEndMin,
            _vpValid: vpValid
        };
    });

    // Overlap marking (only among valid intervals)
    const validIdx = enriched
        .map((r, i) => ({ r, i }))
        .filter(x => x.r._valid)
        .sort((a, b) => a.r._startMin - b.r._startMin || String(a.r.staffId).localeCompare(String(b.r.staffId)));

    for (let k = 0; k < validIdx.length; k++) {
        const cur = validIdx[k].r;
        // compare with any previous interval that still extends beyond cur.start
        for (let j = k - 1; j >= 0; j--) {
            const prev = validIdx[j].r;
            if (prev._endMin <= cur._startMin) break; // no more possible overlaps
            // overlap
            prev._overlap = true;
            cur._overlap = true;
        }
    }

    // Sort by break start time (shift order), then by ID
    enriched.sort((a, b) => {
        const aKey = a._valid ? a._startMin : Number.POSITIVE_INFINITY;
        const bKey = b._valid ? b._startMin : Number.POSITIVE_INFINITY;
        if (aKey !== bKey) return aKey - bKey;
        return String(a.staffId).localeCompare(String(b.staffId));
    });

    if (!enriched.length) {
        return `<div class="border border-slate-200 rounded bg-slate-50 p-3 text-xs text-slate-500">
                    <div class="font-bold text-slate-600 mb-1">Break Time (Assigned Staff)</div>
                    <div>No active assigned staff found for this roster.</div>
                </div>`;
    }

    const overlapCount = enriched.filter(r => r._overlap).length;
    const overlapBanner = overlapCount
        ? `<div class="mx-3 mt-3 mb-1 rounded border border-rose-200 bg-rose-50 px-2 py-1 text-[10px] text-rose-700 font-bold">âš  ${overlapCount} staff break(s) overlapping. Please adjust to avoid clashes.</div>`
        : `<div class="mx-3 mt-3 mb-1 rounded border border-emerald-200 bg-emerald-50 px-2 py-1 text-[10px] text-emerald-700 font-bold">âœ“ No overlapping breaks detected.</div>`;

    const rowHtml = enriched.map(r => {
        const overlapClass = r._overlap ? "bg-rose-50" : "";
        const leftAccent = r._overlap ? "border-l-4 border-rose-500" : "";
        const badge = r._overlap
            ? `<span class="ml-2 inline-flex items-center rounded px-1.5 py-0.5 text-[9px] font-bold bg-rose-100 text-rose-700">OVERLAP</span>`
            : "";
        return `
            <tr class="border-b border-slate-200 last:border-b-0 ${overlapClass} ${leftAccent}">
                <td class="px-2 py-1 font-mono font-bold text-slate-700 whitespace-nowrap">${r.staffId}</td>
                <td class="px-2 py-1 text-slate-700 whitespace-nowrap">${r.name}</td>
                <td class="px-2 py-1 font-mono font-bold text-slate-700 whitespace-nowrap">
                    ${(r.breakStart || '--:--')} - ${(r.breakEnd || '--:--')}
                    ${badge}
                </td>
            </tr>
        `;
    }).join('');

    // Timeline bar view (20:00 -> 08:00 next day)
    const shiftStart = 20 * 60;
    const shiftEnd = (24 + 8) * 60; // 08:00 next day
    const total = shiftEnd - shiftStart;

    const ticks = [
        "20:00","22:00","00:00","02:00","04:00","06:00","08:00"
    ].map(t => {
        const m = toShiftMinute(t);
        const left = ((m - shiftStart) / total) * 100;
        return `<div class="absolute top-0 bottom-0" style="left:${left}%;">
                    <div class="w-px h-full bg-slate-200"></div>
                    <div class="mt-1 -translate-x-1/2 text-[9px] font-mono text-slate-500 whitespace-nowrap">${t}</div>
                </div>`;
    }).join('');

    const bars = enriched
        .filter(r => r._valid)
        .map(r => {
            const left = ((r._startMin - shiftStart) / total) * 100;
            const width = ((r._endMin - r._startMin) / total) * 100;
            const segClass = r._overlap ? "bg-rose-500" : "bg-indigo-500";
            return `
                <div class="bt-row flex items-center gap-2 py-1">
                    <div class="w-28 shrink-0">
                        <div class="text-[10px] font-mono font-bold text-slate-700">${r.staffId}</div>
                        <div class="text-[9px] text-slate-500 truncate">${r.name}</div>
                    </div>
                    <div class="relative flex-1 h-4 bg-slate-200 rounded overflow-hidden">
                        <div class="bt-guide" style="left:${left}%"></div>
                        ${r._vpValid ? `<div class="bt-vp absolute top-0 h-1 rounded bg-red-500/90 shadow-sm" style="left:${((r._vpStartMin - shiftStart) / total) * 100}%; width:${Math.max(0.5, ((r._vpEndMin - r._vpStartMin) / total) * 100)}%;"></div>` : ``}
                        <div class="bt-seg absolute bottom-0 h-2 ${segClass} rounded" data-staff-id="${r.staffId}" data-break-start="${r.breakStart}" data-break-end="${r.breakEnd}" style="left:${left}%; width:${Math.max(0.5, width)}%;"></div>
                    </div>
                    <div class="w-20 shrink-0 text-right text-[10px] font-mono text-slate-500"><span class="bt-range">${r.breakStart}â€“${r.breakEnd}</span></div>
                </div>
            `;
        }).join('');

    const timeline = `
        <div id="breakTimelineRoot" class="mt-3 border border-slate-200 rounded bg-white overflow-hidden">
            <div class="px-3 py-2 bg-slate-50 border-b border-slate-200">
                <div class="text-xs font-extrabold text-slate-700 uppercase tracking-wide">Break Timeline</div>
                <div class="text-[10px] text-slate-500">20:00 â†’ 08:00 (next day) â€¢ Overlaps shown in red</div>
            </div>
            <div class="p-3">
                <div class="flex items-end gap-2 h-6">
                    <div class="w-28 shrink-0"></div>
                    <div class="relative flex-1 h-6">
                        ${ticks}
                    </div>
                    <div class="w-20 shrink-0"></div>
                </div>
                <div class="mt-2">
                    ${bars || `<div class="text-xs text-slate-500">No valid break times to show on the timeline.</div>`}
                </div>
            </div>
        </div>
    `;

    return `
        <div class="border border-slate-200 rounded bg-white overflow-hidden">
            <div class="flex items-center justify-between px-3 py-2 bg-slate-50 border-b border-slate-200">
                <div class="flex items-center gap-2">
                    <i data-lucide="coffee" class="w-4 h-4 text-indigo-600"></i>
                    <div class="text-xs font-extrabold text-slate-700 uppercase tracking-wide">Break Time (Assigned Staff)</div>
                </div>
                <div class="text-[10px] font-mono font-bold text-slate-500">${enriched.length} staff</div>
            </div>
            ${overlapBanner}
            <div class="overflow-x-auto">
                <table class="min-w-full text-[10px]">
                    <thead class="bg-slate-50">
                        <tr class="border-b border-slate-200">
                            <th class="px-2 py-1 text-left font-bold text-slate-500 uppercase tracking-wider">ID</th>
                            <th class="px-2 py-1 text-left font-bold text-slate-500 uppercase tracking-wider">Name</th>
                            <th class="px-2 py-1 text-left font-bold text-slate-500 uppercase tracking-wider">Break</th>
                        </tr>
                    </thead>
                    <tbody>${rowHtml}</tbody>
                </table>
            </div>
        </div>
        ${timeline}
    `;
},
displayRoster(roster) {
        const container = document.getElementById("rosterContainer");
        const tableHead = `<thead><tr><th class="p-2 bg-slate-50 border-b border-slate-200 text-left sticky left-0 z-10 text-[10px] text-slate-500 font-bold uppercase tracking-wider">Location</th>${this.ROSTER_TIMES.map(t => `<th class="p-1 text-center bg-slate-50 border-b border-slate-200 text-[10px] text-slate-500 font-bold border-l border-slate-100">${t}</th>`).join('')}</tr></thead>`;
        
        const tableBody = this.OUTPUT_ORDER.map(locName => {
            const locConfig = this.LOCATIONS.find(l => l.name === locName);
            let locationCell = `<td class="p-2 text-xs font-bold text-slate-700 bg-white border-r border-slate-200 sticky left-0 z-10 shadow-[2px_0_5px_-2px_rgba(0,0,0,0.05)] whitespace-nowrap align-middle">${locName}</td>`;

            const timeCells = this.ROSTER_TIMES.map(time => {
                let content = '', classes = [];
                const isApplicable = this.isSlotApplicable(locName, time);
                const specialNotes = { "20:00": "@ 20:30", "01:00": "@ 01:30", "06:00": "@ 06:30" };
                
                if (isApplicable) {
                    for (let i = 0; i < locConfig.needed; i++) {
                        const assignedStaffId = roster[locName]?.[time]?.[i] || '';
                        const isOverrideCell = this.isCellOverridden(roster, locName, time, i);
                        const overrideBadge = (locName === 'Guard House' && isOverrideCell) ? `<span class="override-badge">âš ï¸ override</span>` : '';
                        let isPredefined = false;
                        const staff = this.staffDataCache.find(s => s.staffId === assignedStaffId);
                        
                        if (staff) {
                            if (staff.startLoc === locName && time === "20:00") isPredefined = true;
                            if (staff.vpSlot && this.VP_CYCLES[staff.vpSlot] && this.VP_CYCLES[staff.vpSlot].time === time && locName === "Vertical Patrol") isPredefined = true;
                        }

                        let extraInfo = "";
                        if (locName === 'Vertical Patrol' && specialNotes[time]) extraInfo = `<div class="text-[8px] text-slate-400 font-mono mt-[-2px]">${specialNotes[time]}</div>`;

                        const cellClass = isPredefined ? "predefined-cell" : "";
                        const icon = isPredefined ? `<i data-lucide="pin" class="predefined-icon"></i>` : "";
                        
                        content += `<div class="relative w-full ${cellClass}" style="flex: 1; display: flex; flex-direction: column; justify-content: center;">${overrideBadge}
                            <select value="${assignedStaffId}" data-loc="${locName}" data-time="${time}" data-index="${i}" class="roster-input transition-colors font-medium text-slate-700 bg-transparent outline-none w-full" >${this.getActiveStaffOptionsHtml(assignedStaffId)}</select>
                            ${icon}
                            ${extraInfo}
                        </div>`;
                    }
                } else classes.push('not-applicable');
                return `<td class="${classes.join(' ')} border-r border-b border-slate-100 relative bg-white" data-location="${locName}" data-time="${time}"><div class="flex flex-col h-full gap-1 p-1" style="min-height: 50px;">${content}</div></td>`;
            }).join('');
            
            return `<tr>${locationCell}${timeCells}</tr>`;
        }).join('');

        const mainTableHtml = `<table class="styled-table w-full text-left">${tableHead}<tbody>${tableBody}</tbody></table>`;
        const breakTableHtml = this.renderBreakTable(roster);
        container.innerHTML = `<div class="flex flex-col gap-3">${mainTableHtml}${breakTableHtml}</div>`;
        this.initBreakTimelineDrag();
        container.querySelectorAll('.roster-input').forEach(input => input.addEventListener('change', (e) => this.handleCellChange(e)));
        this.applyPadlocksVisuals(); this.validateAllCells(); this.enableRosterDragScroll(); lucide.createIcons();
    },

    handleCellChange(event) { 
        const { loc, time, index } = event.target.dataset; 
        this.generatedRoster[loc][time][parseInt(index, 10)] = event.target.value; 
        
        if (loc === 'Guard House') {
            const v = (event.target.value || '').trim();
            this.setCellOverride(this.generatedRoster, 'Guard House', time, parseInt(index, 10), !!v);
        }
this.validateAllCells(); 
        this.enforceHHMDOnly(this.generatedRoster, { source: 'preSave', silent: true });
        this.enforceGuardHouseMax2(this.generatedRoster, { source: 'preSave', silent: true });
        window.firebaseOperations.saveRoster(this.currentDateStr, this.generatedRoster);
        this.triggerSaveIndicator();
    },
    
    triggerSaveIndicator() {
        const el = document.getElementById('saveIndicator');
        el.classList.add('visible');
        setTimeout(() => el.classList.remove('visible'), 2000);
    },

    applyPadlocksVisuals() {
        const locks = window.firebaseOperations.getLocks(); const padlockSlots = ["20:00", "23:00", "01:00", "04:00", "06:00"];
        document.querySelectorAll("td[data-location='Vertical Patrol']").forEach(td => {
            const time = td.getAttribute("data-time"); if (!padlockSlots.includes(time)) return;
            const key = `Vertical Patrol-${time}`; const isLocked = !!locks[key];
            let icon = td.querySelector('.padlock-icon');
            if (!icon) {
                const wrapper = document.createElement('div'); wrapper.className = "absolute top-0 right-0 p-0.5 cursor-pointer z-10 hover:bg-slate-100 rounded";
                wrapper.onclick = () => { window.firebaseOperations.toggleLock(key); const newStatus = !locks[key]; wrapper.innerHTML = newStatus ? `<i data-lucide="lock" class="w-2.5 h-2.5 text-red-500"></i>` : `<i data-lucide="unlock" class="w-2.5 h-2.5 text-green-500/50 hover:text-green-500"></i>`; lucide.createIcons(); };
                wrapper.classList.add('padlock-icon'); td.appendChild(wrapper); icon = wrapper;
            }
            icon.innerHTML = isLocked ? `<i data-lucide="lock" class="w-2.5 h-2.5 text-red-500"></i>` : `<i data-lucide="unlock" class="w-2.5 h-2.5 text-green-500/50 hover:text-green-500"></i>`; lucide.createIcons();
        });
    },
    validateAllCells() {
        document.querySelectorAll('td.conflict-cell').forEach(cell => cell.classList.remove('conflict-cell')); const timeSlotUsage = {};
        document.querySelectorAll('.roster-input').forEach(input => {
            const time = input.dataset.time; const cell = input.closest('td'); const inputValue = input.value.trim(); if (!time || !inputValue) return;
            if (!timeSlotUsage[time]) timeSlotUsage[time] = {}; const staffIds = inputValue.split(/[\s,;\/]+/).filter(id => id);
            staffIds.forEach(staffId => {
                if (!timeSlotUsage[time][staffId]) timeSlotUsage[time][staffId] = []; timeSlotUsage[time][staffId].push(cell);
                const staffMember = this.staffDataCache.find(s => s.staffId === staffId); if (staffMember && this.isOnBreak(staffMember, time)) cell.classList.add('conflict-cell');
            });
        });
        for (const time in timeSlotUsage) { for (const staffId in timeSlotUsage[time]) { if (timeSlotUsage[time][staffId].length > 1) { timeSlotUsage[time][staffId].forEach(cell => cell.classList.add('conflict-cell')); } } }
    },
    showToast(message, type = "info") {
        const container = document.getElementById("toast-container"); const colors = { success: "bg-emerald-600 text-white", error: "bg-red-600 text-white", warning: "bg-amber-400 text-black", info: "bg-blue-600 text-white" };
        const toast = document.createElement("div"); toast.className = `${colors[type]} px-4 py-2 rounded shadow-xl flex items-center gap-2 transform -translate-y-4 opacity-0 transition-all duration-200 text-xs font-bold pointer-events-auto`; toast.innerHTML = `<span>${message}</span>`;
        container.appendChild(toast); requestAnimationFrame(() => { toast.classList.remove("-translate-y-4", "opacity-0"); }); setTimeout(() => { toast.classList.add("-translate-y-4", "opacity-0"); setTimeout(() => toast.remove(), 200); }, 2000);
    },
    copyTSV() {
        if (!this.generatedRoster) return this.showToast("No roster", "error");
        const tsv = this.OUTPUT_ORDER.map(loc => `${loc}\t${this.ROSTER_TIMES.map(time => (this.generatedRoster[loc]?.[time] || []).join(" | ")).join("\t")}`).join("\n");
        navigator.clipboard.writeText(`Location\t${this.ROSTER_TIMES.join("\t")}\n${tsv}`).then(() => this.showToast("Copied", "success"), () => this.showToast("Failed", "error"));
    },
    downloadPDF() {
        // Ensure libs are ready (prevents "sometimes works" on slow mobile loads)
        if (!window.jspdf || !window.jspdf.jsPDF) {
            this.showToast("PDF engine not loaded yet. Try again in 2s.", "warning");
            return;
        }
        if (!window.jspdf.jsPDF.API || !window.jspdf.jsPDF.API.autoTable) {
            // Some builds expose autoTable via doc.autoTable after plugin load; verify by creating doc
            // We'll still proceed and catch if missing.
        }
        if (!this.generatedRoster) return this.showToast('No roster', 'error');
        try {
            const { jsPDF } = window.jspdf; const doc = new jsPDF({ orientation: "landscape", unit: "mm", format: "a4" });
            const rosterDate = document.getElementById('rosterDate').value; const rosterDay = document.getElementById('rosterDay').value;
            doc.setFontSize(14); doc.text(`Staff Roster - ${rosterDate} (${rosterDay})`, 14, 15);
            const specialNotes = { "20:00": "@ 20:30", "01:00": "@ 01:30", "06:00": "@ 06:30" };
            const mainRosterBody = this.OUTPUT_ORDER.map(locName => {
                const rowData = this.ROSTER_TIMES.map(time => {
                    let staffText = (this.generatedRoster[locName]?.[time] || []).filter(Boolean).join('\n'); 
                    if (locName === 'Vertical Patrol' && staffText && specialNotes[time]) return `${staffText}\n${specialNotes[time]}`; return staffText;
                }); return [locName, ...rowData];
            });
            doc.autoTable({ head: [['Location', ...this.ROSTER_TIMES]], body: mainRosterBody, startY: 20, theme: 'grid', styles: { fontSize: 6, cellPadding: 1, halign: 'center', valign: 'middle', lineColor: [200, 200, 200] }, headStyles: { fillColor: [51, 65, 85], textColor: 255, fontSize: 7, fontStyle: 'bold' }, columnStyles: { 0: { fontStyle: "bold", cellWidth: 28, halign: 'left', fillColor: [241, 245, 249] } } });

            // --- Break time table (assigned ACTIVE staff) ---
            const assignedActive = this.getAssignedActiveStaff(this.generatedRoster);
            const breakBody = assignedActive.map(s => [s.staffId, s.name, `${(s.breakStart || '--:--')} - ${(s.breakEnd || '--:--')}`]);
            if (breakBody.length) {
                const y = (doc.lastAutoTable && doc.lastAutoTable.finalY) ? doc.lastAutoTable.finalY + 6 : 120;
                doc.setFontSize(10);
                doc.text('Break Time (Assigned Staff)', 14, y);
                doc.autoTable({
                    head: [['ID', 'Name', 'Break']],
                    body: breakBody,
                    startY: y + 2,
                    theme: 'grid',
                    styles: { fontSize: 8, cellPadding: 1.5, valign: 'middle', lineColor: [200, 200, 200] },
                    headStyles: { fillColor: [241, 245, 249], textColor: 30, fontStyle: 'bold' },
                    columnStyles: { 0: { cellWidth: 18, fontStyle: 'bold' }, 1: { cellWidth: 55 }, 2: { cellWidth: 30, fontStyle: 'bold' } }
                });
            }
            const blob = doc.output('blob');
            const blobUrl = URL.createObjectURL(blob);
            // track & clean up previous object URL
            if (this._pdfObjectUrl) { try { URL.revokeObjectURL(this._pdfObjectUrl); } catch(e){} }
            this._pdfObjectUrl = blobUrl;
            document.getElementById('pdfDownloadLink').href = blobUrl;
            const previewEl = document.getElementById('pdfPreview');
            // iOS/WebView safety: do not embed PDF previews (can trigger iframe/about origin errors).
            // Keep only the Download link.
document.getElementById('pdfModal').classList.remove('hidden'); document.getElementById('pdfModal').classList.add('flex');
        } catch (e) { console.error(e); this.showToast('Error creating PDF', 'error'); }
    },
    closePdfModal() {
        const preview = document.getElementById('pdfPreview');
        // iOS/WebView safety: no embedded PDF preview to clear.
if (this._pdfObjectUrl) {
            try { URL.revokeObjectURL(this._pdfObjectUrl); } catch (e) {}
            this._pdfObjectUrl = null;
        }
        const link = document.getElementById('pdfDownloadLink');
        if (link) link.href = '#';
        document.getElementById('pdfModal').classList.add('hidden');
        document.getElementById('pdfModal').classList.remove('flex');
    },
    smartShuffleOrGenerate(isShuffle = false) {
        const sel = document.getElementById('shuffleModeSel');
        if (sel) this.shuffleMode = sel.value || 'random';

        if (!isShuffle) {
            this._forcedSeed = null;
            return this.runRosterGeneration(false);
        }

        if (this.shuffleMode === 'rotate') {
            this._lastSeed = (this._lastSeed == null ? Date.now() : (this._lastSeed + 1));
            this._forcedSeed = this._lastSeed;
            return this.runRosterGeneration(true);
        }

        if (this.shuffleMode === 'random') {
            this._forcedSeed = Date.now();
            this._lastSeed = this._forcedSeed;
            return this.runRosterGeneration(true);
        }

        // Balanced (tries multiple seeds, chooses best score)
        const trials = 8;
        let best = { score: -Infinity, roster: null, seed: null };

        this._suppressSave = true;
        const originalRoster = this.generatedRoster ? JSON.parse(JSON.stringify(this.generatedRoster)) : null;

        for (let i = 0; i < trials; i++) {
            const seed = (Date.now() + i * 1013) >>> 0;
            this._forcedSeed = seed;
            try {
                this.runRosterGeneration(true);
                const roster = this.generatedRoster ? JSON.parse(JSON.stringify(this.generatedRoster)) : null;
                const score = roster ? (this.computeRosterScore(roster) + this.computeExposureBalanceScore(roster)) : -Infinity;
                if (score > best.score) best = { score, roster, seed };
            } catch (e) {}
        }

        this._suppressSave = false;

        if (best.roster) {
            this._forcedSeed = best.seed;
            this._lastSeed = best.seed;
            this._lastBalancedScore = best.score;
            this.applyGeneratedRoster(best.roster);
            if (window.firebaseOperations && window.firebaseOperations.saveRoster) {
                window.firebaseOperations.saveRoster(best.roster);
            }
            return;
        }

        // fallback restore
        if (originalRoster) {
            this.generatedRoster = originalRoster;
            this.displayRoster(originalRoster);
        }
        this._forcedSeed = Date.now();
        this._lastSeed = this._forcedSeed;
        this.runRosterGeneration(true);
    },

    computeRosterScore(roster) {
        const times = this.ROSTER_TIMES;
        const critical = new Set(["HHMD", "Guard House", "KIOSK"]);
        let score = 0;

        for (const loc of this.OUTPUT_ORDER) {
            const locObj = roster[loc];
            if (!locObj) continue;
            for (const t of times) {
                const cell = locObj[t];
                const ids = Array.isArray(cell) ? cell : [cell];
                const filled = ids.filter(x => x && x !== "--").length;
                score += filled * (critical.has(loc) ? 6 : 2);
                if (critical.has(loc) && filled > 0) score += 1;
            }
        }

        const track = {};
        for (const loc of this.OUTPUT_ORDER) {
            const locObj = roster[loc];
            if (!locObj) continue;
            for (let ti = 0; ti < times.length; ti++) {
                const t = times[ti];
                const cell = locObj[t];
                const ids = Array.isArray(cell) ? cell : [cell];
                for (const id of ids) {
                    if (!id || id === "--") continue;
                    (track[id] ||= []).push({ ti, loc });
                }
            }
        }

        for (const arr of Object.values(track)) {
            arr.sort((a,b)=>a.ti-b.ti);
            for (let i=1;i<arr.length;i++){
                if (arr[i].ti === arr[i-1].ti) continue;
                if (arr[i].ti === arr[i-1].ti + 1 && arr[i].loc === arr[i-1].loc) {
                    score -= critical.has(arr[i].loc) ? 5 : 3;
                } else {
                    score += 0.5;
                }
            }
        }
        return score;

    },
    // ===== Exposure Balance (Insights-driven) =====
    _loadExposureBalanceConfig() {
    try {
        const raw = localStorage.getItem('exposureBalance_v2') || localStorage.getItem('exposureBalance_v1');
        const defaults = {
            enabled: false,
            weight: 3,
            locWeights: { "HHMD": 1, "Guard House": 1, "KIOSK": 1 },
            targets: {},
            // Expectations / workload balancing (Insights + scoring)
            criticalMaxDiff: 1,          // allowed +/- diff vs average exposures for critical locations
            workloadTolerancePct: 0.15,  // allowed +/-15% of weighted workload vs average
            // Weighted workload per location (VP omitted by default)
            workloadWeights: {
                "HHMD": 3,
                "Guard House": 2,
                "KIOSK": 1.5,
                "Pass Counter": 1,
                "Lobby": 0.8,
                "Report Room": 0.8,
                "Vertical Patrol": 0,
                "Tango Papa": 1
            }
        };
        if (!raw) return { ...defaults };

        const cfg = JSON.parse(raw);
        if (!cfg || typeof cfg !== 'object') throw new Error('bad cfg');

        cfg.enabled = !!cfg.enabled;
        cfg.weight = Number(cfg.weight ?? defaults.weight);
        if (!Number.isFinite(cfg.weight) || cfg.weight < 0) cfg.weight = defaults.weight;

        cfg.locWeights = (cfg.locWeights && typeof cfg.locWeights === 'object') ? cfg.locWeights : { ...defaults.locWeights };
        cfg.targets = (cfg.targets && typeof cfg.targets === 'object') ? cfg.targets : {};

        cfg.criticalMaxDiff = Number(cfg.criticalMaxDiff ?? defaults.criticalMaxDiff);
        if (!Number.isFinite(cfg.criticalMaxDiff) || cfg.criticalMaxDiff < 0) cfg.criticalMaxDiff = defaults.criticalMaxDiff;

        cfg.workloadTolerancePct = Number(cfg.workloadTolerancePct ?? defaults.workloadTolerancePct);
        if (!Number.isFinite(cfg.workloadTolerancePct) || cfg.workloadTolerancePct < 0) cfg.workloadTolerancePct = defaults.workloadTolerancePct;

        cfg.workloadWeights = (cfg.workloadWeights && typeof cfg.workloadWeights === 'object') ? cfg.workloadWeights : { ...defaults.workloadWeights };

        return { ...defaults, ...cfg, locWeights: cfg.locWeights, targets: cfg.targets, workloadWeights: cfg.workloadWeights };
    } catch (e) {
        return {
            enabled: false,
            weight: 3,
            locWeights: { "HHMD": 1, "Guard House": 1, "KIOSK": 1 },
            targets: {},
            criticalMaxDiff: 1,
            workloadTolerancePct: 0.15,
            workloadWeights: {
                "HHMD": 3,
                "Guard House": 2,
                "KIOSK": 1.5,
                "Pass Counter": 1,
                "Lobby": 0.8,
                "Report Room": 0.8,
                "Vertical Patrol": 0,
                "Tango Papa": 1
            }
        };
    }
},
    _saveExposureBalanceConfig(cfg) {
        try { localStorage.setItem('exposureBalance_v1', JSON.stringify(cfg)); } catch (e) {}
    },
    getActiveStaffIdsForDay() {
        // Attendance-driven "active for today" pool
        try {
            const present = (this.staffDataCache || []).filter(s => String(s.attendance || '').toLowerCase() === 'yes');
            return present.map(s => String(s.staffId || '').trim()).filter(Boolean);
        } catch (e) {
            return [];
        }
    },
    computeExposureBalanceScore(roster) {
    // Returns a score adjustment (positive is better). Disabled => 0.
    const cfg = this._loadExposureBalanceConfig();
    if (!cfg.enabled) return 0;

    const locs = ["HHMD", "Guard House", "KIOSK"];
    const times = this.ROSTER_TIMES || [];
    const activeIds = this.getActiveStaffIdsForDay();
    if (!roster || !times.length || !activeIds.length) return 0;

    const maxDiff = Number(cfg.criticalMaxDiff ?? 1);
    const tolPct = Number(cfg.workloadTolerancePct ?? 0.15);

    // Build exposure counts per location for active IDs only
    const exposureByLoc = {};
    for (const loc of locs) {
        exposureByLoc[loc] = {};
        const locObj = roster[loc] || {};
        for (const t of times) {
            const cell = locObj[t];
            const ids = Array.isArray(cell) ? cell : [cell];
            for (const id of ids) {
                if (!id || id === "--") continue;
                const sid = String(id);
                if (!activeIds.includes(sid)) continue;
                exposureByLoc[loc][sid] = (exposureByLoc[loc][sid] || 0) + 1;
            }
        }
        // ensure all active appear
        for (const id of activeIds) {
            const sid = String(id);
            if (!(sid in exposureByLoc[loc])) exposureByLoc[loc][sid] = 0;
        }
    }

    const weight = Number(cfg.weight ?? 3);
    const locWeights = cfg.locWeights || {};
    const targets = cfg.targets || {};

    let adj = 0;

    // 1) Variance + target matching per critical location
    for (const loc of locs) {
        const counts = exposureByLoc[loc] || {};
        const locWeight = Number(locWeights[loc] ?? 1) || 1;

        if (targets[loc] && typeof targets[loc] === 'object' && Object.keys(targets[loc]).length) {
            // Penalize absolute error against targets
            for (const id of activeIds) {
                const sid = String(id);
                const tgt = Number(targets[loc][sid]);
                if (!Number.isFinite(tgt)) continue;
                const cur = Number(counts[sid] || 0);
                const err = Math.abs(cur - tgt);
                adj -= err * weight * locWeight;
            }
        } else {
            // Equalize exposures among active IDs: minimize variance
            const arr = activeIds.map(id => Number(counts[String(id)] || 0));
            const mean = arr.reduce((a,b)=>a+b,0) / Math.max(1, arr.length);
            let varSum = 0;
            for (const v of arr) {
                const d = v - mean;
                varSum += d * d;
            }
            const variance = varSum / Math.max(1, arr.length);
            adj -= variance * weight * locWeight;

            // Additional: penalize outliers outside expected band around mean
            const target = Math.round(mean);
            const low = Math.max(0, target - maxDiff);
            const high = target + maxDiff;
            for (const v of arr) {
                if (v < low) adj -= (low - v) * weight * locWeight * 1.5;
                if (v > high) adj -= (v - high) * weight * locWeight * 1.5;
            }
        }
    }

    // 2) Weighted workload fairness (VP omitted by default via weight 0)
    const w = cfg.workloadWeights || {};
    const wl = {};
    for (const id of activeIds) wl[String(id)] = 0;

    for (const loc of (this.OUTPUT_ORDER || [])) {
        const lw = Number(w[loc] ?? 1);
        if (!Number.isFinite(lw)) continue;
        const locObj = roster[loc] || {};
        for (const t of times) {
            const cell = locObj[t];
            const ids = Array.isArray(cell) ? cell : [cell];
            for (const id of ids) {
                if (!id || id === "--") continue;
                const sid = String(id);
                if (!activeIds.includes(sid)) continue;
                wl[sid] += lw;
            }
        }
    }

    const arrW = activeIds.map(id => wl[String(id)] || 0);
    const meanW = arrW.reduce((a,b)=>a+b,0) / Math.max(1, arrW.length);
    const lowW = meanW * (1 - tolPct);
    const highW = meanW * (1 + tolPct);

    for (const v of arrW) {
        if (v < lowW) adj -= (lowW - v) * weight * 0.5;
        if (v > highW) adj -= (v - highW) * weight * 0.5;
    }

    return adj;
},

buildWorkloadBalanceReport(roster) {
    const cfg = this._loadExposureBalanceConfig();
    const activeIds = this.getActiveStaffIdsForDay();
    const times = this.ROSTER_TIMES || [];
    if (!roster || !activeIds.length || !times.length) {
        return { html: '<div class="mt-3 p-3 rounded-lg border border-slate-200 bg-white text-xs text-slate-500">No roster / no active staff to evaluate workload balance.</div>' };
    }

    const staff = (this.staffDataCache || []);
    const hhmdQualifiedActiveIds = staff
        .filter(s => String(s.attendance || '').toLowerCase() === 'yes' && String(s.hhmd || '').toLowerCase() === 'yes')
        .map(s => String(s.staffId || '').trim())
        .filter(Boolean);

    const isActive = (sid) => activeIds.includes(String(sid));
    const isHHMDQualifiedActive = (sid) => hhmdQualifiedActiveIds.includes(String(sid));

    // Exposure counts per location (active IDs only). HHMD counts ONLY qualified active.
    const exposure = {};
    const invalidHHMD = []; // {id,time}
    for (const loc of (this.OUTPUT_ORDER || [])) {
        exposure[loc] = {};
        const locObj = roster[loc] || {};
        for (const t of times) {
            const cell = locObj[t];
            const ids = Array.isArray(cell) ? cell : [cell];
            for (const id of ids) {
                if (!id || id === '--') continue;
                const sid = String(id);
                if (!isActive(sid)) continue;

                if (loc === 'HHMD' && !isHHMDQualifiedActive(sid)) {
                    invalidHHMD.push({ id: sid, time: t });
                    continue;
                }

                exposure[loc][sid] = (exposure[loc][sid] || 0) + 1;
            }
        }
    }

    const criticalLocs = ['HHMD', 'Guard House', 'KIOSK'];
    const maxDiff = Number(cfg.criticalMaxDiff ?? 1);
    const tolPct = Number(cfg.workloadTolerancePct ?? 0.15);

    const fmt = (n) => (Number.isFinite(n) ? n.toFixed(2) : String(n));

    const pill = (text, tone="slate") => {
        const cls = tone === "good" ? "bg-emerald-50 text-emerald-700 border-emerald-200"
                  : tone === "bad" ? "bg-rose-50 text-rose-700 border-rose-200"
                  : "bg-slate-50 text-slate-700 border-slate-200";
        return `<span class="inline-flex items-center gap-1 px-2 py-1 rounded-full border ${cls} text-[11px] font-semibold">${text}</span>`;
    };


    // Helper: total filled slots for a location (active IDs only, including non-qualified on HHMD to measure requirement)
    const totalFilledSlots = (loc) => {
        let total = 0;
        const locObj = roster[loc] || {};
        for (const t of times) {
            const cell = locObj[t];
            const ids = Array.isArray(cell) ? cell : [cell];
            for (const id of ids) {
                if (!id || id === '--') continue;
                const sid = String(id);
                if (!isActive(sid)) continue;
                total += 1;
            }
        }
        return total;
    };

    // Compute critical expectations (qualification-aware for HHMD)
    const crit = criticalLocs.map(loc => {
        const counts = exposure[loc] || {};
        let poolIds = activeIds;
        let poolLabel = `${activeIds.length} active`;
        let totalSlots = 0;
        let note = '';
        let invalid = '';

        if (loc === 'HHMD') {
            poolIds = hhmdQualifiedActiveIds;
            poolLabel = `${hhmdQualifiedActiveIds.length} qualified active`;
            totalSlots = totalFilledSlots('HHMD');

            if (poolIds.length === 0) {
                note = `SHORTFALL: 0 qualified active for ${totalSlots} HHMD slots`;
            } else if (poolIds.length === 1) {
                note = `CAPACITY: 1 qualified active for ${totalSlots} HHMD slots (concentration unavoidable)`;
            } else if (poolIds.length === 2) {
                note = `CAPACITY: 2 qualified active for ${totalSlots} HHMD slots (heavy load)`;
            }

            if (invalidHHMD.length) {
                invalid = `INVALID: ${invalidHHMD.length} HHMD assignment(s) to non-qualified staff`;
            }
        } else {
            // total exposures among active ids for this location
            totalSlots = poolIds.reduce((s, id) => s + (Number(counts[String(id)]) || 0), 0);
        }

        const total = poolIds.reduce((s, id) => s + (Number(counts[String(id)]) || 0), 0);
        const avg = total / Math.max(1, poolIds.length);

        // Expected band
        let target = Math.round(avg);
        let low = Math.max(0, target - maxDiff);
        let high = target + maxDiff;

        // For HHMD, if there are enough slots to give everyone at least 1, enforce low>=1 (only when pool >=2)
        if (loc === 'HHMD' && poolIds.length >= 2 && totalSlots >= poolIds.length) {
            low = Math.max(low, 1);
        }

        const over = [];
        const under = [];

        // If HHMD pool is 0 or 1, balancing is not applicable
        if (!(loc === 'HHMD' && poolIds.length <= 1)) {
            for (const id of poolIds) {
                const v = Number(counts[String(id)] || 0);
                if (v > high) over.push({ id, v });
                if (v < low) under.push({ id, v });
            }
        }

        // Status pill
        let statusPill = '';
        if (loc === 'HHMD' && poolIds.length === 0) {
            statusPill = pill('SHORTFALL', 'bad');
        } else if (loc === 'HHMD' && poolIds.length === 1) {
            statusPill = pill('CAPACITY 1', 'bad');
        } else {
            const ok = (over.length === 0 && under.length === 0 && !(loc === 'HHMD' && invalidHHMD.length));
            statusPill = ok ? pill('OK', 'good') : pill(`${over.length + under.length + (loc === 'HHMD' ? (invalidHHMD.length ? 1 : 0) : 0)} outliers`, 'bad');
        }

        // Display strings
        const bandText = (loc === 'HHMD' && poolIds.length <= 1) ? 'N/A' : `${low}â€“${high}`;
        const avgText = (loc === 'HHMD' && poolIds.length === 0) ? 'â€”' : fmt(avg);

        return {
            loc, total, avg, target, low, high, counts,
            over, under,
            poolIds, poolLabel, totalSlots,
            note, invalid, invalidHHMD,
            bandText, avgText,
            statusPill
        };
    });

    // Weighted workload (uses weights; VP weight is 0 by default). HHMD workload counts only qualified HHMD exposures (invalid HHMD assignments are flagged separately).
    const w = Object.assign({}, this.DEFAULT_LOCATION_WEIGHTS || {});
    const workload = {};
    for (const id of activeIds) workload[String(id)] = 0;

    for (const loc of Object.keys(exposure)) {
        const lw = Number(w[loc] ?? 1);
        if (!Number.isFinite(lw)) continue;
        const counts = exposure[loc] || {};
        for (const id of activeIds) {
            const sid = String(id);
            workload[sid] += (Number(counts[sid] || 0) * lw);
        }
    }

    const wlArr = activeIds.map(id => workload[String(id)] || 0);
    const wlAvg = wlArr.reduce((a, b) => a + b, 0) / Math.max(1, wlArr.length);
    const wlLow = wlAvg * (1 - tolPct);
    const wlHigh = wlAvg * (1 + tolPct);

    const wlOver = [];
    const wlUnder = [];
    for (const id of activeIds) {
        const v = Number(workload[String(id)] || 0);
        if (v > wlHigh) wlOver.push({ id, v });
        if (v < wlLow) wlUnder.push({ id, v });
    }

    const rows = crit.map(c => {
        const locLabel = (c.loc === 'HHMD')
            ? `<div class="text-xs font-semibold text-slate-700">HHMD</div><div class="text-[10px] text-slate-400">${c.poolLabel}</div>`
            : `<div class="text-xs font-semibold text-slate-700">${c.loc}</div>`;

        const avgCell = (c.loc === 'HHMD')
            ? `<div class="text-xs text-slate-600">${c.avgText}</div><div class="text-[10px] text-slate-400">${c.totalSlots} slots</div>`
            : `<div class="text-xs text-slate-600">${fmt(c.avg)}</div>`;

        const bandCell = `<div class="text-xs text-slate-600">${c.bandText}</div>`;

        return `<tr class="border-b border-slate-100">
          <td class="py-2 px-2">${locLabel}</td>
          <td class="py-2 px-2">${avgCell}</td>
          <td class="py-2 px-2">${bandCell}</td>
          <td class="py-2 px-2 text-xs">${c.statusPill}</td>
        </tr>`;
    }).join('');

    const listOutliers = (arr, label, tone = 'bad') => {
        if (!arr.length) return '';
        const chips = arr.map(x => pill(`${x.id} Ã—${(x.v != null ? x.v : 0)}`, tone)).join(' ');
        return `<div class="mt-2">
          <div class="text-[11px] font-semibold text-slate-600">${label}</div>
          <div class="mt-1 flex flex-wrap gap-2">${chips}</div>
        </div>`;
    };

    const listInvalidHHMD = () => {
        if (!invalidHHMD.length) return '';
        const chips = invalidHHMD.slice(0, 12).map(x => pill(`${x.id} @${x.time}`, 'bad')).join(' ');
        const more = invalidHHMD.length > 12 ? `<div class="mt-1 text-[11px] text-slate-500">+${invalidHHMD.length - 12} moreâ€¦</div>` : '';
        return `<div class="mt-2">
          <div class="text-[11px] font-semibold text-slate-600">HHMD: non-qualified assignment(s)</div>
          <div class="mt-1 flex flex-wrap gap-2">${chips}</div>
          ${more}
        </div>`;
    };

    const critOutliersHtml = crit.map(c => {
        let out = '';
        if (c.note) {
            out += `<div class="mt-2 text-[11px] ${c.loc === 'HHMD' && c.poolIds.length === 0 ? 'text-rose-600' : 'text-amber-600'} font-semibold">${c.note}</div>`;
        }
        if (c.invalid) {
            out += `<div class="mt-1 text-[11px] text-rose-600 font-semibold">${c.invalid}</div>`;
        }
        const over = c.over.length ? listOutliers(c.over, `${c.loc}: too high`) : '';
        const under = c.under.length ? listOutliers(c.under, `${c.loc}: too low`) : '';
        out += over + under;
        if (c.loc === 'HHMD') out += listInvalidHHMD();
        return out;
    }).join('');

    const wlSummary = `<div class="mt-3 p-3 rounded-lg border border-slate-200 bg-white">
      <div class="flex items-center justify-between gap-2">
        <div class="text-xs font-semibold text-slate-700">Weighted workload</div>
        <div class="text-[11px] text-slate-500">avg ${fmt(wlAvg)} â€¢ range ${fmt(wlLow)}â€“${fmt(wlHigh)}</div>
      </div>
      ${listOutliers(wlOver, 'Workload: too high')}
      ${listOutliers(wlUnder, 'Workload: too low')}
      <div class="mt-2 text-[11px] text-slate-500">
        Workload uses weights (VP weight is 0 by default). Adjust tolerance in settings below.
      </div>
    </div>`;

    const suggestionsUI = `<div class="mt-3 p-3 rounded-lg border border-slate-200 bg-white">
      <div class="flex items-center justify-between gap-2">
        <div class="text-xs font-semibold text-slate-700">Suggestions</div>
        <button class="px-3 py-1.5 rounded bg-indigo-600 text-white hover:bg-indigo-700"
                onclick="rosterSystem.generateSwapSuggestions()">Suggest swaps</button>
      </div>
      <div class="mt-2 text-[11px] text-slate-500">
        Suggestions propose simple swaps at the same time slot to reduce outliers. They affect the current roster only.
      </div>
      <div id="swapSuggestions" class="mt-2"></div>
    </div>`;

    // Store for swap generator
    this._lastWorkloadBalanceReport = { exposure, workload, crit, wlAvg, wlLow, wlHigh, activeIds, times, hhmdQualifiedActiveIds, invalidHHMD };

    const html = `
      <div class="mt-3 p-3 rounded-lg border border-slate-200 bg-white">
        <div class="flex items-center justify-between gap-2">
          <div class="text-xs font-semibold text-slate-700">Workload balance (expectations)</div>
          <div class="text-[11px] text-slate-500">${activeIds.length} active â€¢ ${times.length} time slots</div>
        </div>
        <div class="mt-2 overflow-auto rounded border border-slate-100">
          <table class="w-full">
            <thead class="bg-slate-50 border-b border-slate-100">
              <tr>
                <th class="py-2 px-2 text-[11px] text-slate-500 font-semibold text-left">Location</th>
                <th class="py-2 px-2 text-[11px] text-slate-500 font-semibold text-left">Avg exposure</th>
                <th class="py-2 px-2 text-[11px] text-slate-500 font-semibold text-left">Expected band</th>
                <th class="py-2 px-2 text-[11px] text-slate-500 font-semibold text-left">Status</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
        ${critOutliersHtml || `<div class="mt-2">${pill('All critical locations balanced','good')}</div>`}
      </div>
      ${wlSummary}
      ${suggestionsUI}
          `;

    return { html, exposure, workload, crit, wlAvg, wlLow, wlHigh };
}

,

    generateSwapSuggestions() {
        try {
            const roster = this.generatedRoster;
            const container = document.getElementById('swapSuggestions');
            if (!container) return;

            // Recompute & cache latest
            const rep = this.buildWorkloadBalanceReport(roster);
            const cache = this._lastWorkloadBalanceReport || {};
            const crit = (cache.crit || rep.crit || []);
            const times = (cache.times || this.ROSTER_TIMES || []);
            const activeIds = (cache.activeIds || this.getActiveStaffIdsForDay());
            const hhmdQualifiedActiveIds = (cache.hhmdQualifiedActiveIds || []);

            const suggestions = [];
            const maxSuggestions = 6;

            const findPosAtTime = (sid, t, excludeLocs=[]) => {
                for (const loc of (this.OUTPUT_ORDER || [])) {
                    if (excludeLocs.includes(loc)) continue;
                    const cell = ((roster[loc] || {})[t]);
                    if (!cell) continue;
                    const ids = Array.isArray(cell) ? cell.map(String) : [String(cell)];
                    const idx = ids.indexOf(String(sid));
                    if (idx !== -1) return { loc, idx, isArray: Array.isArray(cell) };
                }
                return null;
            };

            const cellHasId = (loc, t, sid) => {
                const cell = ((roster[loc] || {})[t]);
                if (!cell) return false;
                if (Array.isArray(cell)) return cell.map(String).includes(String(sid));
                return String(cell) === String(sid);
            };

            const proposeSameTimeSwap = (primaryLoc, overId, underId) => {
                for (const t of times) {
                    if (!cellHasId(primaryLoc, t, overId)) continue;
                    const underPos = findPosAtTime(underId, t, [primaryLoc]);
                    if (!underPos) continue;

                    // For HHMD, ensure underId is qualified
                    if (primaryLoc === 'HHMD' && !hhmdQualifiedActiveIds.includes(String(underId))) continue;

                    suggestions.push({
                        primaryLoc,
                        time: t,
                        overId: String(overId),
                        underId: String(underId),
                        otherLoc: underPos.loc
                    });
                    return true;
                }
                return false;
            };

            // Focus on HHMD first (qualification-aware)
            const hhmd = crit.find(x => x.loc === 'HHMD');
            if (hhmd && Array.isArray(hhmd.over) && Array.isArray(hhmd.under) && hhmdQualifiedActiveIds.length >= 2) {
                const overs = hhmd.over.slice().sort((a,b)=>b.v-a.v);
                const unders = hhmd.under.slice().sort((a,b)=>a.v-b.v);
                for (const o of overs) {
                    for (const u of unders) {
                        if (suggestions.length >= maxSuggestions) break;
                        proposeSameTimeSwap('HHMD', o.id, u.id);
                    }
                }
            }

            // Other critical locations (simple balancing, no special qualification)
            for (const locName of ['Guard House','KIOSK']) {
                if (suggestions.length >= maxSuggestions) break;
                const c = crit.find(x => x.loc === locName);
                if (!c) continue;
                const overs = (c.over || []).slice().sort((a,b)=>b.v-a.v);
                const unders = (c.under || []).slice().sort((a,b)=>a.v-b.v);

                for (const o of overs) {
                    for (const u of unders) {
                        if (suggestions.length >= maxSuggestions) break;
                        // underId must be active
                        if (!activeIds.includes(String(u.id))) continue;
                        proposeSameTimeSwap(locName, o.id, u.id);
                    }
                }
            }

            this._swapSuggestions = suggestions;

            if (!suggestions.length) {
                container.innerHTML = `<div class="text-xs text-slate-500">No safe same-time swap suggestions found (or HHMD has a qualified shortfall).</div>`;
                return;
            }

            container.innerHTML = suggestions.map((s, i) => `
              <div class="mt-2 p-2 rounded border border-slate-200 bg-slate-50 flex items-center justify-between gap-2">
                <div class="text-xs text-slate-700">
                  Swap <span class="font-mono font-semibold">${s.overId}</span> (${s.primaryLoc} @ ${s.time})
                  with <span class="font-mono font-semibold">${s.underId}</span> (${s.otherLoc} @ ${s.time})
                </div>
                <button class="px-3 py-1 rounded bg-slate-900 text-white hover:bg-slate-800 text-xs"
                        onclick="rosterSystem.applySwapSuggestion(${i})">Apply</button>
              </div>
            `).join('');
        } catch (e) {
            const container = document.getElementById('swapSuggestions');
            if (container) container.innerHTML = `<div class="text-xs text-rose-600">Unable to generate suggestions.</div>`;
        }
    },

    applySwapSuggestion(index) {
        try {
            const s = (this._swapSuggestions || [])[index];
            if (!s) return;

            const roster = this.generatedRoster;
            const t = s.time;

            const swapInCell = (loc, time, fromId, toId) => {
                if (!roster[loc]) roster[loc] = {};
                const cell = roster[loc][time];
                if (Array.isArray(cell)) {
                    const idx = cell.map(String).indexOf(String(fromId));
                    if (idx !== -1) cell[idx] = String(toId);
                } else if (cell != null && String(cell) === String(fromId)) {
                    roster[loc][time] = String(toId);
                }
            };

            swapInCell(s.primaryLoc, t, s.overId, s.underId);
            swapInCell(s.otherLoc, t, s.underId, s.overId);

            // Refresh UI: roster table + command center + insights
            try { this.applyGeneratedRoster(this.generatedRoster); } catch (e) {}
            try { this.renderStaffCards(); } catch (e) {}
            try { this.updateStats(); } catch (e) {}
            try { this.openInsights(); } catch (e) {}
        } catch (e) {}
    },
    setExposureBalanceEnabled(enabled) {
        const cfg = this._loadExposureBalanceConfig();
        cfg.enabled = !!enabled;
        this._saveExposureBalanceConfig(cfg);
    },
    setExposureBalanceWeight(weight) {
        const cfg = this._loadExposureBalanceConfig();
        cfg.weight = Number(weight);
        if (!Number.isFinite(cfg.weight) || cfg.weight < 0) cfg.weight = 0;
        this._saveExposureBalanceConfig(cfg);
    },
    saveExposureTargetsFromInsights() {
    const cfg = this._loadExposureBalanceConfig();
    const root = document.getElementById('insightsBody');
    if (!root) return;

    const enabledEl = root.querySelector('#expBalEnabled');
    const weightEl = root.querySelector('#expBalWeight');
    const tolEl = root.querySelector('#expBalTolPct');
    const maxDiffEl = root.querySelector('#expBalMaxDiff');

    cfg.enabled = !!(enabledEl && enabledEl.checked);
    cfg.weight = Number(weightEl ? weightEl.value : cfg.weight);
    if (!Number.isFinite(cfg.weight) || cfg.weight < 0) cfg.weight = 0;

    cfg.workloadTolerancePct = Number(tolEl ? tolEl.value : cfg.workloadTolerancePct);
    if (!Number.isFinite(cfg.workloadTolerancePct) || cfg.workloadTolerancePct < 0) cfg.workloadTolerancePct = 0.15;

    cfg.criticalMaxDiff = Number(maxDiffEl ? maxDiffEl.value : cfg.criticalMaxDiff);
    if (!Number.isFinite(cfg.criticalMaxDiff) || cfg.criticalMaxDiff < 0) cfg.criticalMaxDiff = 1;

    cfg.targets = cfg.targets && typeof cfg.targets === 'object' ? cfg.targets : {};

    // Collect per-location target inputs
    const inputs = root.querySelectorAll('input[data-exp-loc][data-exp-id]');
    inputs.forEach(inp => {
        const loc = inp.getAttribute('data-exp-loc');
        const id = inp.getAttribute('data-exp-id');
        if (!loc || !id) return;
        const v = Number(inp.value);
        if (!cfg.targets[loc]) cfg.targets[loc] = {};
        if (!Number.isFinite(v) || v < 0) {
            delete cfg.targets[loc][id];
        } else {
            cfg.targets[loc][id] = Math.round(v);
        }
    });

    // Location weights (for scoring)
    cfg.locWeights = cfg.locWeights && typeof cfg.locWeights === 'object' ? cfg.locWeights : {};
    const locWeightInputs = root.querySelectorAll('input[data-exp-loc-weight]');
    locWeightInputs.forEach(inp => {
        const loc = inp.getAttribute('data-exp-loc-weight');
        if (!loc) return;
        const v = Number(inp.value);
        if (!Number.isFinite(v) || v <= 0) return;
        cfg.locWeights[loc] = v;
    });

    try { localStorage.setItem('exposureBalance_v2', JSON.stringify(cfg)); } catch (e) {}
    this.toast("Insights settings saved", "success");

    // Re-render insights to reflect new expectations
    this.openInsights();
},
    clearExposureTargets() {
        const cfg = this._loadExposureBalanceConfig();
        cfg.targets = {};
        this._saveExposureBalanceConfig(cfg);
        this.showToast('Exposure targets cleared (back to equalize)', 'success');
        this.openInsights();
    },

    applyGeneratedRoster(roster) {
        this.generatedRoster = roster;
        this.displayRoster(roster);
        if (typeof this.updateStats === 'function') this.updateStats();
        if (typeof this.applyPadlocksVisuals === 'function') this.applyPadlocksVisuals();
    },


    // =========================
    // Blueprint (JSON) Manager
    // =========================
    blueprintEnabled: false,
    blueprintData: null,
    blueprintUpdatedAt: null,

    initBlueprint() {
        // Load toggle first
        const enabled = localStorage.getItem("bp_enabled");
        this.blueprintEnabled = enabled === "true";
        // Load data (local)
        const raw = localStorage.getItem("bp_json");
        if (raw) {
            try {
                this.blueprintData = JSON.parse(raw);
                this.blueprintUpdatedAt = localStorage.getItem("bp_updatedAt") || null;
            } catch (e) {
                console.warn("Invalid local blueprint JSON, clearing.");
                localStorage.removeItem("bp_json");
                localStorage.removeItem("bp_updatedAt");
                this.blueprintData = null;
                this.blueprintUpdatedAt = null;
            }
        }
        this.updateBlueprintToggleUI();
        // If connected, try cloud load (non-blocking, safest)
        if (window.firebaseOperations && window.firebaseOperations.loadBlueprint) {
            window.firebaseOperations.loadBlueprint()
                .then((bp) => {
                    if (bp && bp.blueprint) {
                        this.blueprintData = bp.blueprint;
                        this.blueprintUpdatedAt = bp.updatedAt || this.blueprintUpdatedAt;
                        localStorage.setItem("bp_json", JSON.stringify(this.blueprintData));
                        if (this.blueprintUpdatedAt) localStorage.setItem("bp_updatedAt", this.blueprintUpdatedAt);
                        this.updateBlueprintToggleUI();
                    }
                })
                .catch((e) => console.warn("Cloud blueprint load skipped:", e));
        }
    },

    toggleBlueprint() {
        this.blueprintEnabled = !this.blueprintEnabled;
        localStorage.setItem("bp_enabled", this.blueprintEnabled ? "true" : "false");
        this.updateBlueprintToggleUI();
        this.showToast(`Blueprint ${this.blueprintEnabled ? "ON" : "OFF"}`, "info");
    },

    updateBlueprintToggleUI() {
        const el = document.getElementById("blueprintToggleState");
        if (el) {
            el.textContent = this.blueprintEnabled ? "ON" : "OFF";
            el.className = this.blueprintEnabled ? "font-semibold text-emerald-600" : "font-semibold text-slate-600";
        }
    },

    openBlueprintManager() {
        const drawer = document.getElementById("blueprintDrawer");
        const back = document.getElementById("blueprintDrawerBackdrop");
        if (back) back.classList.remove("hidden");
        if (drawer) {
            drawer.classList.remove("translate-x-full");
            drawer.classList.add("translate-x-0");
        }
        this.refreshBlueprintList();
        this.updateActiveBlueprintStatusUI();
        if (window.lucide) window.lucide.createIcons();
    },

    closeBlueprintManager() {
        const drawer = document.getElementById("blueprintDrawer");
        const back = document.getElementById("blueprintDrawerBackdrop");
        if (drawer) {
            drawer.classList.add("translate-x-full");
            drawer.classList.remove("translate-x-0");
        }
        if (back) back.classList.add("hidden");
    },

    refreshBlueprintManager() {
        const has = !!this.blueprintData;
        const status = document.getElementById("bpStatus");
        const schema = document.getElementById("bpSchema");
        const updated = document.getElementById("bpUpdated");
        const preview = document.getElementById("bpJsonPreview");

        if (status) status.textContent = has ? "Loaded" : "None";
        if (schema) schema.textContent = has ? (this.blueprintData.schema || this.blueprintData.version || "unknown") : "-";
        if (updated) updated.textContent = this.blueprintUpdatedAt || "-";

        if (preview) {
            if (!has) {
                preview.textContent = "No blueprint loaded.\n\nImport a Blueprint JSON to use it as your rotation pattern reference.";
            } else {
                let json = "";
                try { json = JSON.stringify(this.blueprintData, null, 2); } catch (e) { json = String(this.blueprintData); }
                // limit size for mobile
                const max = 60 * 1024;
                preview.textContent = json.length > max ? (json.slice(0, max) + "\n\n...truncated...") : json;
            }
        }
    },

    async handleBlueprintFile(e) {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        try {
            const text = await file.text();
            const obj = JSON.parse(text);
            // Basic validation (lightweight)
            if (!obj || typeof obj !== "object") throw new Error("Invalid JSON");
            // Save
            this.blueprintData = obj;
            this.blueprintUpdatedAt = new Date().toISOString();
            localStorage.setItem("bp_json", JSON.stringify(obj));
            localStorage.setItem("bp_updatedAt", this.blueprintUpdatedAt);
            // Optional cloud save
            if (window.firebaseOperations && window.firebaseOperations.saveBlueprint) {
                await window.firebaseOperations.saveBlueprint(obj, this.blueprintUpdatedAt);
            }
            this.showToast("Blueprint imported", "success");
            this.refreshBlueprintManager();
        } catch (err) {
            console.error(err);
            this.showToast("Invalid Blueprint JSON", "error");
        } finally {
            e.target.value = "";
        }
    },

    exportBlueprintJson() {
        if (!this.blueprintData) {
            this.showToast("No blueprint to export", "error");
            return;
        }
        const blob = new Blob([JSON.stringify(this.blueprintData, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `blueprint_${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        this.showToast("Blueprint exported", "success");
    },

    async clearBlueprint() {
        this.blueprintData = null;
        this.blueprintUpdatedAt = null;
        localStorage.removeItem("bp_json");
        localStorage.removeItem("bp_updatedAt");
        // Optional cloud clear
        if (window.firebaseOperations && window.firebaseOperations.clearBlueprint) {
            try { await window.firebaseOperations.clearBlueprint(); } catch (e) { console.warn(e); }
        }
        this.showToast("Blueprint cleared", "success");
        this.refreshBlueprintManager();
    },


    openInsights() {
        const modal = document.getElementById('insightsModal');
        const body = document.getElementById('insightsBody');
        if (!modal || !body) return;
        const roster = this.generatedRoster;
        if (!roster) {
            body.innerHTML = '<div class="text-sm text-slate-500">No roster generated yet.</div>';
        } else {
            const baseScore = this.computeRosterScore(roster);
            const balAdj = this.computeExposureBalanceScore(roster);
            const score = baseScore + balAdj;
            const lines = [];
            lines.push(`<div class="text-sm font-semibold">Roster Score: <span class="font-mono">${score.toFixed(1)}</span></div>`);
            lines.push(`<div class="text-xs text-slate-500 mt-1">Base: <span class="font-mono">${baseScore.toFixed(1)}</span> &nbsp;|&nbsp; Exposure balance: <span class="font-mono">${balAdj.toFixed(1)}</span></div>`);
            if (this._lastBalancedScore != null) {
                lines.push(`<div class="text-xs text-slate-500 mt-1">Balanced pick: <span class="font-mono">${Number(this._lastBalancedScore).toFixed(1)}</span></div>`);
            }
            // Exposure balance controls (optional)
            const cfg = this._loadExposureBalanceConfig();
            const activeIds = this.getActiveStaffIdsForDay();
            const ctrl = [];
            ctrl.push(`<div class="mt-3 p-3 rounded-lg border border-slate-200 bg-slate-50">
                <div class="flex items-center justify-between gap-3">
                  <div class="text-xs font-semibold text-slate-700">Exposure balancing</div>
                  <label class="text-xs flex items-center gap-2">
                    <input id="expBalEnabled" type="checkbox" ${cfg.enabled ? 'checked' : ''} />
                    <span>Enable</span>
                  </label>
                </div>
                <div class="mt-2 flex items-center gap-2 text-xs">
                  <span class="text-slate-600">Weight</span>
                  <input id="expBalWeight" type="number" min="0" step="0.5" value="${Number(cfg.weight ?? 0)}"
                         class="w-20 px-2 py-1 rounded border border-slate-200 bg-white" />
                  <span class="ml-3 text-slate-600">Max diff</span>
                  <input id="expBalMaxDiff" type="number" min="0" step="1" value="${Number(cfg.criticalMaxDiff ?? 1)}"
                         class="w-16 px-2 py-1 rounded border border-slate-200 bg-white" />
                  <span class="ml-3 text-slate-600">WL tol</span>
                  <input id="expBalTolPct" type="number" min="0" step="0.05" value="${Number(cfg.workloadTolerancePct ?? 0.15)}"
                         class="w-20 px-2 py-1 rounded border border-slate-200 bg-white" />
                  <button class="ml-auto px-3 py-1.5 rounded bg-slate-900 text-white hover:bg-slate-800"
                          onclick="rosterSystem.saveExposureTargetsFromInsights()">Save</button>
                  <button class="px-3 py-1.5 rounded border border-slate-300 bg-white hover:bg-slate-50"
                          onclick="rosterSystem.clearExposureTargets()">Clear targets</button>
                </div>
                <div class="mt-2 text-[11px] text-slate-500">
                  This influences <b>Balanced</b> shuffle selection only (it chooses the best roster among multiple seeds).
                  Only <b>active</b> IDs for the selected day are considered.
                </div>
              </div>`);
            lines.push(ctrl.join(''));

            // Workload balance expectations & outliers
            try {
                const rep = this.buildWorkloadBalanceReport(roster);
                if (rep && rep.html) lines.push(rep.html);
            } catch (e) {}


            const exposure = {};
            for (const loc of this.OUTPUT_ORDER) {
                exposure[loc] = {};
                for (const t of this.ROSTER_TIMES) {
                    const cell = (roster[loc]||{})[t];
                    const ids = Array.isArray(cell) ? cell : [cell];
                    for (const id of ids) {
                        if (!id || id === "--") continue;
                        exposure[loc][id] = (exposure[loc][id]||0)+1;
                    }
                }
            }
            
            // Target editor (optional): set desired exposure counts per ID for critical locations
            const criticalLocs = ["HHMD","Guard House","KIOSK"];
            const makeTargetTable = (loc) => {
                const current = exposure[loc] || {};
                const ids = activeIds.slice().sort((a,b)=>String(a).localeCompare(String(b)));
                const rows = ids.map(id => {
                    const cur = Number(current[id] || 0);
                    const tgt = (((cfg.targets||{})[loc]||{})[id] ?? '');
                    return `<tr class="border-t border-slate-100">
                        <td class="py-1 pr-2 font-mono text-xs">${id}</td>
                        <td class="py-1 pr-2 text-xs text-slate-600">${cur}</td>
                        <td class="py-1">
                          <input class="w-16 px-2 py-1 rounded border border-slate-200 bg-white text-xs font-mono"
                                 placeholder="auto"
                                 value="${tgt}"
                                 data-exp-loc="${loc}" data-exp-id="${id}" />
                        </td>
                    </tr>`;
                }).join('');
                return `<div class="mt-3">
                    <div class="text-xs font-semibold text-slate-700">${loc} targets</div>
                    <div class="mt-1 overflow-auto max-h-48 rounded border border-slate-200 bg-white">
                      <table class="w-full text-left">
                        <thead class="sticky top-0 bg-white border-b border-slate-200">
                          <tr>
                            <th class="py-1 px-2 text-[11px] text-slate-500 font-semibold">ID</th>
                            <th class="py-1 px-2 text-[11px] text-slate-500 font-semibold">Current</th>
                            <th class="py-1 px-2 text-[11px] text-slate-500 font-semibold">Target</th>
                          </tr>
                        </thead>
                        <tbody class="px-2">${rows}</tbody>
                      </table>
                    </div>
                  </div>`;
            };
            if (activeIds && activeIds.length) {
                lines.push(`<div class="mt-3 p-3 rounded-lg border border-slate-200 bg-white">
                    <div class="text-xs font-semibold text-slate-700">Exposure targets (optional)</div>
                    <div class="text-[11px] text-slate-500 mt-1">Leave targets blank to use auto-equalize.</div>
                    ${criticalLocs.map(makeTargetTable).join('')}
                </div>`);
            }
const showLoc = (loc) => {
                const pairs = Object.entries(exposure[loc]||{}).sort((a,b)=>b[1]-a[1]).slice(0,8);
                const items = pairs.map(([id,c])=>`<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded bg-slate-100 text-xs font-mono">${id}<span class="text-slate-500">Ã—${c}</span></span>`).join(' ');
                return `<div class="mt-3"><div class="text-xs font-semibold text-slate-700">${loc} exposure</div><div class="mt-1 flex flex-wrap gap-1">${items || '<span class="text-xs text-slate-400">None</span>'}</div></div>`;
            };
            lines.push(showLoc("HHMD"));
            lines.push(showLoc("Guard House"));
            lines.push(showLoc("KIOSK"));
            body.innerHTML = lines.join('');
        }
        modal.classList.remove('hidden');
    },

    closeInsights() {
        const modal = document.getElementById('insightsModal');
        if (modal) modal.classList.add('hidden');
    },

    // ===== Blueprint Manager (UI helpers) =====
    toggleBlueprintEnabled() {
        // Back-compat: UI button calls this.
        this.toggleBlueprint();
        this.updateActiveBlueprintStatusUI();
    },

    updateActiveBlueprintStatusUI() {
        const el = document.getElementById("activeBlueprintStatus");
        if (el) {
            el.textContent = this.blueprintEnabled ? "ON" : "OFF";
            el.classList.toggle("text-emerald-600", !!this.blueprintEnabled);
            el.classList.toggle("text-slate-800", !this.blueprintEnabled);
        }
    },

    // Saved Blueprints are stored locally as a small library so "Refresh" always works
    async refreshBlueprintList() {
        const listEl = document.getElementById("blueprintList");
        if (!listEl) return;

        // Load local library
        let lib = [];
        try { lib = JSON.parse(localStorage.getItem("bp_library") || "[]") || []; } catch (e) { lib = []; }

        // Render
        if (!lib.length) {
            listEl.innerHTML = '<div class="text-xs text-slate-500">No saved blueprints yet. Import one, then it will appear here.</div>';
            return;
        }

        // newest first
        lib.sort((a,b)=> (b.createdAt||"").localeCompare(a.createdAt||""));

        listEl.innerHTML = lib.map((it)=>`
          <div class="p-2 rounded border border-slate-200 bg-slate-50 flex items-center justify-between gap-2">
            <div class="min-w-0">
              <div class="text-sm font-semibold truncate">${(it.name||"Blueprint")}</div>
              <div class="text-[11px] text-slate-500 truncate">${(it.createdAt||"")}</div>
            </div>
            <div class="flex gap-2 shrink-0">
              <button class="px-2 py-1 rounded border text-xs bg-white hover:bg-slate-100"
                onclick="rosterSystem.loadBlueprintFromLibrary('${it.id}')">Load</button>
              <button class="px-2 py-1 rounded border text-xs bg-white hover:bg-slate-100"
                onclick="rosterSystem.setActiveBlueprintFromLibrary('${it.id}')">Set Active</button>
              <button class="px-2 py-1 rounded border text-xs bg-white hover:bg-slate-100 text-red-600 border-red-200"
                onclick="rosterSystem.deleteBlueprintFromLibrary('${it.id}')">Delete</button>
            </div>
          </div>
        `).join("");
    },

    exportCurrentBlueprintJSON() {
        // UI button calls this; keep stable
        this.exportBlueprintJson();
    },

    async handleBlueprintFileImport(file) {
        if (!file) return;
        try {
            const text = await file.text();
            const obj = JSON.parse(text);
            if (!obj || typeof obj !== "object") throw new Error("Invalid JSON");

            // Save as active blueprint (local + optional cloud)
            this.blueprintData = obj;
            const nowIso = new Date().toISOString();
            this.blueprintUpdatedAt = nowIso;
            localStorage.setItem("bp_json", JSON.stringify(obj));
            localStorage.setItem("bp_updatedAt", nowIso);

            if (window.firebaseOperations && window.firebaseOperations.saveBlueprint) {
                try { await window.firebaseOperations.saveBlueprint(obj, nowIso); } catch (e) {}
            }

            // Also save into local library for selection
            let lib = [];
            try { lib = JSON.parse(localStorage.getItem("bp_library") || "[]") || []; } catch (e) { lib = []; }
            const id = "bp_" + Math.random().toString(36).slice(2, 10) + "_" + Date.now();
            const name = obj.name || obj.version || obj.schema || ("Blueprint " + new Date().toLocaleString());
            lib.unshift({ id, name, createdAt: nowIso, blueprint: obj });
            // keep small
            lib = lib.slice(0, 50);
            localStorage.setItem("bp_library", JSON.stringify(lib));

            this.showToast("Blueprint imported and saved.", "success");
            this.updateActiveBlueprintStatusUI();
            await this.refreshBlueprintList();
        } catch (e) {
            console.error(e);
            this.showToast("Import failed: invalid JSON file.", "error");
        }
    },

    async loadBlueprintFromLibrary(id) {
        if (!id) return;
        let lib = [];
        try { lib = JSON.parse(localStorage.getItem("bp_library") || "[]") || []; } catch (e) { lib = []; }
        const it = lib.find(x => x.id === id);
        if (!it || !it.blueprint) return this.showToast("Blueprint not found.", "warning");
        this.blueprintData = it.blueprint;
        this.blueprintUpdatedAt = it.createdAt || new Date().toISOString();
        localStorage.setItem("bp_json", JSON.stringify(this.blueprintData));
        localStorage.setItem("bp_updatedAt", this.blueprintUpdatedAt);
        this.showToast("Blueprint loaded.", "success");
        this.updateActiveBlueprintStatusUI();
    },

    async setActiveBlueprintFromLibrary(id) {
        // Same as Load, but also pushes to cloud active blueprint if available
        await this.loadBlueprintFromLibrary(id);
        if (window.firebaseOperations && window.firebaseOperations.saveBlueprint) {
            try { await window.firebaseOperations.saveBlueprint(this.blueprintData, new Date().toISOString()); } catch (e) {}
        }
        this.showToast("Active blueprint updated.", "success");
    },

    async deleteBlueprintFromLibrary(id) {
        if (!id) return;
        let lib = [];
        try { lib = JSON.parse(localStorage.getItem("bp_library") || "[]") || []; } catch (e) { lib = []; }
        const next = lib.filter(x => x.id !== id);
        localStorage.setItem("bp_library", JSON.stringify(next));
        await this.refreshBlueprintList();
        this.showToast("Saved blueprint deleted.", "success");
    },



};
document.addEventListener('DOMContentLoaded', () => { rosterSystem.init(); if (document.getElementById('shuffleModeSel')) { rosterSystem.shuffleMode = document.getElementById('shuffleModeSel').value || 'random'; document.getElementById('shuffleModeSel').addEventListener('change',(e)=>{ rosterSystem.shuffleMode = e.target.value; }); } if (window.__resolveRosterReady) window.__resolveRosterReady(); applyRosterVisibilityPref(); });

function setRosterHidden(hidden){
  document.body.classList.toggle('roster-hidden', !!hidden);
  try { localStorage.setItem('roster_hide', hidden ? '1' : '0'); } catch(e){}
  const btn = document.getElementById('toggleRosterBtn');
  if(btn){
    btn.title = hidden ? 'Show roster panel' : 'Hide roster panel';
    const icon = btn.querySelector('i[data-lucide]');
    if(icon){
      icon.setAttribute('data-lucide', hidden ? 'eye' : 'eye-off');
      // refresh lucide icons
      if(window.lucide && typeof window.lucide.createIcons === 'function'){
        window.lucide.createIcons();
      }
    }
  }
}
function toggleRosterVisibility(){
  const hidden = document.body.classList.contains('roster-hidden');
  setRosterHidden(!hidden);
}
function applyRosterVisibilityPref(){
  let pref = '0';
  try { pref = localStorage.getItem('roster_hide') || '0'; } catch(e){}
  setRosterHidden(pref === '1');
}

</script>
<!-- Blueprint Manager Drawer (side panel) -->
<div id="blueprintDrawerBackdrop" class="fixed inset-0 bg-black/40 hidden z-50" onclick="rosterSystem.closeBlueprintManager()"></div>

<aside id="blueprintDrawer" class="fixed top-0 right-0 h-full w-[92vw] max-w-md bg-white shadow-2xl border-l border-slate-200 translate-x-full transition-transform z-50 flex flex-col">
  <div class="p-4 border-b border-slate-200 flex items-center justify-between">
    <div class="flex items-center gap-2">
      <i data-lucide="layers" class="w-4 h-4"></i>
      <div class="font-semibold">Blueprint Manager</div>
    </div>
    <button class="px-2 py-1 rounded hover:bg-slate-100" onclick="rosterSystem.closeBlueprintManager()" aria-label="Close">
      <i data-lucide="x" class="w-5 h-5"></i>
    </button>
  </div>

  <div class="p-4 space-y-3 overflow-y-auto">
    <div class="text-sm text-slate-600">
      Blueprints are rotation-pattern templates. When <b>Blueprint ON</b>, generation will preserve the HHMD / Guard House / KIOSK pattern first, then relax others if needed.
    </div>

    <div class="p-3 rounded-lg bg-slate-50 border border-slate-200 space-y-2">
      <div class="font-semibold text-sm">Import / Export</div>
      <div class="flex items-center gap-2">
        <input id="blueprintFileInput" type="file" accept="application/json" class="hidden" />
        <button class="px-3 py-2 rounded bg-white border border-slate-200 hover:bg-slate-50 text-sm"
          onclick="document.getElementById('blueprintFileInput').click()">
          Import JSON
        </button>
        <button class="px-3 py-2 rounded bg-white border border-slate-200 hover:bg-slate-50 text-sm"
          onclick="rosterSystem.exportCurrentBlueprintJSON()">
          Export JSON
        </button>
      </div>
      <div class="text-xs text-slate-500">Tip: You can save multiple blueprints into Firebase and select them below.</div>
    </div>

    <div class="p-3 rounded-lg bg-white border border-slate-200 space-y-2">
      <div class="flex items-center justify-between">
        <div class="font-semibold text-sm">Saved Blueprints</div>
        <button class="px-2 py-1 rounded bg-slate-900 text-white text-xs hover:bg-slate-800"
          onclick="rosterSystem.refreshBlueprintList()">
          Refresh
        </button>
      </div>
      <div id="blueprintList" class="space-y-2 text-sm"></div>
    </div>

    <div class="p-3 rounded-lg bg-white border border-slate-200 space-y-2">
      <div class="font-semibold text-sm">Active Blueprint</div>
      <div class="flex items-center justify-between">
        <div class="text-sm"><span class="text-slate-500">Status:</span> <span id="activeBlueprintStatus" class="font-semibold">OFF</span></div>
        <button class="px-3 py-2 rounded bg-indigo-600 text-white text-sm hover:bg-indigo-700"
          onclick="rosterSystem.toggleBlueprintEnabled()">
          Toggle ON/OFF
        </button>
      </div>
      <div class="text-xs text-slate-500">Active blueprint applies during Generate/Shuffle; you do not need to re-import every time.</div>
    </div>
  </div>
</aside>

<!-- Insights Modal -->
<div id="insightsModal" class="fixed inset-0 bg-black/40 hidden items-center justify-center z-50 p-4">
  <div class="bg-white w-full max-w-lg rounded-xl shadow-xl overflow-hidden max-h-[85vh] flex flex-col insights-card">
    <div class="p-4 border-b border-slate-200 flex items-center justify-between">
      <div class="font-semibold flex items-center gap-2">
        <i data-lucide="bar-chart-3" class="w-4 h-4"></i> Insights
        <button id="insightsInfoBtn" class="ml-1 w-6 h-6 rounded-full border border-slate-300 text-slate-600 text-sm leading-none flex items-center justify-center hover:bg-slate-50 active:bg-slate-100" aria-label="About Insights" type="button">â“˜</button>
      </div>
      <button class="px-2 py-1 rounded hover:bg-slate-100" onclick="rosterSystem.closeInsights()" aria-label="Close">
        <i data-lucide="x" class="w-5 h-5"></i>
      </button>
    </div>
    <div id="insightsInfoPopover" class="insights-popover hidden" role="dialog" aria-label="Insights help">
          <div class="insights-popover-title">How to use Insights</div>
          <div class="insights-popover-body">
            <ul>
              <li><b>Workload balance</b> shows exposure per location (HHMD / Guard House / KIOSK). â€œExpected bandâ€ is the target range per staff.</li>
              <li><b>HHMD qualified</b>: If only 1â€“2 qualified staff are active, Insights marks a <i>shortfall</i> and widens expectations automatically.</li>
              <li><b>Outliers</b> = staff over/under the band. Scroll to see â€œtoo high / too lowâ€ chips by ID.</li>
              <li><b>Suggest swaps</b> proposes simple same-time-slot swaps to reduce outliers (does not change VP by default).</li>
              <li><b>Exposure targets</b> (optional): leave â€œautoâ€ to let the system equalize; set numbers to force a bias.</li>
              <li><b>VP weight</b> is 0 by default, so VP is ignored in workload scoring unless you change weights.</li>
            </ul>
            <div class="insights-popover-tip">Tip: Use this after manual edits to quickly spot who is overloaded/underused.</div>
          </div>
        </div>
<div class="p-4 text-sm text-slate-700 space-y-2 flex-1 overflow-y-auto overscroll-contain" id="insightsBody">
      <div class="text-slate-500">No insights yet.</div>
    </div>
  </div>
</div>

<script>
  // Wire blueprint file import to rosterSystem (works even if drawer opens later)
  (function(){
    const inp = document.getElementById('blueprintFileInput');
    if(inp){
      inp.addEventListener('change', (e) => {
        const file = e.target.files && e.target.files[0];
        if(!file) return;
        rosterSystem.handleBlueprintFileImport(file);
        e.target.value = '';
      });
    }
  })();


    // Insights â“˜ popover
  (function(){
    const inp = document.getElementById('blueprintFileInput');
    if(inp){
      inp.addEventListener('change', (e) => {
        const file = e.target.files && e.target.files[0];
        if(!file) return;
        rosterSystem.handleBlueprintFileImport(file);
        e.target.value = '';
      });
    }

    // Insights â“˜ help popover
    const infoBtn = document.getElementById('insightsInfoBtn');
    const pop = document.getElementById('insightsInfoPopover');

    function closePop(){
      if(!pop) return;
      pop.classList.add('hidden');
      if(infoBtn) infoBtn.setAttribute('aria-expanded','false');
    }
    function togglePop(){
      if(!pop) return;
      const willOpen = pop.classList.contains('hidden');
      if(willOpen){
        pop.classList.remove('hidden');
        if(infoBtn) infoBtn.setAttribute('aria-expanded','true');
      }else{
        closePop();
      }
    }

    if(infoBtn && pop){
      infoBtn.setAttribute('aria-expanded','false');
      infoBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        togglePop();
      });
      pop.addEventListener('click', (e) => e.stopPropagation());
      document.addEventListener('click', closePop);
      document.addEventListener('keydown', (e) => { if(e.key === 'Escape') closePop(); });

      // Also close when the Insights modal closes
      const origClose = rosterSystem && rosterSystem.closeInsights;
      if(typeof origClose === 'function'){
        rosterSystem.closeInsights = function(){
          closePop();
          return origClose.apply(this, arguments);
        };
      }
    }
  })()

</script>

</body>
</html>