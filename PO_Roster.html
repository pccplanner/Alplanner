<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Staff Command Center v3.8 (Smart Rotation)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- PDF Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.29/jspdf.plugin.autotable.min.js"></script>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, collection, doc, setDoc, getDoc, addDoc, updateDoc, deleteDoc, onSnapshot, query, writeBatch, serverTimestamp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

        const firebaseConfig = {
          apiKey: "AIzaSyAP7b4KcwRYPMZjNc2TWsNqMvC3ywImhOM",
          authDomain: "roster-4a997.firebaseapp.com",
          projectId: "roster-4a997",
          storageBucket: "roster-4a997.firebasestorage.app",
          messagingSenderId: "901381868881",
          appId: "1:901381868881:web:92930481d6c1c85fedd770"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'custom-roster-app';
        
        const COLLECTION_STAFF = 'employees'; 
        const COLLECTION_TEAMS = 'teams';
        const COLLECTION_ROSTERS = 'rosters';

        let currentUser = null;
        let staffList = [];
        let lockedCellsData = {};
        
        const initAuth = async () => {
            try {
                const statusEl = document.getElementById('db-status');
                if(statusEl) statusEl.innerText = 'Connecting...';
                await signInAnonymously(auth);
            } catch (error) {
                console.error("Auth Failed:", error);
                document.getElementById('error-display').innerHTML = `<div class="bg-red-100 text-red-800 p-4 rounded mb-4">Auth Error: ${error.message}</div>`;
            }
        };

        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                const statusEl = document.getElementById('db-status');
                if(statusEl) statusEl.innerHTML = '<span class="flex items-center gap-1 text-green-600 font-bold text-[10px]"><span class="w-1.5 h-1.5 bg-green-500 rounded-full animate-pulse"></span> ONLINE</span>';
                subscribeToData();
                rosterSystem.initializeDate(); 
            }
        });

        function subscribeToData() {
            if (!currentUser) return;
            const staffPath = collection(db, 'artifacts', appId, 'public', 'data', COLLECTION_STAFF);
            const staffQuery = query(staffPath);
            onSnapshot(staffQuery, (snapshot) => {
                staffList = snapshot.docs.map(doc => ({ firebaseId: doc.id, ...doc.data() }));
                staffList.sort((a, b) => (a.staffId || "").localeCompare(b.staffId || ""));
                rosterSystem.staffDataCache = staffList; 
                rosterSystem.renderStaffCards(staffList); 
                rosterSystem.updateStats();
                rosterSystem.updateStaffDatalist();
            }, (error) => console.error("Staff Read Error: " + error.message));

            const settingsDocRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_TEAMS, 'roster_settings');
            onSnapshot(settingsDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    lockedCellsData = data.lockedCells || {};
                    rosterSystem.durations = data.locationDurations || {}; 
                    rosterSystem.breakDuration = data.breakDuration || 60; 
                    rosterSystem.applyPadlocksVisuals();
                    if(rosterSystem.generatedRoster) rosterSystem.validateAllCells(); 
                }
            });
        }

        window.firebaseOperations = {
            addStaff: async (staffData) => {
                if (!currentUser) return alert("Not connected!");
                try {
                    await addDoc(collection(db, 'artifacts', appId, 'public', 'data', COLLECTION_STAFF), staffData);
                    rosterSystem.showToast("Staff added", "success");
                } catch (e) {
                    console.error("Write Failed: " + e.message);
                    rosterSystem.showToast("Failed to save", "error");
                }
            },
            updateStaff: async (firebaseId, data) => {
                if (!currentUser || !firebaseId) return;
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_STAFF, firebaseId);
                await updateDoc(docRef, data);
            },
            deleteStaff: async (firebaseId) => {
                if (!currentUser || !firebaseId) return;
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_STAFF, firebaseId);
                await deleteDoc(docRef);
                rosterSystem.showToast("Staff removed", "success");
            },
            toggleLock: async (key) => {
                if (!currentUser) return;
                const newLocks = { ...lockedCellsData };
                if (newLocks[key]) delete newLocks[key]; else newLocks[key] = true;
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_TEAMS, 'roster_settings');
                await setDoc(docRef, { lockedCells: newLocks }, { merge: true });
            },
            saveSettings: async (settingsData) => {
                 if (!currentUser) return;
                 const docRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_TEAMS, 'roster_settings');
                 await setDoc(docRef, settingsData, { merge: true });
            },
            batchUpdateStaff: async (updates) => {
                if (!currentUser || updates.length === 0) return;
                const batch = writeBatch(db);
                updates.forEach(update => {
                    const docRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_STAFF, update.id);
                    batch.update(docRef, update.data);
                });
                await batch.commit();
            },
            saveRoster: async (dateStr, rosterData) => {
                if (!currentUser || !dateStr) return;
                try {
                    const docRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_ROSTERS, dateStr);
                    await setDoc(docRef, { roster: rosterData, updatedAt: serverTimestamp() }, { merge: true });
                } catch (e) {
                    console.error("Save Error:", e);
                    alert(`Failed to save roster: ${e.message}`);
                }
            },
            subscribeToRoster: (dateStr, callback) => {
                if (!currentUser || !dateStr) return null;
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', COLLECTION_ROSTERS, dateStr);
                return onSnapshot(docRef, (doc) => {
                    if (doc.exists()) {
                        callback(doc.data().roster);
                    } else {
                        callback(null);
                    }
                }, (error) => {
                    console.error("Subscription Error:", error);
                    callback(null);
                });
            },
            getLocks: () => lockedCellsData
        };

        initAuth();
    </script>

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f1f5f9; color: #0f172a; font-size: 14px; }
        .card-panel { background: #ffffff; border: 1px solid #e2e8f0; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); }
        .staff-card { transition: all 0.15s ease; position: relative; background: white; border: 1px solid #cbd5e1; }
        .staff-card:hover { border-color: #6366f1; background-color: #f8fafc; transform: translateY(-1px); z-index: 10; }
        .staff-card.inactive { background-color: #f8fafc; opacity: 0.75; border-style: dashed; border-color: #cbd5e1; }
        .staff-card.inactive .avatar { filter: grayscale(1); opacity: 0.5; }
        
        .styled-table { border-collapse: separate; border-spacing: 0; width: max-content; min-width: 100%; table-layout: auto; }
        .styled-table thead th { background-color: #f8fafc; color: #64748b; font-size: 0.7rem; text-transform: uppercase; border-bottom: 2px solid #e2e8f0; font-weight: 700; padding: 6px 4px; min-width: 85px; width: 85px; position: sticky; top: 0; z-index: 20; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .styled-table td { border-bottom: 1px solid #e2e8f0; padding: 0; vertical-align: top; min-width: 85px; width: 85px; }
        .styled-table tbody tr:hover td { background-color: #f8fafc; }
        .styled-table thead th:first-child, .styled-table tbody td:first-child { position: sticky; left: 0; z-index: 30; background-color: #ffffff; border-right: 2px solid #e2e8f0; min-width: 100px; width: 100px; }
        .styled-table thead th:first-child { z-index: 40; }

        .roster-input { background: transparent; color: #0f172a; border: none; width: 100%; text-align: center; font-size: 0.85rem; height: 32px; font-weight: 700; padding: 0 2px; }
        .roster-input:focus { outline: 2px solid #6366f1; background: #fff; z-index: 5; position: relative; }
        .roster-input:hover { background: #f1f5f9; }
        
        .predefined-cell { background-color: #eff6ff !important; }
        .predefined-cell .roster-input { color: #1d4ed8; font-weight: 800; }
        .predefined-icon { position: absolute; top: 1px; right: 1px; width: 8px; height: 8px; color: #3b82f6; z-index: 4; pointer-events: none; }

        .not-applicable { background-color: #f8fafc; background-image: repeating-linear-gradient(45deg, transparent, transparent 5px, #e2e8f0 5px, #e2e8f0 6px); }
        .conflict-cell { background-color: #fee2e2 !important; box-shadow: inset 0 0 0 1px #ef4444; }
        
        .scroll-container { overflow: auto; -webkit-overflow-scrolling: touch; overscroll-behavior: contain; touch-action: pan-x pan-y; }
        #rosterContainer { overflow-x: auto; overflow-y: auto; position: relative; }
        #rosterContainer table { width: max-content; min-width: 100%; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        .avatar-bg-0 { background-color: #ef4444; } .avatar-bg-1 { background-color: #f97316; } .avatar-bg-2 { background-color: #eab308; } .avatar-bg-3 { background-color: #22c55e; } .avatar-bg-4 { background-color: #06b6d4; } .avatar-bg-5 { background-color: #3b82f6; } .avatar-bg-6 { background-color: #a855f7; } .avatar-bg-7 { background-color: #ec4899; }
        .filter-chip { transition: all 0.2s; } .filter-chip.active { background-color: #e0e7ff; color: #4338ca; border-color: #c7d2fe; }
        .modal { transition: opacity 0.2s ease-in-out; } .modal.hidden { pointer-events: none; opacity: 0; } .modal.flex { pointer-events: auto; opacity: 1; }

        .roster-panel.fullscreen { position: fixed !important; inset: 0; width: 100vw; height: 100dvh; z-index: 9999; margin: 0; border: none; border-radius: 0; background-color: #f8fafc; display: flex; flex-direction: column; }
        .roster-panel.fullscreen .controls-bar { flex-shrink: 0; z-index: 50; }
        .roster-panel.fullscreen .roster-content-wrapper { flex: 1; overflow: hidden; display: flex; flex-direction: column; padding: 0 !important; }
        .roster-panel.fullscreen .roster-inner-card { flex: 1; height: 100%; border-radius: 0; border: none; display: flex; flex-direction: column; }
        .roster-panel.fullscreen #rosterContainer { flex: 1; width: 100%; height: 100%; overflow: scroll; -webkit-overflow-scrolling: touch; padding-bottom: 80px; }
        .roster-panel.fullscreen #rosterActionsContainer { position: fixed; bottom: 20px; right: 20px; z-index: 100; }
    
        @media (orientation: landscape) and (max-height: 520px) {
            #leftPanel { display: none !important; }
            #rosterPanel { width: 100% !important; }
            .roster-content-wrapper { padding: 6px !important; }
            .controls-bar { padding-left: calc(env(safe-area-inset-left) + 8px) !important; padding-right: calc(env(safe-area-inset-right) + 12px) !important; flex-wrap: wrap; }
        }

        .controls-bar { padding-left: max(8px, env(safe-area-inset-left)); padding-right: max(10px, env(safe-area-inset-right)); }
        #rosterContainer { overflow-x: scroll; -webkit-overflow-scrolling: touch; }
        #rosterContainer table { width: max-content !important; min-width: 100% !important; }

        .saved-indicator { font-size: 10px; font-weight: 600; color: #10b981; opacity: 0; transition: opacity 0.5s; }
        .saved-indicator.visible { opacity: 1; }

</style>
</head>
<body class="min-h-screen bg-slate-50 flex flex-col h-screen overflow-hidden">

<nav class="h-12 bg-white border-b border-slate-200 flex items-center shrink-0 z-20 shadow-sm">
    <div class="w-full px-4 flex items-center justify-between">
        <div class="flex items-center gap-2">
            <div class="w-6 h-6 rounded bg-indigo-600 flex items-center justify-center">
                <i data-lucide="shield" class="w-3.5 h-3.5 text-white"></i>
            </div>
            <h1 class="text-sm font-bold text-slate-800 uppercase tracking-wide">Command Center</h1>
            <button onclick="rosterSystem.openSettings()" class="ml-2 text-slate-400 hover:text-indigo-600 transition-colors p-1 rounded hover:bg-slate-100" title="Configuration">
                <i data-lucide="settings" class="w-4 h-4"></i>
            </button>
        </div>
        <div class="hidden md:flex items-center gap-6">
            <div class="flex items-center gap-2 text-xs">
                <span class="text-slate-400 font-medium">POOL</span>
                <span class="font-bold text-slate-700"><span id="stat-present">0</span>/<span id="stat-total">0</span></span>
            </div>
            <div class="flex items-center gap-2 text-xs">
                <span class="text-slate-400 font-medium">HHMD</span>
                <span class="font-bold text-purple-600" id="stat-hhmd">0</span>
            </div>
        </div>
        <div class="flex md:hidden items-center gap-2 text-[10px] font-mono bg-slate-100 px-2 py-0.5 rounded">
            <span class="font-bold text-slate-700" id="stat-present-m">0</span> active
        </div>
    </div>
</nav>

<div id="mainSplit" class="flex-1 flex flex-col md:flex-row overflow-hidden">
    <!-- LEFT PANEL -->
    <div id="leftPanel" class="w-full md:w-[380px] lg:w-[420px] h-[40%] md:h-full bg-white border-b md:border-b-0 md:border-r border-slate-200 flex flex-col shrink-0 z-10 shadow-lg md:shadow-none">
        <div class="p-2 border-b border-slate-100 flex gap-2 items-center bg-slate-50/50 shrink-0">
            <div class="flex-1 flex bg-white border border-slate-200 rounded-md p-0.5" id="filterContainer">
                <button class="filter-chip active flex-1 py-1 text-[10px] font-bold text-slate-600 rounded" data-filter="all">ALL</button>
                <button class="filter-chip flex-1 py-1 text-[10px] font-bold text-slate-400 rounded hover:text-slate-600" data-filter="present">ACTIVE</button>
                <button class="filter-chip flex-1 py-1 text-[10px] font-bold text-slate-400 rounded hover:text-slate-600" data-filter="hhmd">HHMD</button>
            </div>
            <button onclick="rosterSystem.openAddModal()" class="w-8 h-8 rounded bg-indigo-600 text-white flex items-center justify-center hover:bg-indigo-700 shadow-sm"><i data-lucide="plus" class="w-4 h-4"></i></button>
        </div>
        <div class="flex-1 overflow-y-auto p-2 scroll-container">
            <div id="staffGrid" class="grid grid-cols-2 gap-2">
                <div class="col-span-2 text-center py-8 text-xs text-slate-400">Loading...</div>
            </div>
        </div>
        <div class="p-2 border-t border-slate-200 bg-slate-50 flex justify-between items-center text-xs shrink-0">
            <div class="flex gap-2">
                <button onclick="rosterSystem.shuffleBreaks()" class="text-purple-600 hover:text-purple-800 font-semibold flex items-center gap-1 px-2 py-1 rounded hover:bg-purple-50"><i data-lucide="shuffle" class="w-3 h-3"></i> Shuffle</button>
                <button onclick="rosterSystem.clearAssignments()" class="text-red-600 hover:text-red-800 font-semibold flex items-center gap-1 px-2 py-1 rounded hover:bg-red-50"><i data-lucide="eraser" class="w-3 h-3"></i> Clear</button>
            </div>
            <div id="db-status" class="text-[10px] font-mono text-slate-400">Connecting...</div>
        </div>
    </div>

    <!-- RIGHT PANEL (Roster) -->
    <div id="rosterPanel" class="roster-panel flex-1 flex flex-col bg-slate-50 overflow-hidden relative min-h-0">
        <div class="controls-bar min-h-12 border-b border-slate-200 bg-white px-4 py-1 flex items-center justify-between shrink-0 gap-2 overflow-x-auto">
            <div class="flex items-center gap-3 shrink-0">
                <div class="flex items-center gap-1">
                    <i data-lucide="calendar" class="w-3.5 h-3.5 text-slate-400"></i>
                    <input type="date" id="rosterDate" class="text-xs font-semibold bg-transparent border-none focus:ring-0 text-slate-700 p-0 w-24 cursor-pointer">
                </div>
                <select id="rosterDay" class="text-xs font-bold text-slate-700 bg-transparent border-none focus:ring-0 cursor-pointer w-24" disabled><option>Monday</option><option>Tuesday</option><option>Wednesday</option><option>Thursday</option><option>Friday</option><option>Saturday</option><option>Sunday</option></select>
                <div id="loadingIndicator" class="hidden text-slate-400"><i data-lucide="loader-2" class="w-3 h-3 animate-spin"></i></div>
                <span id="saveIndicator" class="saved-indicator flex items-center gap-1"><i data-lucide="cloud-check" class="w-3 h-3"></i> Saved</span>
            </div>
            <div class="flex items-center gap-2 shrink-0">
                <button id="fillGapsBtn" onclick="rosterSystem.fillRosterGaps()" class="bg-blue-600 hover:bg-blue-700 text-white p-1.5 rounded shadow-sm transition-all" title="Fill Empty Slots"><i data-lucide="paint-bucket" class="w-3.5 h-3.5"></i></button>
                <button id="shuffleRosterBtn" onclick="rosterSystem.runRosterGeneration(true)" class="bg-purple-600 hover:bg-purple-700 text-white p-1.5 rounded shadow-sm transition-all" title="Shuffle Roster"><i data-lucide="shuffle" class="w-3.5 h-3.5"></i></button>
                <button id="generateRosterBtn" class="bg-emerald-600 hover:bg-emerald-700 text-white text-xs font-bold py-1.5 px-3 md:px-4 rounded shadow-sm flex items-center gap-2 transition-transform active:scale-95 whitespace-nowrap"><i data-lucide="zap" class="w-3.5 h-3.5"></i> <span class="hidden md:inline">GENERATE</span><span class="md:hidden">GO</span></button>
                <button id="toggleFullscreenBtn" onclick="rosterSystem.toggleFullscreen()" class="bg-slate-800 hover:bg-slate-700 text-white p-1.5 rounded shadow-sm transition-all" title="Full Screen"><i data-lucide="maximize" class="w-3.5 h-3.5"></i></button>
            </div>
        </div>
        
        <div class="roster-content-wrapper flex-1 overflow-hidden relative p-0 md:p-4">
             <div class="roster-inner-card bg-white border border-slate-200 rounded shadow-sm h-full flex flex-col">
                <div id="rosterContainer" class="scroll-container h-full w-full">
                    <div class="flex flex-col items-center justify-center h-40 text-slate-400">
                        <i data-lucide="layout-template" class="w-10 h-10 mb-2 opacity-20"></i>
                        <p class="text-xs">Roster View</p>
                    </div>
                </div>
            </div>
            <div id="rosterActionsContainer" class="hidden absolute bottom-4 right-4 flex gap-2 z-20">
                <button id="copyTSVBtn" class="bg-white border border-slate-300 text-slate-600 hover:text-slate-800 hover:border-slate-400 p-2 rounded-full shadow-lg flex items-center justify-center w-10 h-10 transition-all" title="Copy TSV"><i data-lucide="copy" class="w-4 h-4"></i></button>
                <button id="downloadPDFBtn" type="button" class="bg-rose-600 hover:bg-rose-700 text-white p-2 rounded-full shadow-lg flex items-center justify-center w-10 h-10 transition-all" title="Export PDF"><i data-lucide="file-down" class="w-4 h-4"></i></button>
            </div>
        </div>
    </div>
</div>

<div id="toast-container" class="fixed top-4 right-1/2 translate-x-1/2 z-[1000] flex flex-col gap-2 pointer-events-none w-max max-w-[90vw]"></div>

<!-- Staff Modal -->
<div id="staffModal" class="modal hidden fixed inset-0 z-[1001] bg-black/40 backdrop-blur-[1px] items-center justify-center">
    <div class="bg-white rounded-lg w-full max-w-sm shadow-2xl border border-slate-200 m-4">
        <div class="flex justify-between items-center p-3 border-b border-slate-100 bg-slate-50 rounded-t-lg">
            <h3 class="text-sm font-bold text-slate-800" id="modalTitle">Edit Staff</h3>
            <button onclick="rosterSystem.closeModal()" class="text-slate-400 hover:text-slate-700"><i data-lucide="x" class="w-4 h-4"></i></button>
        </div>
        <div class="p-4 space-y-3">
            <input type="hidden" id="modalFirebaseId">
            <div class="flex gap-3">
                <div class="w-1/3"><label class="text-[10px] font-bold text-slate-400 uppercase">ID</label><input type="text" id="modalStaffId" class="w-full mt-1 bg-slate-50 border border-slate-300 rounded px-2 py-1 text-xs font-mono focus:border-indigo-500 focus:outline-none"></div>
                <div class="w-2/3"><label class="text-[10px] font-bold text-slate-400 uppercase">Name</label><input type="text" id="modalName" class="w-full mt-1 bg-slate-50 border border-slate-300 rounded px-2 py-1 text-xs focus:border-indigo-500 focus:outline-none"></div>
            </div>
            <div class="bg-slate-50 p-3 rounded border border-slate-100">
                <label class="text-[10px] font-bold text-indigo-600 uppercase mb-1 block">Break Time</label>
                <div class="flex items-center gap-2">
                    <input type="time" id="modalBreakStart" class="bg-white border border-slate-300 rounded px-2 py-1 text-xs w-full text-center"><span class="text-slate-300 text-[10px]">&rarr;</span><input type="time" id="modalBreakEnd" class="bg-white border border-slate-300 rounded px-2 py-1 text-xs w-full text-center">
                </div>
            </div>
            <div class="grid grid-cols-2 gap-3">
                <div class="bg-slate-50 p-3 rounded border border-slate-100"><label class="text-[10px] font-bold text-slate-500 uppercase mb-1 block">First Hour (20:00)</label><select id="modalStartLoc" class="w-full bg-white border border-slate-300 rounded px-2 py-1 text-xs font-medium text-slate-700 focus:border-indigo-500 focus:outline-none"><option value="">Any</option></select></div>
                <div class="bg-slate-50 p-3 rounded border border-slate-100"><label class="text-[10px] font-bold text-blue-600 uppercase mb-1 block">Vertical Patrol</label><select id="modalVPSlot" class="w-full bg-white border border-slate-300 rounded px-2 py-1 text-xs font-medium text-slate-700 focus:border-indigo-500 focus:outline-none"><option value="">None</option></select></div>
            </div>
            <div class="flex items-center justify-between pt-1"><label class="flex items-center gap-2 cursor-pointer select-none"><input type="checkbox" id="modalHHMD" class="w-4 h-4 text-purple-600 border-slate-300 rounded focus:ring-purple-500"><span class="text-xs font-semibold text-slate-700">HHMD Qualified</span></label></div>
            <div class="flex gap-2 pt-3 border-t border-slate-100 mt-2"><button id="modalDeleteBtn" onclick="rosterSystem.deleteCurrentStaff()" class="hidden px-3 py-1.5 text-xs font-bold text-red-600 bg-red-50 hover:bg-red-100 rounded">Remove</button><div class="flex-1"></div><button onclick="rosterSystem.saveStaffFromModal()" class="px-6 py-1.5 text-xs font-bold text-white bg-indigo-600 hover:bg-indigo-700 rounded shadow-sm">Save</button></div>
        </div>
    </div>
</div>

<div id="settingsModal" class="modal hidden fixed inset-0 z-[1001] bg-black/40 backdrop-blur-[1px] items-center justify-center">
    <div class="bg-white rounded-lg w-full max-w-sm shadow-2xl border border-slate-200 m-4 flex flex-col max-h-[80vh]">
        <div class="flex justify-between items-center p-3 border-b border-slate-100 bg-slate-50 rounded-t-lg shrink-0"><h3 class="text-sm font-bold text-slate-800 flex items-center gap-2"><i data-lucide="settings" class="w-4 h-4"></i> Configuration</h3><button onclick="rosterSystem.closeSettings()" class="text-slate-400 hover:text-slate-700"><i data-lucide="x" class="w-4 h-4"></i></button></div>
        <div class="p-4 overflow-y-auto flex-1">
            <div class="mb-5 pb-5 border-b border-slate-100"><h4 class="text-xs font-bold text-slate-500 uppercase mb-3">Global Settings</h4><div class="flex items-center justify-between bg-slate-50 p-3 rounded border border-slate-200"><div class="flex flex-col"><span class="text-xs font-bold text-slate-700">Standard Break Duration</span><span class="text-[9px] text-slate-400">Updates all staff break end times</span></div><div class="flex items-center gap-1"><input type="number" id="settingBreakDuration" class="w-16 text-center text-xs border border-slate-300 rounded px-1 py-1 font-mono" min="0" step="15" value="60"><span class="text-[10px] text-slate-400 font-bold">mins</span></div></div></div>
            <h4 class="text-xs font-bold text-slate-500 uppercase mb-3">Duty Durations</h4><p class="text-[10px] text-slate-400 mb-3 italic">Set the credit (in minutes) a staff member receives for one slot at each location.</p><div id="settingsList" class="space-y-3"></div>
        </div>
        <div class="p-3 border-t border-slate-100 bg-slate-50 rounded-b-lg shrink-0 flex justify-end"><button onclick="rosterSystem.saveSettings()" class="px-6 py-1.5 text-xs font-bold text-white bg-indigo-600 hover:bg-indigo-700 rounded shadow-sm">Save Configuration</button></div>
    </div>
</div>

<div id="pdfModal" class="modal hidden fixed inset-0 z-50 bg-black/50 backdrop-blur-sm items-center justify-center p-4">
    <div class="bg-white rounded w-full max-w-5xl h-[85vh] flex flex-col shadow-2xl">
        <div class="flex justify-between items-center p-3 border-b bg-slate-50 rounded-t"><h3 class="text-sm font-bold text-slate-700">PDF Preview</h3><div class="flex gap-2"><a id="pdfDownloadLink" href="#" download="roster.pdf" class="bg-slate-800 text-white px-3 py-1 rounded text-xs font-bold hover:bg-black">Download</a><button onclick="rosterSystem.closePdfModal()" class="text-slate-400 hover:text-slate-800"><i data-lucide="x" class="w-5 h-5"></i></button></div></div>
        <iframe id="pdfPreview" class="flex-1 w-full bg-slate-200"></iframe>
    </div>
</div>

<datalist id="staff-id-list"></datalist>

<script>
const rosterSystem = {
    ROSTER_TIMES: ["20:00", "21:00", "22:00", "23:00", "00:00", "01:00", "02:00", "03:00", "04:00", "05:00", "06:00", "07:00"],
    LOCATIONS: [ { name: "Pass Counter", needed: 2 }, { name: "KIOSK", needed: 1 }, { name: "Lobby", needed: 1 }, { name: "HHMD", needed: 1 }, { name: "Guard House", needed: 1 }, { name: "Report Room", needed: 1 }, { name: "Vertical Patrol", needed: 1 }, { name: "Tango Papa", needed: 1 } ],
    OUTPUT_ORDER: ["Pass Counter", "KIOSK", "Lobby", "HHMD", "Guard House", "Report Room", "Vertical Patrol", "Tango Papa"],
    CRITICAL_DUTIES: { "Vertical Patrol": ["20:00", "23:00", "01:00", "04:00", "06:00"], "Report Room": ["20:00", "21:00"], "Tango Papa": ["07:00"] },
    VP_CYCLES: { "VP-2030": { time: "20:00", label: "20:30" }, "VP-2300": { time: "23:00", label: "23:00" }, "VP-0130": { time: "01:00", label: "01:30" }, "VP-0400": { time: "04:00", label: "04:00" }, "VP-0630": { time: "06:00", label: "06:30" } },
    STANDING_LOCATIONS: ["Lobby", "KIOSK"], // Smart Fatigue Logic
    
    generatedRoster: null, staffDataCache: [], currentFilter: 'all', isFullscreen: false,
    durations: {}, breakDuration: 60, currentDateStr: "", rosterUnsubscribe: null,

    init() { 
        lucide.createIcons();
        this.bindModalBreakAutoCalc(); 
        this.setupUI(); 
    },

    setupUI() {
        document.getElementById("generateRosterBtn").addEventListener("click", () => this.runRosterGeneration());
        document.getElementById("copyTSVBtn").addEventListener("click", () => this.copyTSV());
        // Robust PDF download handler (works even if UI re-renders on mobile)
        document.addEventListener("click", (ev) => {
            const btn = ev.target.closest && ev.target.closest("#downloadPDFBtn");
            if (!btn) return;
            ev.preventDefault();
            ev.stopPropagation();
            this.downloadPDF();
        }, { passive: false });
        document.getElementById("modalStartLoc").addEventListener("change", (e) => this.handleStartLocChange(e));
        const dateInput = document.getElementById("rosterDate");
        dateInput.addEventListener("change", (e) => { this.handleDateChange(e.target.value); });
        document.getElementById("modalBreakStart").addEventListener("change", (e) => {
            const start = e.target.value; if(start) document.getElementById("modalBreakEnd").value = this.calculateEndTime(start, this.breakDuration);
        });
        document.querySelectorAll('.filter-chip').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.filter-chip').forEach(b => { b.classList.remove('active', 'bg-indigo-50', 'text-indigo-700'); b.classList.add('text-slate-400'); });
                e.target.classList.remove('text-slate-400'); e.target.classList.add('active');
                this.currentFilter = e.target.dataset.filter; this.renderStaffCards(this.staffDataCache);
            });
        });
    },

    initializeDate() { 
        const today = new Date(); const year = today.getFullYear(); const month = String(today.getMonth() + 1).padStart(2, '0'); const day = String(today.getDate()).padStart(2, '0'); const dateStr = `${year}-${month}-${day}`;
        document.getElementById("rosterDate").value = dateStr; this.handleDateChange(dateStr);
    },

    async handleDateChange(dateStr) {
        this.currentDateStr = dateStr; if (!dateStr) return;
        const parts = dateStr.split('-'); const dateObj = new Date(parts[0], parts[1] - 1, parts[2]); const dayName = dateObj.toLocaleDateString('en-US', { weekday: 'long' });
        document.getElementById("rosterDay").value = dayName;
        if (this.rosterUnsubscribe) { this.rosterUnsubscribe(); this.rosterUnsubscribe = null; }
        document.getElementById('loadingIndicator').classList.remove('hidden');
        document.getElementById("rosterContainer").innerHTML = `<div class="flex flex-col items-center justify-center h-40 text-slate-400"><i data-lucide="loader-2" class="w-8 h-8 mb-2 animate-spin"></i><p class="text-xs">Loading Roster...</p></div>`;
        this.rosterUnsubscribe = window.firebaseOperations.subscribeToRoster(dateStr, (rosterData) => {
             document.getElementById('loadingIndicator').classList.add('hidden');
             if (rosterData) { this.generatedRoster = rosterData; this.displayRoster(rosterData); document.getElementById('rosterActionsContainer').classList.remove('hidden'); } 
             else { this.generatedRoster = null; document.getElementById("rosterContainer").innerHTML = `<div class="flex flex-col items-center justify-center h-40 text-slate-400"><i data-lucide="calendar" class="w-10 h-10 mb-2 opacity-20"></i><p class="text-xs">No roster for ${dateStr}</p><p class="text-[10px] mt-1">Click GENERATE to create one</p></div>`; document.getElementById('rosterActionsContainer').classList.add('hidden'); lucide.createIcons(); }
        });
    },
    
    toggleFullscreen() {
        this.isFullscreen = !this.isFullscreen; const panel = document.getElementById("rosterPanel");
        if (this.isFullscreen) { panel.classList.add("fullscreen"); document.querySelector('#toggleFullscreenBtn i').setAttribute('data-lucide', 'minimize'); } else { panel.classList.remove("fullscreen"); document.querySelector('#toggleFullscreenBtn i').setAttribute('data-lucide', 'maximize'); } lucide.createIcons();
    },

    calculateEndTime(startTimeStr, durationMins) {
        if (!startTimeStr) return ""; const [h, m] = startTimeStr.split(':').map(Number); let totalMins = h * 60 + m + parseInt(durationMins); let newH = Math.floor(totalMins / 60) % 24; let newM = totalMins % 60; return `${String(newH).padStart(2, '0')}:${String(newM).padStart(2, '0')}`;
    },

    // Apply global break duration change to all staff cards (updates break END times)
    async applyGlobalBreakDurationToStaff(durationMins) {
        try {
            const staffList = Array.isArray(this.staffDataCache) ? this.staffDataCache : [];
            const updates = [];
            staffList.forEach(staff => {
                const start = staff.breakStart;
                if (!start) return;
                const newEnd = this.calculateEndTime(start, durationMins);
                if (newEnd && staff.breakEnd !== newEnd) {
                    staff.breakEnd = newEnd; // update local cache immediately
                    if (staff.firebaseId) {
                        updates.push(window.firebaseOperations.updateStaff(staff.firebaseId, { breakEnd: newEnd }));
                    }
                }
            });
            if (updates.length) await Promise.all(updates);
            // Re-render cards + break table so UI reflects the new time-out
            this.renderStaffCards(this.staffDataCache);
            this.syncOpenEditModalBreakFields();
            if (typeof this.renderBreakTable === 'function') this.renderBreakTable();
        } catch (e) {
            console.error("applyGlobalBreakDurationToStaff failed:", e);
            this.showToast("Failed to apply break duration", "error");
        }
    },


    renderOptions(currentStaffId) {
        const startSelect = document.getElementById("modalStartLoc"); const vpSelect = document.getElementById("modalVPSlot");
        startSelect.innerHTML = '<option value="">Any</option>'; vpSelect.innerHTML = '<option value="">None</option>';
        const usage = { start: {}, vp: {} };
        this.staffDataCache.forEach(s => { if (s.attendance === 'Yes' && s.firebaseId !== currentStaffId) { if (s.startLoc) usage.start[s.startLoc] = (usage.start[s.startLoc] || 0) + 1; if (s.vpSlot) usage.vp[s.vpSlot] = (usage.vp[s.vpSlot] || 0) + 1; } });
        this.LOCATIONS.forEach(loc => { if (loc.name !== "Vertical Patrol") { const count = usage.start[loc.name] || 0; const isFull = count >= loc.needed; const option = document.createElement("option"); option.value = loc.name; option.text = `${loc.name} ${isFull ? '(Full)' : `(${count}/${loc.needed})`}`; if (isFull) { option.disabled = true; option.classList.add('text-slate-400', 'italic'); } startSelect.appendChild(option); } });
        for (const [key, config] of Object.entries(this.VP_CYCLES)) { const count = usage.vp[key] || 0; const isFull = count >= 1; const option = document.createElement("option"); option.value = key; option.text = `${config.label} ${isFull ? '(Taken)' : ''}`; if (isFull) { option.disabled = true; option.classList.add('text-slate-400', 'italic'); } vpSelect.appendChild(option); }
    },

    handleStartLocChange(e) {
        const vpSelect = document.getElementById("modalVPSlot"); Array.from(vpSelect.options).forEach(opt => opt.disabled = opt.text.includes('(Taken)')); 
        if (e.target.value !== "") { const vp2030Opt = Array.from(vpSelect.options).find(o => o.value === "VP-2030"); if (vp2030Opt) vp2030Opt.disabled = true; if (vpSelect.value === "VP-2030") vpSelect.value = ""; }
    },

    renderStaffCards(staffList) {
        const grid = document.getElementById('staffGrid'); grid.innerHTML = ''; let filteredList = staffList;
        if (this.currentFilter === 'present') filteredList = staffList.filter(s => s.attendance === 'Yes'); if (this.currentFilter === 'hhmd') filteredList = staffList.filter(s => s.hhmd === 'Yes');
        if (filteredList.length === 0) { grid.innerHTML = `<div class="col-span-2 text-center py-6 text-xs text-slate-400 italic">No staff found.</div>`; return; }
        filteredList.forEach(staff => {
            const isPresent = staff.attendance === 'Yes';
            const initials = staff.name.split(' ').map(n => n[0]).join('').slice(0, 2).toUpperCase();
            const colorIndex = (staff.staffId.charCodeAt(staff.staffId.length - 1) || 0) % 8;

            let indicators = "";
            if (staff.startLoc) indicators += `<div class="w-2 h-2 bg-indigo-500 rounded-full shadow-sm ring-1 ring-white"></div>`;
            if (staff.vpSlot) indicators += `<div class="w-2 h-2 bg-blue-500 rounded-full shadow-sm ring-1 ring-white"></div>`;
            if (indicators) indicators = `<div class="absolute -top-1 -right-1 flex gap-0.5">${indicators}</div>`;

            // Quick VP assignment options (advance assignment from Command Center)
            const vpOptionsHTML = [
                `<option value="">VP: None</option>`,
                ...Object.entries(this.VP_CYCLES).map(([key, cfg]) => {
                    const isTakenByOther = this.staffDataCache.some(s => s.vpSlot === key && s.firebaseId !== staff.firebaseId);
                    const selected = (staff.vpSlot === key) ? 'selected' : '';
                    const disabled = isTakenByOther ? 'disabled' : '';
                    const takenTxt = isTakenByOther ? ' (Taken)' : '';
                    return `<option value="${key}" ${selected} ${disabled}>VP ${cfg.label}${takenTxt}</option>`;
                })
            ].join('');

            const card = document.createElement('div');
            card.className = `staff-card h-16 rounded flex items-center pr-2 pl-2 gap-3 ${!isPresent ? 'inactive' : ''}`;

            card.innerHTML =
`<button onclick="rosterSystem.toggleAttendance('${staff.firebaseId}', '${staff.attendance}')" class="w-8 h-8 rounded-full flex items-center justify-center transition-all shrink-0 ${isPresent ? 'bg-green-100 text-green-600 hover:bg-green-200' : 'bg-slate-100 text-slate-300 hover:bg-slate-200'}"><i data-lucide="power" class="w-4 h-4"></i></button>
<div class="relative w-10 h-10 rounded shrink-0 avatar-bg-${colorIndex} flex items-center justify-center text-white font-bold text-xs cursor-pointer avatar shadow-sm" onclick="rosterSystem.openEditModal('${staff.firebaseId}')">${initials}${indicators}</div>
<div class="flex flex-col min-w-0 flex-1 cursor-pointer justify-center" onclick="rosterSystem.openEditModal('${staff.firebaseId}')">
  <div class="flex items-center gap-1.5 mb-0.5">
    <span class="text-sm font-bold text-slate-800 truncate leading-tight">${staff.name}</span>
    ${staff.hhmd === 'Yes' ? `<div class="w-2 h-2 rounded-full bg-purple-500 ring-2 ring-white" title="HHMD Qualified"></div>` : ''}
  </div>
  <div class="flex items-center justify-between text-xs w-full">
    <span class="font-mono font-bold text-slate-600 bg-slate-100 px-1 rounded">${staff.staffId}</span>
    <div class="flex items-center gap-1.5">
      <div class="flex items-center gap-1 text-slate-500 font-semibold bg-slate-50 px-1.5 py-0.5 rounded border border-slate-100">
        <i data-lucide="clock" class="w-3 h-3 text-slate-400"></i>
        <span>${staff.breakStart}-${staff.breakEnd}</span>
      </div>
      <select class="vp-quick text-[10px] font-bold bg-white border border-slate-200 rounded px-1 py-0.5 text-slate-700 max-w-[92px]" data-fbid="${staff.firebaseId}" title="Advance Vertical Patrol assignment">
        ${vpOptionsHTML}
      </select>
    </div>
  </div>
</div>`;
            grid.appendChild(card);
        });

// Bind quick VP assignment events (prevent modal open when interacting with select)
grid.querySelectorAll('.vp-quick').forEach(sel => {
            sel.addEventListener('click', (e) => e.stopPropagation());
            sel.addEventListener('mousedown', (e) => e.stopPropagation());
            sel.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
            sel.addEventListener('change', (e) => {
                e.stopPropagation();
                rosterSystem.setVPSlotQuick(e.target.dataset.fbid, e.target.value);
            });
        });
        lucide.createIcons();
    },
    
    // Quick advance assignment for Vertical Patrol (Command Center card level)
    async setVPSlotQuick(firebaseId, newSlot) {
        const staff = this.staffDataCache.find(s => s.firebaseId === firebaseId);
        if (!staff) return;

        // No change
        if ((staff.vpSlot || "") === (newSlot || "")) return;

        // If assigning a VP slot that is already taken by someone else, offer to swap
        if (newSlot) {
            const other = this.staffDataCache.find(s => s.vpSlot === newSlot && s.firebaseId !== firebaseId);
            if (other) {
                const label = this.VP_CYCLES?.[newSlot]?.label || newSlot;
                const ok = confirm(`VP ${label} is already assigned to ${other.name} (${other.staffId}).\n\nSwap it to ${staff.name} (${staff.staffId})?`);
                if (!ok) {
                    // Re-render to revert the dropdown selection
                    this.renderStaffCards(this.staffDataCache);
                    return;
                }
                // Optimistic update
                other.vpSlot = "";
                await window.firebaseOperations.updateStaff(other.firebaseId, { vpSlot: "" });
            }
        }

        // Optimistic update for immediate UI
        staff.vpSlot = newSlot || "";
        await window.firebaseOperations.updateStaff(firebaseId, { vpSlot: newSlot || "" });

        this.showToast("Vertical Patrol updated", "success");
        this.renderStaffCards(this.staffDataCache);
        // If roster already generated, re-validate / reflect predefined VP assignments
        if (this.generatedRoster) this.validateAllCells();
    },

    updateStats() {
        const total = this.staffDataCache.length; const present = this.staffDataCache.filter(s => s.attendance === 'Yes').length; const hhmd = this.staffDataCache.filter(s => s.hhmd === 'Yes' && s.attendance === 'Yes').length;
        document.getElementById('stat-total').textContent = total; document.getElementById('stat-present').textContent = present; document.getElementById('stat-hhmd').textContent = hhmd; document.getElementById('stat-present-m').textContent = present;
    },
    updateStaffDatalist() {
        const datalist = document.getElementById('staff-id-list'); if (!datalist) return; const presentStaff = this.staffDataCache.filter(s => s.attendance === 'Yes'); datalist.innerHTML = presentStaff.map(s => `<option value="${s.staffId}"></option>`).join('');
    },
// ---- Break time utilities (used by cards + edit modal + break table) ----
timeToMinutesHHMM(t) {
    if (!t || typeof t !== 'string' || !t.includes(':')) return NaN;
    const [h, m] = t.split(':').map(n => parseInt(n, 10));
    if (Number.isNaN(h) || Number.isNaN(m)) return NaN;
    return (h * 60) + m;
},
minutesToHHMM(totalMin) {
    let m = totalMin % (24 * 60);
    if (m < 0) m += 24 * 60;
    const hh = String(Math.floor(m / 60)).padStart(2, '0');
    const mm = String(m % 60).padStart(2, '0');
    return `${hh}:${mm}`;
},
addMinutesToHHMM(startHHMM, addMins) {
    const base = this.timeToMinutesHHMM(startHHMM);
    if (Number.isNaN(base)) return "00:00";
    return this.minutesToHHMM(base + (parseInt(addMins, 10) || 0));
},
computeBreakEndFromStart(startHHMM) {
    return this.addMinutesToHHMM(startHHMM, this.breakDuration || 60);
},
syncOpenEditModalBreakFields() {
    const modal = document.getElementById('staffModal');
    if (!modal || modal.classList.contains('hidden')) return;
    const fbId = document.getElementById('modalFirebaseId')?.value;
    if (!fbId) return;
    const staff = this.staffDataCache.find(s => s.firebaseId === fbId);
    if (!staff) return;

    const startEl = document.getElementById('modalBreakStart');
    const endEl = document.getElementById('modalBreakEnd');
    if (!startEl || !endEl) return;

    // Keep the user's selected start time, but always sync end time from latest staff record.
    startEl.value = staff.breakStart || startEl.value || "22:00";
    endEl.value = staff.breakEnd || this.computeBreakEndFromStart(startEl.value);
},
bindModalBreakAutoCalc() {
    const startEl = document.getElementById('modalBreakStart');
    const endEl = document.getElementById('modalBreakEnd');
    if (!startEl || !endEl) return;

    // Whenever break START changes in the edit modal, auto recompute END using global break duration.
    startEl.addEventListener('change', () => {
        endEl.value = this.computeBreakEndFromStart(startEl.value);
    });
    startEl.addEventListener('input', () => {
        // lightweight live update (helps iOS picker)
        endEl.value = this.computeBreakEndFromStart(startEl.value);
    });
},

    toggleAttendance(id, currentStatus) { window.firebaseOperations.updateStaff(id, { attendance: currentStatus === 'Yes' ? 'No' : 'Yes' }); },
    openAddModal() {
        document.getElementById('modalTitle').innerText = "Add Staff"; document.getElementById('modalFirebaseId').value = ""; document.getElementById('modalStaffId').value = `S${Math.floor(Math.random()*9000)+1000}`; document.getElementById('modalName').value = ""; document.getElementById('modalBreakStart').value = "22:00"; document.getElementById('modalBreakEnd').value = this.computeBreakEndFromStart("22:00"); this.renderOptions(null); document.getElementById('modalStartLoc').value = ""; document.getElementById('modalVPSlot').value = ""; document.getElementById('modalHHMD').checked = false; document.getElementById('modalDeleteBtn').classList.add('hidden'); document.getElementById('staffModal').classList.remove('hidden'); document.getElementById('staffModal').classList.add('flex');
    },
    openEditModal(id) {
        const staff = this.staffDataCache.find(s => s.firebaseId === id); if(!staff) return;
        document.getElementById('modalTitle').innerText = "Edit Staff"; document.getElementById('modalFirebaseId').value = staff.firebaseId; document.getElementById('modalStaffId').value = staff.staffId; document.getElementById('modalName').value = staff.name; document.getElementById('modalBreakStart').value = staff.breakStart || "22:00"; const __bs = document.getElementById('modalBreakStart').value; const __beRaw = (staff.breakEnd || "").trim(); const __be = (!__beRaw || (__beRaw === "00:00" && __bs !== "00:00")) ? this.computeBreakEndFromStart(__bs) : __beRaw; document.getElementById('modalBreakEnd').value = __be; this.renderOptions(staff.firebaseId); document.getElementById('modalStartLoc').value = staff.startLoc || ""; document.getElementById('modalVPSlot').value = staff.vpSlot || ""; document.getElementById('modalHHMD').checked = staff.hhmd === 'Yes'; document.getElementById('modalDeleteBtn').classList.remove('hidden'); document.getElementById('staffModal').classList.remove('hidden'); document.getElementById('staffModal').classList.add('flex');
        this.handleStartLocChange({target: {value: staff.startLoc || ""}});
    },
    closeModal() { document.getElementById('staffModal').classList.add('hidden'); document.getElementById('staffModal').classList.remove('flex'); },
    async saveStaffFromModal() {
        const id = document.getElementById('modalFirebaseId').value; const data = { staffId: document.getElementById('modalStaffId').value, name: document.getElementById('modalName').value || "Unknown", breakStart: document.getElementById('modalBreakStart').value, breakEnd: document.getElementById('modalBreakEnd').value, hhmd: document.getElementById('modalHHMD').checked ? 'Yes' : 'No', startLoc: document.getElementById('modalStartLoc').value, vpSlot: document.getElementById('modalVPSlot').value, attendance: 'Yes' };
        if (!data.breakEnd) data.breakEnd = this.computeBreakEndFromStart(data.breakStart);
        if (id) { delete data.attendance; await window.firebaseOperations.updateStaff(id, data); this.showToast("Saved", "success"); } else { await window.firebaseOperations.addStaff(data); } this.closeModal();
    },
    deleteCurrentStaff() { const id = document.getElementById('modalFirebaseId').value; if(confirm("Remove?")) { window.firebaseOperations.deleteStaff(id); this.closeModal(); } },
    
    openSettings() {
        document.getElementById('settingBreakDuration').value = this.breakDuration; const list = document.getElementById('settingsList');
        list.innerHTML = this.OUTPUT_ORDER.map(locName => { const currentDur = this.durations[locName] || (locName === 'Vertical Patrol' ? 90 : 60); return `<div class="flex items-center justify-between bg-slate-50 p-2 rounded border border-slate-200"><span class="text-xs font-bold text-slate-700">${locName}</span><div class="flex items-center gap-1"><input type="number" id="dur-${locName.replace(/\s+/g, '-')}" value="${currentDur}" class="w-16 text-center text-xs border border-slate-300 rounded px-1 py-1 font-mono" min="0" step="15"><span class="text-[10px] text-slate-400 font-bold">mins</span></div></div>`; }).join('');
        document.getElementById('settingsModal').classList.remove('hidden'); document.getElementById('settingsModal').classList.add('flex');
    },
    closeSettings() { document.getElementById('settingsModal').classList.add('hidden'); document.getElementById('settingsModal').classList.remove('flex'); },
    async saveSettings() {
        const newBreakDur = parseInt(document.getElementById('settingBreakDuration').value) || 60;
        const newDurations = {};
        this.OUTPUT_ORDER.forEach(locName => {
            const val = document.getElementById(`dur-${locName.replace(/\s+/g, '-')}`).value;
            newDurations[locName] = parseInt(val) || 60;
        });

        // 1) Save settings (durations + global break duration)
        await window.firebaseOperations.saveSettings({ locationDurations: newDurations, breakDuration: newBreakDur });
        this.durations = newDurations;
        this.breakDuration = newBreakDur;

        // 2) IMPORTANT: Apply the new global break duration to staff break END times
        //    so the Staff Command Center cards reflect the updated "time out".
        await this.applyGlobalBreakDurationToStaff(newBreakDur);
        this.syncOpenEditModalBreakFields();

        this.showToast("Saved", "success");
        this.closeSettings();
        if (this.generatedRoster) this.validateAllCells();
    },

    shuffleBreaks() {
        const present = this.staffDataCache.filter(s => s.attendance === 'Yes'); if (present.length < 2) return this.showToast("Need more staff", "warning");
        let times = present.map(s => ({ s: s.breakStart, e: s.breakEnd })); for (let i = times.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [times[i], times[j]] = [times[j], times[i]]; }
        present.forEach((staff, idx) => { window.firebaseOperations.updateStaff(staff.firebaseId, { breakStart: times[idx].s, breakEnd: times[idx].e }); }); this.showToast("Breaks shuffled", "success");
    },
    clearAssignments() {
        if(!confirm("Clear manual assignments? (HHMD preserved)")) return;
        this.staffDataCache.forEach(staff => { const updates = {}; let changed = false; if (staff.startLoc && staff.startLoc !== 'HHMD') { updates.startLoc = ""; changed = true; } if (staff.vpSlot) { updates.vpSlot = ""; changed = true; } if (changed) window.firebaseOperations.updateStaff(staff.firebaseId, updates); });
        this.showToast("Cleared (HHMD kept)", "success");
    },

    // --- FILL GAPS ---
    fillRosterGaps() {
        if (!this.generatedRoster) return this.showToast("No roster to fill", "warning");
        const presentStaff = this.staffDataCache.filter(s => s.attendance === 'Yes');
        const roster = JSON.parse(JSON.stringify(this.generatedRoster)); 
        
        const assignmentsByStaff = Object.fromEntries(presentStaff.map(s => [s.staffId, []]));
        const staffMap = Object.fromEntries(presentStaff.map(s => [s.staffId, s]));
        const verticalPatrolTracker = new Set();
        
        this.OUTPUT_ORDER.forEach(locName => {
            this.ROSTER_TIMES.forEach(time => {
                const slots = roster[locName]?.[time] || [];
                slots.forEach(sId => {
                    if (sId && staffMap[sId]) {
                        if (!assignmentsByStaff[sId]) assignmentsByStaff[sId] = [];
                        assignmentsByStaff[sId].push(time);
                        if (locName === 'Vertical Patrol' || locName === 'Tango Papa') verticalPatrolTracker.add(sId);
                    }
                });
            });
        });

        let filledCount = 0;
        this.ROSTER_TIMES.forEach(time => {
            this.OUTPUT_ORDER.forEach(locName => {
                if (this.CRITICAL_DUTIES[locName] && !this.CRITICAL_DUTIES[locName].includes(time)) return;
                const isWeekend = ['Saturday', 'Sunday'].includes(document.getElementById('rosterDay').value);
                if (locName === "Report Room" && isWeekend) return;
                
                const locConfig = this.LOCATIONS.find(l => l.name === locName);
                if (!roster[locName][time]) roster[locName][time] = new Array(locConfig.needed).fill('');

                for (let i = 0; i < locConfig.needed; i++) {
                    if (roster[locName][time][i] === '') {
                         const staffPool = presentStaff.map(s => s.staffId).sort(() => Math.random() - 0.5);
                         for (const sId of staffPool) {
                             if (this.canAssign(sId, time, locName, assignmentsByStaff, staffMap, verticalPatrolTracker, roster)) {
                                 roster[locName][time][i] = sId;
                                 assignmentsByStaff[sId].push(time);
                                 if (locName === 'Vertical Patrol' || locName === 'Tango Papa') verticalPatrolTracker.add(sId);
                                 filledCount++;
                                 break;
                             }
                         }
                    }
                }
            });
        });

        this.generatedRoster = roster;
        this.displayRoster(roster);
        window.firebaseOperations.saveRoster(this.currentDateStr, roster);
        this.showToast(`Filled ${filledCount} gaps`, "success");
    },

    runRosterGeneration(isShuffle = false) {
        if (this.generatedRoster && !isShuffle) { if(!confirm("Overwrite existing roster for this date?")) return; }

        const presentStaff = this.staffDataCache.filter(s => s.attendance === 'Yes');
        if (presentStaff.length === 0) return this.showToast("No active staff!", 'error');
        const locks = window.firebaseOperations.getLocks(); const lockedValues = this.preserveLockedValues();
        const roster = Object.fromEntries(this.LOCATIONS.map(loc => [loc.name, Object.fromEntries(this.ROSTER_TIMES.map(t => [t, new Array(loc.needed).fill('')]))]));
        const assignmentsByStaff = Object.fromEntries(presentStaff.map(s => [s.staffId, []]));
        const staffMap = Object.fromEntries(presentStaff.map(s => [s.staffId, s]));
        const shortfalls = [];
        const isWeekend = ['Saturday', 'Sunday'].includes(document.getElementById('rosterDay').value);
        const verticalPatrolTracker = new Set();
        
        const specificAssignments = {}; 
        presentStaff.forEach(staff => {
            if (staff.startLoc) {
                if (!specificAssignments["20:00"]) specificAssignments["20:00"] = {}; if (!specificAssignments["20:00"][staff.startLoc]) specificAssignments["20:00"][staff.startLoc] = []; specificAssignments["20:00"][staff.startLoc].push(staff.staffId);
            }
            if (staff.vpSlot && this.VP_CYCLES[staff.vpSlot]) {
                const time = this.VP_CYCLES[staff.vpSlot].time; if (!specificAssignments[time]) specificAssignments[time] = {}; if (!specificAssignments[time]["Vertical Patrol"]) specificAssignments[time]["Vertical Patrol"] = []; specificAssignments[time]["Vertical Patrol"].push(staff.staffId);
            }
        });

        const attemptAssignment = (time, locName, positionIndex, forceStaffId = null) => {
            const lockKey = `${locName}-${time}`; let lockedId = lockedValues[lockKey] || (locks[lockKey] ? this.getStaffIdByLock(lockKey) : null);
            if (lockedId) { roster[locName][time][positionIndex] = lockedId; if (assignmentsByStaff[lockedId]) { assignmentsByStaff[lockedId].push(time); if (locName === 'Vertical Patrol' || locName === 'Tango Papa') verticalPatrolTracker.add(lockedId); } return true; }
            if (roster[locName][time][positionIndex] !== '') return true;

            if (forceStaffId) {
                const staff = staffMap[forceStaffId]; const isOverlapping = assignmentsByStaff[forceStaffId].includes(time); const isBreak = this.isOnBreak(staff, time); const isHHMD = (locName === 'HHMD' && staff.hhmd !== 'Yes');
                if (!isOverlapping && !isBreak && !isHHMD) { roster[locName][time][positionIndex] = forceStaffId; assignmentsByStaff[forceStaffId].push(time); if (locName === 'Vertical Patrol' || locName === 'Tango Papa') verticalPatrolTracker.add(forceStaffId); return true; } return false;
            }
            return false;
        };

        this.ROSTER_TIMES.forEach(time => {
            this.OUTPUT_ORDER.forEach(locName => {
                if (this.CRITICAL_DUTIES[locName] && !this.CRITICAL_DUTIES[locName].includes(time)) return;
                if (locName === "Report Room" && isWeekend) return;
                const needed = this.LOCATIONS.find(l => l.name === locName).needed;
                
                for (let i = 0; i < needed; i++) {
                    let preAssignedId = null;
                    if (specificAssignments[time] && specificAssignments[time][locName] && specificAssignments[time][locName].length > 0) { preAssignedId = specificAssignments[time][locName].shift(); }
                    
                    // --- VP BUFFER LOGIC: Check previous VP and assign to Pass Counter Slot 1 ---
                    if (!preAssignedId && locName === "Pass Counter" && i === 1) { // i=1 is the Buffer Slot
                        const prevTimeIndex = this.ROSTER_TIMES.indexOf(time) - 1;
                        if (prevTimeIndex >= 0) {
                            const prevTime = this.ROSTER_TIMES[prevTimeIndex];
                            const vpStaffId = roster['Vertical Patrol']?.[prevTime]?.[0];
                            if (vpStaffId) preAssignedId = vpStaffId;
                        }
                    }
                    attemptAssignment(time, locName, i, preAssignedId);
                }
            });
        });

        // Smart Random Fill with Fatigue Check
        const fillRandomly = (time, locName, positionIndex) => {
            if (roster[locName][time][positionIndex] !== '') return true;
            let candidateId = null; let fallbackCandidateId = null;
            const staffPool = presentStaff.map(s => s.staffId).sort(() => Math.random() - 0.5);
            
            for (const sId of staffPool) { 
                let isReservedElsewhere = false;
                if (specificAssignments[time]) { for (const assignedLoc in specificAssignments[time]) { if (assignedLoc !== locName && specificAssignments[time][assignedLoc].includes(sId)) { isReservedElsewhere = true; break; } } }
                if (isReservedElsewhere) continue;

                if (this.canAssign(sId, time, locName, assignmentsByStaff, staffMap, verticalPatrolTracker, roster)) { 
                    // SOFT CONSTRAINT: Check Standing Fatigue
                    const isStandingNow = this.STANDING_LOCATIONS.includes(locName);
                    let isFatigued = false;
                    if (isStandingNow) {
                        const prevTimeIndex = this.ROSTER_TIMES.indexOf(time) - 1;
                        if (prevTimeIndex >= 0) {
                            const prevTime = this.ROSTER_TIMES[prevTimeIndex];
                            const prevLoc = this.findStaffLocation(roster, prevTime, sId);
                            if (prevLoc && this.STANDING_LOCATIONS.includes(prevLoc)) isFatigued = true;
                        }
                    }

                    if (!isFatigued) { candidateId = sId; break; } else { if (!fallbackCandidateId) fallbackCandidateId = sId; }
                } 
            }
            
            const finalId = candidateId || fallbackCandidateId;
            if (finalId) { roster[locName][time][positionIndex] = finalId; assignmentsByStaff[finalId].push(time); if (locName === 'Vertical Patrol' || locName === 'Tango Papa') verticalPatrolTracker.add(finalId); return true; }
            return false;
        };

        this.ROSTER_TIMES.forEach(time => {
            this.OUTPUT_ORDER.forEach(locName => {
                if (this.CRITICAL_DUTIES[locName] && !this.CRITICAL_DUTIES[locName].includes(time)) return;
                if (locName === "Report Room" && isWeekend) return;
                const needed = this.LOCATIONS.find(l => l.name === locName).needed;
                for (let i = 0; i < needed; i++) { if (!fillRandomly(time, locName, i)) { if(!shortfalls.includes(`Shortfall: ${locName} @ ${time}`)) shortfalls.push(`Shortfall: ${locName} @ ${time}`); } }
            });
        });

        this.generatedRoster = roster; this.displayRoster(roster); document.getElementById('rosterActionsContainer').classList.remove('hidden');
        window.firebaseOperations.saveRoster(this.currentDateStr, roster); this.triggerSaveIndicator();
        if (shortfalls.length > 0) this.showToast(`${shortfalls.length} Shortfalls`, 'warning'); else this.showToast("Roster Generated", "success");
    },
    
    canAssign(sId, time, locName, assignmentsByStaff, staffMap, verticalPatrolTracker, rosterRef) {
        const staffMember = staffMap[sId];
        const isAlreadyAssigned = assignmentsByStaff[sId].includes(time);
        const isonBreak = this.isOnBreak(staffMember, time);
        const isHhmdMismatch = (locName === 'HHMD' && staffMember.hhmd !== 'Yes');
        const isPatrolDuplicate = ((locName === 'Vertical Patrol' || locName === 'Tango Papa') && verticalPatrolTracker.has(sId));
        if (isAlreadyAssigned || isonBreak || isHhmdMismatch || isPatrolDuplicate) return false;
        return true;
    },
    
    findStaffLocation(roster, time, staffId) {
        for (const loc of this.OUTPUT_ORDER) {
            const slot = roster[loc]?.[time];
            if (slot && slot.includes(staffId)) return loc;
        }
        return null;
    },

    preserveLockedValues() {
        const lockedValues = {}; const locks = window.firebaseOperations.getLocks();
        document.querySelectorAll(".roster-input").forEach(input => { const loc = input.dataset.loc; const time = input.dataset.time; const key = `${loc}-${time}`; if(locks[key] && input.value.trim()) lockedValues[key] = input.value.trim(); });
        return lockedValues;
    },
    getStaffIdByLock(key) { return null; },
    isOnBreak(staff, timeSlot) {
        if (!staff || !staff.breakStart || !staff.breakEnd) return false;
        const timeToMins = t => { let [h,m] = t.split(':').map(Number); return (h<12?h+24:h)*60+m; };
        const start = timeToMins(staff.breakStart), end = timeToMins(staff.breakEnd), slot = timeToMins(timeSlot);
        return start >= end ? false : (slot >= start && slot < end);
    },

    enableRosterDragScroll() {
        const el = document.getElementById('rosterContainer'); if (!el) return; if (el.__dragScrollBound) return; el.__dragScrollBound = true;
        let isDown = false; let startX; let startScrollLeft;
        el.addEventListener('mousedown', (e) => { if(['INPUT','SELECT'].includes(e.target.tagName)) return; isDown = true; startX = e.pageX - el.offsetLeft; startScrollLeft = el.scrollLeft; });
        el.addEventListener('mouseleave', () => { isDown = false; });
        el.addEventListener('mouseup', () => { isDown = false; });
        el.addEventListener('mousemove', (e) => { if (!isDown) return; e.preventDefault(); const x = e.pageX - el.offsetLeft; const walk = (x - startX) * 2; el.scrollLeft = startScrollLeft - walk; });
    },

    isSlotApplicable(locName, time) {
        const isWeekend = ['Saturday', 'Sunday'].includes(document.getElementById('rosterDay').value);
        if (this.CRITICAL_DUTIES[locName] && !this.CRITICAL_DUTIES[locName].includes(time)) return false;
        if (locName === "Report Room" && isWeekend) return false;
        return true;
    },


    // Build a compact list of ACTIVE staff who are actually assigned anywhere in the roster (for the selected day)
    getAssignedActiveStaff(roster) {
        const assignedIds = new Set();
        this.OUTPUT_ORDER.forEach(loc => {
            this.ROSTER_TIMES.forEach(time => {
                const arr = roster?.[loc]?.[time] || [];
                arr.forEach(val => {
                    if (!val) return;
                    String(val).split(/[\s,\/|]+/).filter(Boolean).forEach(id => assignedIds.add(id));
                });
            });
        });

        const rows = [];
        assignedIds.forEach(id => {
            const staff = this.staffDataCache.find(s => s.staffId === id);
            if (!staff) return;
            if (staff.attendance !== 'Yes') return; // active only
            rows.push({
                staffId: staff.staffId || id,
                name: staff.name || '',
                breakStart: staff.breakStart || '',
                breakEnd: staff.breakEnd || ''
            });
        });
        return rows;
    },

    renderBreakTable(roster) {
    const rows = this.getAssignedActiveStaff(roster);

    // Helpers for time math (night shift ordering)
    const timeToMinutes = (t) => {
        if (!t || typeof t !== 'string' || !t.includes(':')) return NaN;
        const [h, m] = t.split(':').map(n => parseInt(n, 10));
        if (Number.isNaN(h) || Number.isNaN(m)) return NaN;
        return (h * 60) + m;
    };
    const toShiftMinute = (t) => {
        const base = timeToMinutes(t);
        if (Number.isNaN(base)) return NaN;
        // Treat early morning as "next day" so 00:xx comes after 23:xx
        return (base < 12 * 60) ? (base + 24 * 60) : base;
    };

    const normalizeEnd = (startHHMM, endHHMM) => {
        const s = (startHHMM || "").trim();
        const e = (endHHMM || "").trim();
        if (!s) return e;
        // If end is missing OR still the default 00:00 while start is not 00:00,
        // compute it from the current global break duration so timeline/overlap stay correct.
        if (!e || (e === "00:00" && s !== "00:00")) return this.computeBreakEndFromStart(s);
        // If malformed, also compute.
        if (!e.includes(":")) return this.computeBreakEndFromStart(s);
        return e;
    };

    // Build interval metadata + detect overlaps
    const enriched = rows.map(r => {
        const startHHMM = (r.breakStart || '').trim();
        const endHHMM = normalizeEnd(startHHMM, r.breakEnd);
        const startMin = toShiftMinute(startHHMM);
        let endMin = toShiftMinute(endHHMM);
        let valid = !(Number.isNaN(startMin) || Number.isNaN(endMin));
        if (valid && endMin <= startMin) endMin += 24 * 60; // cross-midnight -> next day
        return {
            ...r,
            breakStart: startHHMM,
            breakEnd: endHHMM,
            _startMin: startMin,
            _endMin: endMin,
            _valid: valid,
            _overlap: false
        };
    });

    // Overlap marking (only among valid intervals)
    const validIdx = enriched
        .map((r, i) => ({ r, i }))
        .filter(x => x.r._valid)
        .sort((a, b) => a.r._startMin - b.r._startMin || String(a.r.staffId).localeCompare(String(b.r.staffId)));

    for (let k = 0; k < validIdx.length; k++) {
        const cur = validIdx[k].r;
        // compare with any previous interval that still extends beyond cur.start
        for (let j = k - 1; j >= 0; j--) {
            const prev = validIdx[j].r;
            if (prev._endMin <= cur._startMin) break; // no more possible overlaps
            // overlap
            prev._overlap = true;
            cur._overlap = true;
        }
    }

    // Sort by break start time (shift order), then by ID
    enriched.sort((a, b) => {
        const aKey = a._valid ? a._startMin : Number.POSITIVE_INFINITY;
        const bKey = b._valid ? b._startMin : Number.POSITIVE_INFINITY;
        if (aKey !== bKey) return aKey - bKey;
        return String(a.staffId).localeCompare(String(b.staffId));
    });

    if (!enriched.length) {
        return `<div class="border border-slate-200 rounded bg-slate-50 p-3 text-xs text-slate-500">
                    <div class="font-bold text-slate-600 mb-1">Break Time (Assigned Staff)</div>
                    <div>No active assigned staff found for this roster.</div>
                </div>`;
    }

    const overlapCount = enriched.filter(r => r._overlap).length;
    const overlapBanner = overlapCount
        ? `<div class="mx-3 mt-3 mb-1 rounded border border-rose-200 bg-rose-50 px-2 py-1 text-[10px] text-rose-700 font-bold"> ${overlapCount} staff break(s) overlapping. Please adjust to avoid clashes.</div>`
        : `<div class="mx-3 mt-3 mb-1 rounded border border-emerald-200 bg-emerald-50 px-2 py-1 text-[10px] text-emerald-700 font-bold"> No overlapping breaks detected.</div>`;

    const rowHtml = enriched.map(r => {
        const overlapClass = r._overlap ? "bg-rose-50" : "";
        const leftAccent = r._overlap ? "border-l-4 border-rose-500" : "";
        const badge = r._overlap
            ? `<span class="ml-2 inline-flex items-center rounded px-1.5 py-0.5 text-[9px] font-bold bg-rose-100 text-rose-700">OVERLAP</span>`
            : "";
        return `
            <tr class="border-b border-slate-200 last:border-b-0 ${overlapClass} ${leftAccent}">
                <td class="px-2 py-1 font-mono font-bold text-slate-700 whitespace-nowrap">${r.staffId}</td>
                <td class="px-2 py-1 text-slate-700 whitespace-nowrap">${r.name}</td>
                <td class="px-2 py-1 font-mono font-bold text-slate-700 whitespace-nowrap">
                    ${(r.breakStart || '--:--')} - ${(r.breakEnd || '--:--')}
                    ${badge}
                </td>
            </tr>
        `;
    }).join('');

    // Timeline bar view (20:00 -> 08:00 next day)
    const shiftStart = 20 * 60;
    const shiftEnd = (24 + 8) * 60; // 08:00 next day
    const total = shiftEnd - shiftStart;

    const ticks = [
        "20:00","22:00","00:00","02:00","04:00","06:00","08:00"
    ].map(t => {
        const m = toShiftMinute(t);
        const left = ((m - shiftStart) / total) * 100;
        return `<div class="absolute top-0 bottom-0" style="left:${left}%;">
                    <div class="w-px h-full bg-slate-200"></div>
                    <div class="mt-1 -translate-x-1/2 text-[9px] font-mono text-slate-500 whitespace-nowrap">${t}</div>
                </div>`;
    }).join('');

    const bars = enriched
        .filter(r => r._valid)
        .map(r => {
            const left = ((r._startMin - shiftStart) / total) * 100;
            const width = ((r._endMin - r._startMin) / total) * 100;
            const segClass = r._overlap ? "bg-rose-500" : "bg-indigo-500";
            return `
                <div class="flex items-center gap-2 py-1">
                    <div class="w-28 shrink-0">
                        <div class="text-[10px] font-mono font-bold text-slate-700">${r.staffId}</div>
                        <div class="text-[9px] text-slate-500 truncate">${r.name}</div>
                    </div>
                    <div class="relative flex-1 h-2 bg-slate-200 rounded overflow-hidden">
                        <div class="absolute top-0 h-full ${segClass} rounded" style="left:${left}%; width:${Math.max(0.5, width)}%;"></div>
                    </div>
                    <div class="w-20 shrink-0 text-right text-[9px] font-mono text-slate-500">${r.breakStart}${r.breakEnd}</div>
                </div>
            `;
        }).join('');

    const timeline = `
        <div class="mt-3 border border-slate-200 rounded bg-white overflow-hidden">
            <div class="px-3 py-2 bg-slate-50 border-b border-slate-200">
                <div class="text-xs font-extrabold text-slate-700 uppercase tracking-wide">Break Timeline</div>
                <div class="text-[10px] text-slate-500">20:00  08:00 (next day)  Overlaps shown in red</div>
            </div>
            <div class="p-3">
                <div class="relative h-6">
                    ${ticks}
                </div>
                <div class="mt-2">
                    ${bars || `<div class="text-xs text-slate-500">No valid break times to show on the timeline.</div>`}
                </div>
            </div>
        </div>
    `;

    return `
        <div class="border border-slate-200 rounded bg-white overflow-hidden">
            <div class="flex items-center justify-between px-3 py-2 bg-slate-50 border-b border-slate-200">
                <div class="flex items-center gap-2">
                    <i data-lucide="coffee" class="w-4 h-4 text-indigo-600"></i>
                    <div class="text-xs font-extrabold text-slate-700 uppercase tracking-wide">Break Time (Assigned Staff)</div>
                </div>
                <div class="text-[10px] font-mono font-bold text-slate-500">${enriched.length} staff</div>
            </div>
            ${overlapBanner}
            <div class="overflow-x-auto">
                <table class="min-w-full text-[10px]">
                    <thead class="bg-slate-50">
                        <tr class="border-b border-slate-200">
                            <th class="px-2 py-1 text-left font-bold text-slate-500 uppercase tracking-wider">ID</th>
                            <th class="px-2 py-1 text-left font-bold text-slate-500 uppercase tracking-wider">Name</th>
                            <th class="px-2 py-1 text-left font-bold text-slate-500 uppercase tracking-wider">Break</th>
                        </tr>
                    </thead>
                    <tbody>${rowHtml}</tbody>
                </table>
            </div>
        </div>
        ${timeline}
    `;
},
displayRoster(roster) {
        const container = document.getElementById("rosterContainer");
        const tableHead = `<thead><tr><th class="p-2 bg-slate-50 border-b border-slate-200 text-left sticky left-0 z-10 text-[10px] text-slate-500 font-bold uppercase tracking-wider">Location</th>${this.ROSTER_TIMES.map(t => `<th class="p-1 text-center bg-slate-50 border-b border-slate-200 text-[10px] text-slate-500 font-bold border-l border-slate-100">${t}</th>`).join('')}</tr></thead>`;
        
        const tableBody = this.OUTPUT_ORDER.map(locName => {
            const locConfig = this.LOCATIONS.find(l => l.name === locName);
            let locationCell = `<td class="p-2 text-xs font-bold text-slate-700 bg-white border-r border-slate-200 sticky left-0 z-10 shadow-[2px_0_5px_-2px_rgba(0,0,0,0.05)] whitespace-nowrap">${locName}</td>`;

            const timeCells = this.ROSTER_TIMES.map(time => {
                let content = '', classes = [];
                const isApplicable = this.isSlotApplicable(locName, time);
                const specialNotes = { "20:00": "@ 20:30", "01:00": "@ 01:30", "06:00": "@ 06:30" };
                
                if (isApplicable) {
                    for (let i = 0; i < locConfig.needed; i++) {
                        const assignedStaffId = roster[locName]?.[time]?.[i] || '';
                        let isPredefined = false;
                        const staff = this.staffDataCache.find(s => s.staffId === assignedStaffId);
                        
                        if (staff) {
                            if (staff.startLoc === locName && time === "20:00") isPredefined = true;
                            if (staff.vpSlot && this.VP_CYCLES[staff.vpSlot] && this.VP_CYCLES[staff.vpSlot].time === time && locName === "Vertical Patrol") isPredefined = true;
                        }

                        let extraInfo = "";
                        if (locName === 'Vertical Patrol' && specialNotes[time]) extraInfo = `<div class="text-[8px] text-slate-400 font-mono mt-[-2px]">${specialNotes[time]}</div>`;

                        const cellClass = isPredefined ? "predefined-cell" : "";
                        const icon = isPredefined ? `<i data-lucide="pin" class="predefined-icon"></i>` : "";
                        
                        content += `<div class="relative w-full ${cellClass}" style="flex: 1; display: flex; flex-direction: column; justify-content: center;">
                            <input type="text" list="staff-id-list" value="${assignedStaffId}" data-loc="${locName}" data-time="${time}" data-index="${i}" class="roster-input transition-colors font-medium text-slate-700" placeholder="--">
                            ${icon}
                            ${extraInfo}
                        </div>`;
                    }
                } else classes.push('not-applicable');
                return `<td class="${classes.join(' ')} border-r border-b border-slate-100 relative bg-white" data-location="${locName}" data-time="${time}"><div class="flex flex-col h-full gap-1 p-1" style="min-height: 50px;">${content}</div></td>`;
            }).join('');
            
            return `<tr>${locationCell}${timeCells}</tr>`;
        }).join('');

        const mainTableHtml = `<table class="styled-table w-full text-left">${tableHead}<tbody>${tableBody}</tbody></table>`;
        const breakTableHtml = this.renderBreakTable(roster);
        container.innerHTML = `<div class="flex flex-col gap-3">${mainTableHtml}${breakTableHtml}</div>`;
        container.querySelectorAll('.roster-input').forEach(input => input.addEventListener('change', (e) => this.handleCellChange(e)));
        this.applyPadlocksVisuals(); this.validateAllCells(); this.enableRosterDragScroll(); lucide.createIcons();
    },

    handleCellChange(event) { 
        const { loc, time, index } = event.target.dataset; 
        this.generatedRoster[loc][time][parseInt(index, 10)] = event.target.value; 
        this.validateAllCells(); 
        window.firebaseOperations.saveRoster(this.currentDateStr, this.generatedRoster);
        this.triggerSaveIndicator();
    },
    
    triggerSaveIndicator() {
        const el = document.getElementById('saveIndicator');
        el.classList.add('visible');
        setTimeout(() => el.classList.remove('visible'), 2000);
    },

    applyPadlocksVisuals() {
        const locks = window.firebaseOperations.getLocks(); const padlockSlots = ["20:00", "23:00", "01:00", "04:00", "06:00"];
        document.querySelectorAll("td[data-location='Vertical Patrol']").forEach(td => {
            const time = td.getAttribute("data-time"); if (!padlockSlots.includes(time)) return;
            const key = `Vertical Patrol-${time}`; const isLocked = !!locks[key];
            let icon = td.querySelector('.padlock-icon');
            if (!icon) {
                const wrapper = document.createElement('div'); wrapper.className = "absolute top-0 right-0 p-0.5 cursor-pointer z-10 hover:bg-slate-100 rounded";
                wrapper.onclick = () => { window.firebaseOperations.toggleLock(key); const newStatus = !locks[key]; wrapper.innerHTML = newStatus ? `<i data-lucide="lock" class="w-2.5 h-2.5 text-red-500"></i>` : `<i data-lucide="unlock" class="w-2.5 h-2.5 text-green-500/50 hover:text-green-500"></i>`; lucide.createIcons(); };
                wrapper.classList.add('padlock-icon'); td.appendChild(wrapper); icon = wrapper;
            }
            icon.innerHTML = isLocked ? `<i data-lucide="lock" class="w-2.5 h-2.5 text-red-500"></i>` : `<i data-lucide="unlock" class="w-2.5 h-2.5 text-green-500/50 hover:text-green-500"></i>`; lucide.createIcons();
        });
    },
    validateAllCells() {
        document.querySelectorAll('td.conflict-cell').forEach(cell => cell.classList.remove('conflict-cell')); const timeSlotUsage = {};
        document.querySelectorAll('.roster-input').forEach(input => {
            const time = input.dataset.time; const cell = input.closest('td'); const inputValue = input.value.trim(); if (!time || !inputValue) return;
            if (!timeSlotUsage[time]) timeSlotUsage[time] = {}; const staffIds = inputValue.split(/[\s,;\/]+/).filter(id => id);
            staffIds.forEach(staffId => {
                if (!timeSlotUsage[time][staffId]) timeSlotUsage[time][staffId] = []; timeSlotUsage[time][staffId].push(cell);
                const staffMember = this.staffDataCache.find(s => s.staffId === staffId); if (staffMember && this.isOnBreak(staffMember, time)) cell.classList.add('conflict-cell');
            });
        });
        for (const time in timeSlotUsage) { for (const staffId in timeSlotUsage[time]) { if (timeSlotUsage[time][staffId].length > 1) { timeSlotUsage[time][staffId].forEach(cell => cell.classList.add('conflict-cell')); } } }
    },
    showToast(message, type = "info") {
        const container = document.getElementById("toast-container"); const colors = { success: "bg-emerald-600 text-white", error: "bg-red-600 text-white", warning: "bg-amber-400 text-black", info: "bg-blue-600 text-white" };
        const toast = document.createElement("div"); toast.className = `${colors[type]} px-4 py-2 rounded shadow-xl flex items-center gap-2 transform -translate-y-4 opacity-0 transition-all duration-200 text-xs font-bold pointer-events-auto`; toast.innerHTML = `<span>${message}</span>`;
        container.appendChild(toast); requestAnimationFrame(() => { toast.classList.remove("-translate-y-4", "opacity-0"); }); setTimeout(() => { toast.classList.add("-translate-y-4", "opacity-0"); setTimeout(() => toast.remove(), 200); }, 2000);
    },
    copyTSV() {
        if (!this.generatedRoster) return this.showToast("No roster", "error");
        const tsv = this.OUTPUT_ORDER.map(loc => `${loc}\t${this.ROSTER_TIMES.map(time => (this.generatedRoster[loc]?.[time] || []).join(" | ")).join("\t")}`).join("\n");
        navigator.clipboard.writeText(`Location\t${this.ROSTER_TIMES.join("\t")}\n${tsv}`).then(() => this.showToast("Copied", "success"), () => this.showToast("Failed", "error"));
    },
    downloadPDF() {
        // Ensure libs are ready (prevents "sometimes works" on slow mobile loads)
        if (!window.jspdf || !window.jspdf.jsPDF) {
            this.showToast("PDF engine not loaded yet. Try again in 2s.", "warning");
            return;
        }
        if (!window.jspdf.jsPDF.API || !window.jspdf.jsPDF.API.autoTable) {
            // Some builds expose autoTable via doc.autoTable after plugin load; verify by creating doc
            // We'll still proceed and catch if missing.
        }
        if (!this.generatedRoster) return this.showToast('No roster', 'error');
        try {
            const { jsPDF } = window.jspdf; const doc = new jsPDF({ orientation: "landscape", unit: "mm", format: "a4" });
            const rosterDate = document.getElementById('rosterDate').value; const rosterDay = document.getElementById('rosterDay').value;
            doc.setFontSize(14); doc.text(`Staff Roster - ${rosterDate} (${rosterDay})`, 14, 15);
            const specialNotes = { "20:00": "@ 20:30", "01:00": "@ 01:30", "06:00": "@ 06:30" };
            const mainRosterBody = this.OUTPUT_ORDER.map(locName => {
                const rowData = this.ROSTER_TIMES.map(time => {
                    let staffText = (this.generatedRoster[locName]?.[time] || []).filter(Boolean).join('\n'); 
                    if (locName === 'Vertical Patrol' && staffText && specialNotes[time]) return `${staffText}\n${specialNotes[time]}`; return staffText;
                }); return [locName, ...rowData];
            });
            doc.autoTable({ head: [['Location', ...this.ROSTER_TIMES]], body: mainRosterBody, startY: 20, theme: 'grid', styles: { fontSize: 6, cellPadding: 1, halign: 'center', valign: 'middle', lineColor: [200, 200, 200] }, headStyles: { fillColor: [51, 65, 85], textColor: 255, fontSize: 7, fontStyle: 'bold' }, columnStyles: { 0: { fontStyle: "bold", cellWidth: 28, halign: 'left', fillColor: [241, 245, 249] } } });

            // --- Break time table (assigned ACTIVE staff) ---
            const assignedActive = this.getAssignedActiveStaff(this.generatedRoster);
            const breakBody = assignedActive.map(s => [s.staffId, s.name, `${(s.breakStart || '--:--')} - ${(s.breakEnd || '--:--')}`]);
            if (breakBody.length) {
                const y = (doc.lastAutoTable && doc.lastAutoTable.finalY) ? doc.lastAutoTable.finalY + 6 : 120;
                doc.setFontSize(10);
                doc.text('Break Time (Assigned Staff)', 14, y);
                doc.autoTable({
                    head: [['ID', 'Name', 'Break']],
                    body: breakBody,
                    startY: y + 2,
                    theme: 'grid',
                    styles: { fontSize: 8, cellPadding: 1.5, valign: 'middle', lineColor: [200, 200, 200] },
                    headStyles: { fillColor: [241, 245, 249], textColor: 30, fontStyle: 'bold' },
                    columnStyles: { 0: { cellWidth: 18, fontStyle: 'bold' }, 1: { cellWidth: 55 }, 2: { cellWidth: 30, fontStyle: 'bold' } }
                });
            }
            const blobUrl = doc.output('bloburl'); document.getElementById('pdfDownloadLink').href = blobUrl; document.getElementById('pdfPreview').src = blobUrl; document.getElementById('pdfModal').classList.remove('hidden'); document.getElementById('pdfModal').classList.add('flex');
        } catch (e) { console.error(e); this.showToast('Error creating PDF', 'error'); }
    },
    closePdfModal() { const preview = document.getElementById('pdfPreview'); preview.src = 'about:blank'; document.getElementById('pdfModal').classList.add('hidden'); document.getElementById('pdfModal').classList.remove('flex'); }
};
document.addEventListener('DOMContentLoaded', () => rosterSystem.init());
</script>
</body>
</html>


