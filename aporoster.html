<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent Roster System (v15.8 - Matrix Mode Buffer Fix)</title>
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Load React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- 3. Load Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- 4. Load Firebase SDKs (v10.13.1 - Stable) -->
    <!-- CRITICAL FIX: Use module loading again, but explicitly export global references -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, getDoc, setDoc, onSnapshot, 
            collection, deleteDoc, setLogLevel, updateDoc
        } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js";

        // --- SDK CONFIGURATION (Must be defined outside the module for the environment to pick up __variables) ---
        const mockFirebaseConfig = {
          apiKey: "AIzaSyAP7b4KcwRYPMZjNc2TWsNqMvC3ywImhOM",
          authDomain: "roster-4a997.firebaseapp.com",
          projectId: "roster-4a997",
          storageBucket: "roster-4a997.firebasestorage.app",
          messagingSenderId: "901381868881",
          appId: "1:901381868881:web:92930481d6c1c85fedd770"
        };
        
        // --- Canvas Environment Variables ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : mockFirebaseConfig;
        
        // CRITICAL FIX: Corrected typo from __initialAuthToken to __initial_auth_token
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Set Firebase Log Level for debugging
        setLogLevel('debug');

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // **CRITICAL:** Expose all required variables and functions on a single global object, 
        // which the React script will then rely upon.
        window.firebase = {
            // Core Instances and Constants
            db: db,
            auth: auth, 
            appId: appId,
            initialAuthToken: initialAuthToken,
            
            // Firestore Functions
            doc: doc,
            getDoc: getDoc,
            setDoc: setDoc,
            onSnapshot: onSnapshot,
            collection: collection,
            deleteDoc: deleteDoc,
            updateDoc: updateDoc,
            
            // Auth Functions
            signInAnonymously: signInAnonymously,
            onAuthStateChanged: onAuthStateChanged,
            signInWithCustomToken: signInWithCustomToken
        };
        
        // CRITICAL FIX: Delay React Render until Firebase is ready
        let attempts = 0;
        const maxAttempts = 20; 
        
        function tryRenderApp() {
            // Use the globally exposed firebase object and its properties for the readiness check
            if (window.firebase && window.firebase.db && window.firebase.auth) {
                try {
                    // Use React.createElement to prevent Babel interpretation issues during delayed render
                    const root = ReactDOM.createRoot(document.getElementById('root'));
                    root.render(React.createElement(App));
                } catch (e) {
                    console.error("React Render Failed:", e);
                    document.getElementById('root').innerHTML = '<div style="padding: 20px; color: red; background: #fee2e2; border: 1px solid #f87171; text-align: center;">FATAL ERROR: React failed to start. Check console.</div>';
                }
            } else if (attempts < maxAttempts) {
                attempts++;
                setTimeout(tryRenderApp, 100);
            } else {
                console.error("FATAL ERROR: Firebase SDK did not initialize within the expected time.");
                document.getElementById('root').innerHTML = '<div style="padding: 20px; color: red; background: #fee2e2; border: 1px solid #f87171; text-align: center;">FATAL ERROR: Application timeout. Firebase SDK failed to initialize. Please try again.</div>';
            }
        }
        
        // Start the render attempt process on window load
        window.onload = tryRenderApp;

    </script>
    
    <style>
        /* --- General Styling --- */
        .highlight-cell { background-color: #FDE047; border: 2px solid #F59E0B; color: #000; font-weight: bold; }
        
        /* Styles for cells containing permanent/buffer pairs (dropdowns) */
        .dropdown-permanent { font-weight: bold; color: #1D4ED8; background-image: linear-gradient(45deg, #EFF6FF 50%, #DBEAFE 50%); background-size: 8px 8px; }
        .dropdown-buffer { font-weight: bold; color: #581c87; background-color: #d8b4fe; }

        /* ENHANCED: Style for any cell whose VALUE (staff ID) is a buffer, regardless of pairing/mode */
        .buffer-id-content { 
            background-color: #FBCFE8 !important; /* Pink 200 - enhanced visibility */
            color: #9D174D !important; /* Rose 700 - deep contrast text */
            font-weight: 700 !important;
            border: 1px solid #F472B6 !important; /* Pink 400 */
        }

        select, input { text-align: center !important; text-align-last: center !important; -moz-text-align-last: center !important; }
        
        /* --- Consolidated Setup Card Styles (Section 1) --- */
        .staff-pool-grid {
             grid-template-columns: repeat(2, minmax(0, 1fr)); 
        }
        @media (min-width: 400px) { 
            .staff-pool-grid { grid-template-columns: repeat(3, minmax(0, 1fr)); } 
        }
        @media (min-width: 768px) { 
            .staff-pool-grid { grid-template-columns: repeat(4, minmax(0, 1fr)); } 
        }
        @media (min-width: 1024px) { 
            .staff-pool-grid { grid-template-columns: repeat(5, minmax(0, 1fr)); } 
        }

        .staff-card-scheduled { border: 1px solid #10B981; background-color: #F0FDF4; }
        .staff-card-unscheduled { border: 1px solid #F87171; background-color: #FEF2F2; }

        /* --- Assignment Card Styles (Section 2) --- */
        .assignment-grid {
             grid-template-columns: repeat(1, minmax(0, 1fr)); 
        }
        @media (min-width: 768px) { 
            .assignment-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); } 
        }
        @media (min-width: 1024px) { 
            .assignment-grid { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        }

        /* --- Custom Toggle Switch (for Mobile/Touch) --- */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #3B82F6; /* Blue-500 */
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        
        /* Radio Group for Roster Mode */
        .radio-group input[type="radio"]:checked + label {
            background-color: #3B82F6; /* Blue-500 */
            color: white;
            border-color: #3B82F6;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        .modal-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            max-width: 90%;
            width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        /* Matrix Edit Mode Styles */
        .matrix-edit-active td {
            background-color: #f0f9ff !important; /* Blue-50 */
        }
        
        /* CRITICAL FIX: Ensure matrix select inputs can be overridden by buffer style */
        .matrix-edit-active select {
            background-color: #e0f2fe !important; /* Blue-100 */
            font-weight: 600;
            border: 1px solid #93c5fd;
            padding: 1px 1px !important; 
            height: 18px !important;
        }
        
        /* Give buffer content higher specificity than the generic matrix select style */
        .matrix-edit-active .buffer-id-content {
             background-color: #FBCFE8 !important;
             color: #9D174D !important;
             border: 1px solid #F472B6 !important;
        }


        .matrix-edit-active select:focus {
            outline: none;
            box-shadow: 0 0 0 2px #93c5fd;
        }


        /* --- Print Styles --- */
        @media print {
            header, footer, .nav-buttons, .action-buttons, .focus-buttons, .date-selector, .unsaved-changes, .print-hidden, .setup-tools, .roster-mode-selector, .filter-control-button { display: none !important; }
            @page { size: A4 landscape; margin: 0.5cm; }
            body { zoom: 80%; }
            .min-h-screen, #root, main, .container { min-height: auto !important; padding: 0 !important; margin: 0 auto !important; width: 100% !important; max-width: none !important; }
            .shadow-md, .rounded-lg, .border { box-shadow: none !important; border: none !important; border-collapse: collapse !important; }
            .roster-section { break-inside: avoid; margin-bottom: 0.5cm !important; padding: 0 !important; }
            .overflow-x-auto { overflow: visible !important; }
            .min-w-full { width: 100% !important; table-layout: fixed; }
            .min-w-full th:first-child, .min-w-full td:first-child { width: 2.4in !important; max-width: 2.4in !important; min-width: 2.4in !important; white-space: normal !important; text-align: left !important; }
            .min-w-full th:first-child, .min-w-full td:first-child span { font-size: 7.5pt !important; }
            .p-1 { padding: 0.1rem !important; }
            .text-xs, .text-sm { font-size: 8pt !important; line-height: 1.1 !important; }
            .sticky { position: static !important; }
            input, select { -webkit-appearance: none !important; -moz-appearance: none !important; appearance: none !important; border: 0.5px solid #ccc !important; background-color: transparent !important; text-align: center !important; font-weight: bold; color: #000; width: 100% !important; box-sizing: border-box !important; }
            
            /* Print-specific style overrides */
            .dropdown-permanent, .dropdown-buffer, .highlight-cell { background-color: #E0F2FE !important; color: #000 !important; border: 0.5px solid #999 !important; background-image: none !important; }
            .bg-gray-100, .bg-gray-50 { background-color: #f7f7f7 !important; }
            .bg-white { background-color: white !important; }
            .highlight-cell { background-color: #FEF3C7 !important; }
            
            /* NEW: Print-specific style for Buffer ID content (ENHANCED) */
            .buffer-id-content { 
                background-color: #FBCFE8 !important; /* Pink 200 */
                color: #9D174D !important; /* Rose 700 */
                font-weight: 700 !important; 
                border: 0.5px solid #F472B6 !important; /* Pink 400 */
            }

            .vp-cell-fix { width: 17% !important; text-align: center !important; padding: 0px !important; margin: 0px !important; }
            .roster-section table td { padding: 0.1rem 0 !important; }
            .roster-section table input.vp-cell-fix, .roster-section table select.vp-cell-fix { margin: 0 !important; padding: 1px 1px !important; height: 14px !important; line-height: 1.2 !important; text-align: center !important; width: 100% !important; box-sizing: border-box !important; }
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div id="root"></div>

    <script type="text/babel">
        // --- REACT COMPONENT CODE STARTS HERE ---
        
        // This is a placeholder structure to grab the global variables set by the module script above
        const FIREBASE_GLOBALS = window.firebase || {};
        
        const { useState, useEffect, useMemo, createContext, useContext } = React;
        
        // Grab dependencies from the global object
        const { 
            doc, getDoc, setDoc, onSnapshot, 
            collection, deleteDoc, updateDoc,
            signInAnonymously, onAuthStateChanged, 
            signInWithCustomToken, initialAuthToken,
            appId, db, auth
        } = FIREBASE_GLOBALS;
        
        // --- Constants (rest of the file remains the same) ---
        const SECURITY_POSITIONS = ["TEAM LEADER (I/C)", "SECTION I/C"];
        const FOYER_POSITIONS = ["XRAY-VISITOR", "FOYER-OE"];
        const VERTICAL_PROWLER_POSITION = "VERTICAL PROWLER";
        
        // All possible rows in the Sentry/Patrol section
        const SENTRY_POSITIONS = ["E1", "PATROL 1", "E3", "N1 (CNB)", "PATROL 2", "OE/ STANDBY", "PERIMETER PROWLER (1st Half)", "PERIMETER PROWLER (2nd Half)"];
        
        const TIME_SLOTS = ["2000Hrs", "2100Hrs", "2200Hrs", "2300Hrs", "2400Hrs", "0100Hrs", "0200Hrs", "0300Hrs", "0400Hrs", "0500Hrs", "0600Hrs", "0700Hrs"];
        const VERTICAL_PROWLER_SLOTS = ["20:30", "23:00", "00:30", "03:00", "04:30", "06:30"];
        
        // Roster Keys (used for Auto-Sequence Assignment)
        const SENTRY_SEQUENCE_KEYS = ["E1", "OE", "P2", "N1", "E3", "P1"];
        
        // Location Keys (used for Manual Fixed Assignment)
        const SENTRY_LOCATION_KEYS = ["E1", "PATROL 1", "E3", "N1 (CNB)", "PATROL 2", "OE/ STANDBY", "PERIMETER PROWLER (1st Half)", "PERIMETER PROWLER (2nd Half)"];
        
        const FOYER_ASSIGNMENT_KEYS = ["FOYER 1", "FOYER 2"];
        const SECURITY_ASSIGNMENT_KEYS = ["TEAM LEADER (I/C)", "SECTION I/C"];
        
        // All possible assignment keys (sequences and locations)
        const ALL_ASSIGNMENT_KEYS = [...SENTRY_SEQUENCE_KEYS, ...SENTRY_LOCATION_KEYS, ...FOYER_ASSIGNMENT_KEYS, ...SECURITY_ASSIGNMENT_KEYS];
        const UNASSIGNED_KEY = "Unassigned";
        const UNFILLED_SLOT = "---";

        // Logic for Auto-Sequence Mode
        const SENTRY_POSITION_SEQUENCES = {
            "E1": ["E1", "OE", "P2", "N1", "E3", "P1"], "PATROL 1": ["P1", "E1", "OE", "P2", "N1", "E3"],
            "E3": ["E3", "P1", "E1", "OE", "P2", "N1"], "N1 (CNB)": ["N1", "E3", "P1", "E1", "OE", "P2"],
            "PATROL 2": ["P2", "N1", "E3", "P1", "E1", "OE"], "OE/ STANDBY": ["OE", "P2", "N1", "E3", "P1", "E1"],
            // Patrol Prowlers will be handled separately as they are a full shift assignment
            "PERIMETER PROWLER (1st Half)": ["Prowler1"], "PERIMETER PROWLER (2nd Half)": ["Prowler2"]
        };
        
        // Roster Modes for daily operations
        const ROSTER_MODES = {
            AUTO_SEQUENCE: 'Auto-Sequence',
            MANUAL_LOCATION_FIXED: 'Manual-Location-Fixed'
        };
        
        // --- DB Collection Names ---
        const TEAM_COLLECTION = "teams"; 
        const EMPLOYEES_COLLECTION = "employees";
        const DAILY_ASSIGNMENTS_COLLECTION = "dailyAssignments_v7";
        const DAILY_ROSTER_COLLECTION = "dailyRosters_v7";
        const DAILY_ATTENDANCE_COLLECTION = "dailyAttendance_v7"; 
        
        // CRITICAL HELPER: Generates the correct collection reference path
        const getCollectionRef = (collectionName) => {
            // Defensive checks for missing Firebase objects
            if (!db || typeof collection !== 'function') return null;

            // Team and Employee data use the public path prefix
            if (collectionName === TEAM_COLLECTION || collectionName === EMPLOYEES_COLLECTION) {
                // FALLBACK CHECK: If appId is not defined or is 'default-app-id', we try to read from the root collection instead
                if (appId === 'default-app-id' || typeof appId === 'undefined') {
                    console.warn(`[WARNING] Using fallback root path for ${collectionName}. Check if appId is defined correctly.`);
                    return collection(db, collectionName);
                }
                const path = `artifacts/${appId}/public/data/${collectionName}`;
                return collection(db, path);
            }
            // All daily roster data is stored at the root collection path
            return collection(db, collectionName);
        };

        // CRITICAL HELPER: Generates the correct doc reference path
        const getDocRef = (collectionName, docId) => {
            // Defensive checks for missing Firebase objects
            if (!db || typeof doc !== 'function') return null;

            // Team and Employee data use the public path prefix
            if (collectionName === TEAM_COLLECTION || collectionName === EMPLOYEES_COLLECTION) {
                if (appId === 'default-app-id' || typeof appId === 'undefined') {
                    return doc(db, collectionName, String(docId));
                }
                return doc(db, `artifacts/${appId}/public/data/${collectionName}`, String(docId));
            }
            // All daily roster data is stored at the root collection path
            return doc(db, collectionName, String(docId));
        };
        
        // --- Helper: Get today's date ---
        const getTodayDate = () => {
            const today = new Date();
            const offset = today.getTimezoneOffset();
            const adjustedToday = new Date(today.getTime() - (offset*60*1000));
            return adjustedToday.toISOString().split('T')[0];
        };

        // --- CRITICAL: Helper to sanitize data for Firestore ---
        const sanitizeForFirestore = (obj) => {
            if (obj === undefined || obj === null) return null;
            if (Array.isArray(obj)) {
                return obj.map(sanitizeForFirestore);
            }
            if (typeof obj === 'object' && obj !== null) {
                const newObj = {};
                Object.keys(obj).forEach(key => {
                    newObj[key] = sanitizeForFirestore(obj[key]);
                });
                return newObj;
            }
            return obj;
        };

        // --- Helper to extract name after parentheses ---
        const extractName = (fullName) => {
            if (!fullName || typeof fullName !== 'string') return '';
            const match = fullName.match(/\((.*?)\)\s*(.*)/);
            if (match && match[2]) {
                // Returns the part after the closing parenthesis and optional space
                return match[2].trim();
            }
            // If no parentheses are found, return the original name
            return fullName.trim();
        };

        // --- Helper to remove leading 'T' from ID ---
        const cleanStaffId = (id) => {
            if (!id || typeof id !== 'string') return '';
            const trimmedId = id.trim();
            // Check if the ID starts with 'T' (case-insensitive) and remove it.
            if (trimmedId.length > 1 && (trimmedId.startsWith('T') || trimmedId.startsWith('t'))) {
                return trimmedId.substring(1);
            }
            return trimmedId;
        };
        
        // --- React Context for Staff Pool & Attendance ---
        const StaffContext = createContext();
        
        function StaffProvider({ children, selectedDate }) {
            const [employees, setEmployees] = useState([]); 
            const [teams, setTeams] = useState([]); 
            const [dailyAttendance, setDailyAttendance] = useState([]); 
            const [loadingState, setLoadingState] = useState({ teams: true, employees: true, attendance: true });
            const [error, setError] = useState(null);
            
            // 1. Load Teams Data (Uses dynamic public path/fallback)
            useEffect(() => {
                const teamsCollectionRef = getCollectionRef(TEAM_COLLECTION);
                if (!teamsCollectionRef) return;
                
                const unsubscribe = onSnapshot(teamsCollectionRef, (querySnapshot) => {
                    const loadedTeams = [];
                    querySnapshot.forEach(doc => {
                        loadedTeams.push({ docId: doc.id, ...doc.data() });
                    });
                    setTeams(loadedTeams);
                    setLoadingState(prev => ({ ...prev, teams: false }));
                }, (err) => {
                    console.error("Error fetching teams: ", err);
                    setError("Could not load teams data. Data path might be incorrect or missing.");
                    setLoadingState(prev => ({ ...prev, teams: false }));
                });
                return () => unsubscribe();
            }, [appId]);

            // 2. Load Employees/Users Data (Uses dynamic public path/fallback)
            useEffect(() => {
                const employeesCollectionRef = getCollectionRef(EMPLOYEES_COLLECTION);
                if (!employeesCollectionRef) return;
                
                const unsubscribe = onSnapshot(employeesCollectionRef, (querySnapshot) => {
                    const loadedEmployees = [];
                    querySnapshot.forEach(doc => {
                        loadedEmployees.push({ docId: doc.id, ...doc.data() });
                    });
                    setEmployees(loadedEmployees.sort((a, b) => (a.name || '').localeCompare(b.name || '')));
                    setLoadingState(prev => ({ ...prev, employees: false }));
                }, (err) => {
                    console.error("Error fetching users/employees: ", err);
                    setError(`Could not load employee data. Data path might be incorrect or missing.`);
                    setLoadingState(prev => ({ ...prev, employees: false }));
                });
                return () => unsubscribe();
            }, [appId]);
            
            // 3. Load Daily Attendance for selected date (Uses root path)
            useEffect(() => {
                if (!selectedDate || !db) return; 
                setLoadingState(prev => ({ ...prev, attendance: true }));

                const docRef = getDocRef(DAILY_ATTENDANCE_COLLECTION, selectedDate);
                if (!docRef) return;
                
                const unsubscribe = onSnapshot(docRef, (docSnap) => {
                    const scheduledIds = docSnap.exists() ? docSnap.data().scheduledStaff || [] : [];
                    setDailyAttendance(scheduledIds);
                    setLoadingState(prev => ({ ...prev, attendance: false }));
                }, (err) => {
                    console.error("Error fetching daily attendance: ", err);
                    setLoadingState(prev => ({ ...prev, attendance: false }));
                });
                return () => unsubscribe();
            }, [selectedDate]); 
            
            // Processed data for components (CRITICAL for fixing the white screen error)
            const teamMap = useMemo(() => {
                const map = new Map();
                teams.forEach(t => map.set(t.docId, t));
                return map;
            }, [teams]);
            
            const staffPool = useMemo(() => employees.map(emp => {
                // Priority: emp_id > id > docId
                const rawStaffId = emp.emp_id || emp.id || emp.docId; 
                if (!rawStaffId) return null; 

                // Apply ID cleaning logic here
                const staffId = cleanStaffId(String(rawStaffId));

                // Use the name extraction helper
                const rawName = emp.name || String(staffId);
                const extractedName = extractName(rawName);

                return {
                    id: String(staffId), // Use CLEANED ID (for display/roster logic)
                    docId: emp.docId, // **CRITICAL FIX: Keep original Firestore document ID for deletion**
                    name: extractedName || String(staffId), // Ensure name is always set
                    rawName: rawName, // Keep raw name for reference if needed
                    team_id: emp.team_id || '', // **CRITICAL FIX: Ensure team_id is a string, not undefined**
                    team_name: teamMap.get(emp.team_id)?.name || 'N/A Team', 
                    type: emp.is_buffer ? 'buffer' : 'permanent',
                };
            }).filter(s => s !== null), [employees, teamMap]); 

            const staffTypeMap = useMemo(() => {
                const map = new Map();
                staffPool.forEach(staff => {
                    map.set(staff.id, staff.type);
                });
                return map;
            }, [staffPool]);
            
            // Overall loading is only false when all sources are done
            const loading = loadingState.teams || loadingState.employees || loadingState.attendance;

            const scheduledStaff = useMemo(() => {
                const scheduledSet = new Set(dailyAttendance);
                if (loading) return []; 
                
                return staffPool.filter(staff => scheduledSet.has(staff.id));
            }, [staffPool, dailyAttendance, loading]);

            const value = { 
                staffPool, 
                teamMap,   
                staffTypeMap, 
                loading, 
                error,
                dailyAttendance,
                scheduledStaff
            };
            
            return (
                <StaffContext.Provider value={value}>
                    {children}
                </StaffContext.Provider>
            );
        }

        // --- Main App Component ---
        function App() {
            const [view, setView] = useState('roster'); 
            const [userId, setUserId] = useState(null);
            const [authLoading, setAuthLoading] = useState(true);
            const [authError, setAuthError] = useState(null);
            const [selectedDate, setSelectedDate] = useState(getTodayDate());

            // Authentication Handler
            useEffect(() => {
                // Check if auth object is available before proceeding
                if (typeof auth === 'undefined' || auth === null) {
                    // This case should be caught by the external delay loop, but safety first
                    setAuthError("Firebase Auth service is still loading or unavailable.");
                    setAuthLoading(false);
                    return;
                }
                
                let isSigningIn = false;
                
                const unsubscribe = onAuthStateChanged(auth, (user) => {
                    if (user) {
                        setUserId(user.uid);
                        setAuthLoading(false);
                    } else if (!isSigningIn) {
                        isSigningIn = true;
                        const signIn = async () => {
                            try {
                                if (initialAuthToken) {
                                    // Use sign in with custom token if available
                                    await signInWithCustomToken(auth, initialAuthToken);
                                    console.log("Signed in with custom token.");
                                } else {
                                    // Fallback to anonymous sign in
                                    await signInAnonymously(auth);
                                    console.log("Signed in anonymously.");
                                }
                            } catch (err) {
                                console.error("Authentication error: ", err);
                                setAuthError("Failed to authenticate. Token might be invalid or rules misconfigured.");
                            } finally {
                                if(authLoading) setAuthLoading(false); 
                            }
                        };
                        signIn();
                    }
                });
                
                return () => unsubscribe();
            }, []); 

            if (authLoading) return <div className="p-8 text-center text-2xl font-semibold text-blue-600">Connecting to Firebase Server...</div>
            if (authError) return <div className="p-8 text-center text-xl font-semibold text-red-600">Authentication Failed: {authError}</div>
            
            // Render the main content only if authenticated
            return (
                <StaffProvider selectedDate={selectedDate}>
                    <div className="min-h-screen">
                        {/* Header: Hidden on Print */}
                        <header className="bg-white shadow-md">
                            <nav className="container mx-auto px-4 sm:px-6 lg:px-8 flex flex-col sm:flex-row justify-between items-center py-4 gap-4">
                                <h1 className="text-2xl font-bold text-blue-600">Direct Assign Roster (v15.3)</h1>
                                <div className="flex space-x-2 nav-buttons">
                                    <NavButton
                                        label="Daily Roster"
                                        isActive={view === 'roster'}
                                        onClick={() => setView('roster')}
                                    />
                                    <NavButton
                                        label="Staff & Roster Setup"
                                        isActive={view === 'settings'}
                                        onClick={() => setView('settings')}
                                    />
                                </div>
                            </nav>
                        </header>
                        
                        {/* Page Content */}
                        <main className="container mx-auto p-0 sm:p-6 lg:px-8">
                            {view === 'roster' && <RosterView selectedDate={selectedDate} setSelectedDate={setSelectedDate} />}
                            {view === 'settings' && <StaffAndRosterSetupView selectedDate={selectedDate} setSelectedDate={setSelectedDate} />}
                        </main>
                        
                        {/* Footer: Hidden on Print */}
                        <footer className="text-center p-4 text-gray-500 text-sm">
                            User ID (Auth Token): <span className="font-mono bg-gray-200 px-1 rounded">{userId}</span>
                        </footer>
                    </div>
                </StaffProvider>
            );
        }

        function NavButton({ label, isActive, onClick }) {
            const baseClasses = "py-2 px-4 rounded-md font-medium text-sm sm:text-base transition-all duration-200";
            const activeClasses = "bg-blue-600 text-white shadow-md";
            const inactiveClasses = "text-gray-600 hover:bg-gray-200";
            return ( <button onClick={onClick} className={`${baseClasses} ${isActive ? activeClasses : inactiveClasses}`}>{label}</button> );
        }

        // --- View 1: Staff & Roster Setup (Combined and Consolidated) ---
        function StaffAndRosterSetupView({ selectedDate, setSelectedDate }) {
            return (
                <div className="space-y-6">
                    {/* Section 1: Consolidated Staff Pool and Attendance Management */}
                    <ConsolidatedStaffManagement selectedDate={selectedDate} setSelectedDate={setSelectedDate} />
                    
                    {/* Section 2 (Compact Card List): Daily Assignment Setup */}
                    <DailySequenceAssignment selectedDate={selectedDate} setSelectedDate={setSelectedDate} />
                </div>
            );
        }

        // --- Reusable Modal Component ---
        // **UPDATE**: Added SHOW_SCHEDULED_FILTER_VALUE to the modal
        function TeamFilterModal({ isOpen, onClose, teamOptions, currentFilter, onSelectTeam }) {
            if (!isOpen) return null;

            const SHOW_ALL_FILTER_VALUE = 'SHOW_ALL';
            const SHOW_SCHEDULED_FILTER_VALUE = 'SHOW_SCHEDULED';

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={e => e.stopPropagation()}>
                        <div className="flex justify-between items-center border-b pb-3 mb-4">
                            <h3 className="text-lg font-bold text-gray-800">Filter Staff by Team</h3>
                            <button onClick={onClose} className="text-gray-500 hover:text-gray-900 text-xl font-bold">&times;</button>
                        </div>

                        <div className="space-y-2">
                            {/* Option 1: Show All (Default) */}
                            <button 
                                onClick={() => { onSelectTeam(SHOW_ALL_FILTER_VALUE); onClose(); }}
                                className={`w-full py-2 px-4 text-left rounded-md font-semibold transition-all ${
                                    currentFilter === SHOW_ALL_FILTER_VALUE 
                                    ? 'bg-blue-600 text-white shadow-md' 
                                    : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                                }`}
                            >
                                Show All Staff
                            </button>
                            
                            {/* **NEW OPTION**: Show Scheduled IDs */}
                            <button 
                                onClick={() => { onSelectTeam(SHOW_SCHEDULED_FILTER_VALUE); onClose(); }}
                                className={`w-full py-2 px-4 text-left rounded-md font-semibold transition-all ${
                                    currentFilter === SHOW_SCHEDULED_FILTER_VALUE 
                                    ? 'bg-green-600 text-white shadow-md' 
                                    : 'bg-white border border-green-300 hover:bg-green-50 text-green-700'
                                }`}
                            >
                                Show Only Scheduled Staff
                            </button>

                            {/* Option 3: Clear Filter / Show None */}
                            <button 
                                onClick={() => { onSelectTeam(""); onClose(); }}
                                className={`w-full py-2 px-4 text-left rounded-md font-semibold transition-all ${
                                    currentFilter === "" 
                                    ? 'bg-red-600 text-white shadow-md' 
                                    : 'bg-white border hover:bg-red-50 text-red-700'
                                }`}
                            >
                                Clear Filter (Show None)
                            </button>


                            <div className="border-t pt-2 mt-2">
                                <p className="text-sm font-bold text-gray-600 my-2">-- Filter by Specific Team --</p>
                                {/* Team Options */}
                                {teamOptions.map(t => (
                                    <button
                                        key={t.docId}
                                        onClick={() => { onSelectTeam(t.docId); onClose(); }}
                                        className={`w-full py-2 px-4 text-left rounded-md font-semibold transition-all ${
                                            currentFilter === t.docId 
                                            ? 'bg-blue-600 text-white shadow-md' 
                                            : 'bg-white border hover:bg-gray-50 text-gray-700'
                                        }`}
                                    >
                                        {t.name}
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }
        
        // --- CONSOLIDATED STAFF MANAGEMENT COMPONENT (Section 1) ---
        function ConsolidatedStaffManagement({ selectedDate, setSelectedDate }) {
            const { staffPool, dailyAttendance, teamMap, loading: staffLoading } = useContext(StaffContext);
            const [newStaffId, setNewStaffId] = useState("");
            const [newStaffName, setNewStaffName] = useState("");
            const [newStaffType, setNewStaffType] = useState("permanent");
            const [newStaffTeamId, setNewStaffTeamId] = useState("");
            const [localDailyAttendance, setLocalDailyAttendance] = useState([]);
            const [status, setStatus] = useState("idle");
            const [error, setError] = useState(null);
            
            // Filter constants
            const SHOW_ALL_FILTER_VALUE = 'SHOW_ALL';
            const SHOW_SCHEDULED_FILTER_VALUE = 'SHOW_SCHEDULED';
            
            // Filter state: "" means "Show None", 'SHOW_ALL' means show all staff, 'SHOW_SCHEDULED' means only scheduled, team ID means filter by team.
            const [filterTeamId, setFilterTeamId] = useState(""); 
            const [isModalOpen, setIsModalOpen] = useState(false);
            
            // Sync Firestore attendance data with local state when it changes from the DB
            useEffect(() => {
                setLocalDailyAttendance(dailyAttendance);
                setStatus("idle");
            }, [dailyAttendance, selectedDate]);
            
            const isLocalDataDirty = useMemo(() => {
                if (localDailyAttendance.length !== dailyAttendance.length) return true;
                const sortedLocal = [...localDailyAttendance].sort();
                const sortedRemote = [...dailyAttendance].sort();
                
                for(let i = 0; i < sortedLocal.length; i++) {
                    if (sortedLocal[i] !== sortedRemote[i]) return true;
                }
                
                return false;
            }, [localDailyAttendance, dailyAttendance]);

            const scheduledSet = useMemo(() => new Set(localDailyAttendance), [localDailyAttendance]);
            
            // **UPDATE**: Filtering Logic adjusted to handle SHOW_SCHEDULED
            const filteredStaff = useMemo(() => {
                if (filterTeamId === SHOW_SCHEDULED_FILTER_VALUE) {
                     return staffPool.filter(staff => scheduledSet.has(staff.id));
                }
                if (filterTeamId === SHOW_ALL_FILTER_VALUE) return staffPool;
                if (filterTeamId === "") return []; // New default: Show None
                
                return staffPool.filter(staff => staff.team_id === filterTeamId);
            }, [staffPool, filterTeamId, scheduledSet]);

            const teamOptions = useMemo(() => {
                return Array.from(teamMap.values()).sort((a, b) => a.name.localeCompare(b.name));
            }, [teamMap]);

            // CRITICAL FIX: Determine display name for the filter button
            const currentFilterName = useMemo(() => {
                if (filterTeamId === SHOW_ALL_FILTER_VALUE) return "Filter: All Staff";
                if (filterTeamId === SHOW_SCHEDULED_FILTER_VALUE) return "Filter: Scheduled Only"; // New display name
                if (filterTeamId === "") return "Filter: None"; 
                
                const team = teamOptions.find(t => t.docId === filterTeamId);
                return team ? `Filter: ${team.name}` : "Filter: Unknown";
            }, [filterTeamId, teamOptions]);


            // --- Pool Management Functions (Public Path - dependent on existing rules) ---
            const handleAddStaff = async () => {
                const id = String(newStaffId.trim());
                const name = newStaffName.trim();
                const team_id = newStaffTeamId;
                const is_buffer = newStaffType === 'buffer';

                if (!id || !name || !team_id) {
                     setError("Staff ID, Name, and Team are required.");
                     setTimeout(() => setError(null), 3000);
                     return;
                }
                
                // CRITICAL: We need to use the cleaned ID to check for duplicates in the pool
                const cleanedId = cleanStaffId(id);

                if (staffPool.find(s => s.id === cleanedId)) {
                    setError(`Staff ID ${cleanedId} already exists (or T-prefixed version exists).`);
                    setTimeout(() => setError(null), 3000);
                    return;
                }
                
                try {
                    // IMPORTANT: We use the raw input ID as the document ID in Firestore.
                    const empDocRef = getDocRef(EMPLOYEES_COLLECTION, id); 
                    if (!empDocRef) throw new Error("Could not create employee document reference.");
                    
                    await setDoc(empDocRef, { 
                        emp_id: id, 
                        name: name,
                        team_id: team_id,
                        role: 'member', 
                        is_buffer: is_buffer, 
                        docId: id // Store the document ID within the document for easy retrieval
                    });
                    
                    setNewStaffId("");
                    setNewStaffName("");
                    setNewStaffTeamId("");
                    
                    // Add the CLEANED ID to the local attendance list
                    setLocalDailyAttendance(prev => [...prev, cleanedId].sort());
                    setStatus("unsaved"); 
                    setError(null);
                } catch (err) {
                    console.error("Error adding staff: ", err);
                    setError(`Failed to add staff ID ${id}. Check data path/permissions.`);
                    setTimeout(() => setError(null), 5000);
                }
            };
            
            // **UPDATE**: Enhanced confirmation for permanent deletion.
            const handleRemoveStaff = async (staffObject) => {
                if (!db) return setError("Database not available.");
                
                // Custom confirmation dialog replacement
                const confirmDelete = window.confirm(`Are you absolutely sure you want to permanently DELETE staff ID ${staffObject.id} (${staffObject.name}) from the ENTIRE Staff Pool? This action cannot be undone.`);

                if (confirmDelete) {
                    try {
                        setStatus("deleting");
                        // 1. Remove from the Employees Collection (Pool)
                        const empDocRef = getDocRef(EMPLOYEES_COLLECTION, staffObject.docId); 
                        if (!empDocRef) throw new Error("Could not create delete document reference.");
                        await deleteDoc(empDocRef); 
                        
                        // 2. Remove from the local attendance list immediately
                        setLocalDailyAttendance(prev => prev.filter(staffId => staffId !== staffObject.id));
                        
                        // 3. Status update
                        setStatus("idle");
                        setError(null);
                    } catch (err) {
                        console.error("Error removing staff: ", err);
                        setError(`Failed to remove staff ID ${staffObject.id}. Check data path/permissions.`);
                        setStatus("error");
                        setTimeout(() => setError(null), 5000);
                    }
                }
            };

            // --- Attendance Management Functions (Root Path) ---
            const handleAttendanceToggle = (staffId) => {
                setStatus("unsaved");
                let newAttendance;
                if (scheduledSet.has(staffId)) {
                    newAttendance = localDailyAttendance.filter(id => id !== staffId);
                } else {
                    newAttendance = [...localDailyAttendance, staffId].sort();
                }
                setLocalDailyAttendance(newAttendance);
            };
            
            const handleUnscheduleAll = () => {
                const filteredIds = new Set(filteredStaff.map(s => s.id));
                const newAttendance = localDailyAttendance.filter(id => !filteredIds.has(id));
                
                setLocalDailyAttendance(newAttendance); 
                setStatus("unsaved"); 
            };
            
            const handleScheduleAll = () => {
                const filteredIds = filteredStaff.map(s => s.id);
                const combinedIds = [...new Set([...localDailyAttendance, ...filteredIds])].sort();
                
                setLocalDailyAttendance(combinedIds);
                setStatus("unsaved"); 
            };
            
            const handleSaveAttendance = async () => {
                if (!db) return setError("Database not available.");
                setStatus("saving");
                setError(null);
                try {
                    const docRef = getDocRef(DAILY_ATTENDANCE_COLLECTION, selectedDate);
                    if (!docRef) throw new Error("Could not create attendance document reference.");
                    
                    const currentStaffIds = new Set(staffPool.map(s => s.id));
                    const cleanedAttendance = localDailyAttendance
                                            .filter(id => currentStaffIds.has(id))
                                            .map(id => String(id)); 

                    await setDoc(docRef, { 
                        scheduledStaff: cleanedAttendance,
                        updatedAt: new Date().toISOString(),
                    });
                    
                    setLocalDailyAttendance(cleanedAttendance);
                    setStatus("saved");
                    setTimeout(() => setStatus("idle"), 2000);
                } catch (err) {
                    console.error("FATAL SAVE ERROR (Attendance): ", err);
                    setError("Failed to save daily attendance. Check path/permissions.");
                    setStatus("error");
                }
            };
            
            const isLoading = staffLoading;

            return (
                <div className="bg-white p-2 sm:p-6 rounded-lg shadow-lg">
                    <h2 className="text-xl font-bold mb-4 text-gray-800">1. Staff Pool & Daily Attendance Management (Merged)</h2>
                    
                    <TeamFilterModal 
                        isOpen={isModalOpen}
                        onClose={() => setIsModalOpen(false)}
                        teamOptions={teamOptions}
                        currentFilter={filterTeamId}
                        onSelectTeam={setFilterTeamId}
                    />

                    <div className="setup-tools">
                        {/* Date Selector */}
                        <div className="mb-4 date-selector flex flex-col sm:flex-row items-start sm:items-center gap-2">
                            <label htmlFor="roster-date-attendance" className="font-medium text-gray-700 text-lg">Select Roster Date:</label>
                            <input
                                type="date"
                                id="roster-date-attendance"
                                value={selectedDate}
                                onChange={(e) => setSelectedDate(e.target.value)}
                                className="border-gray-300 rounded-md shadow-sm p-2 text-lg"
                            />
                        </div>

                        {/* Add Staff Tool */}
                        <div className="flex flex-col gap-2 mb-6 p-4 border rounded-lg bg-blue-50">
                            <h3 className="text-base font-semibold text-gray-700">Add New Employee to Pool (Uses Public/Shared Path)</h3>
                            <div className="grid grid-cols-1 md:grid-cols-4 gap-2">
                                <input
                                    type="text"
                                    value={newStaffId}
                                    onChange={(e) => setNewStaffId(e.target.value)}
                                    className="p-2 border border-gray-300 rounded-md shadow-sm"
                                    placeholder="Service ID (e.g., T12268 or 12268)"
                                />
                                <input
                                    type="text"
                                    value={newStaffName}
                                    onChange={(e) => setNewStaffName(e.target.value)}
                                    className="p-2 border border-gray-300 rounded-md shadow-sm"
                                    placeholder="Employee Name (e.g., CPL (APF) JANE DOE)"
                                />
                                <select 
                                    value={newStaffTeamId}
                                    onChange={(e) => setNewStaffTeamId(e.target.value)}
                                    className="p-2 border border-gray-300 rounded-md shadow-sm bg-white"
                                    disabled={isLoading || teamOptions.length === 0}
                                >
                                    <option value="">{isLoading ? 'Loading Teams...' : 'Select Team'}</option>
                                    {teamOptions.map(t => (
                                        <option key={t.docId} value={t.docId}>{t.name}</option>
                                    ))}
                                </select>
                                <select 
                                    value={newStaffType}
                                    onChange={(e) => setNewStaffType(e.target.value)}
                                    className="p-2 border border-gray-300 rounded-md shadow-sm bg-white"
                                >
                                    <option value="permanent">Permanent</option>
                                    <option value="buffer">Buffer</option>
                                </select>
                            </div>
                            <button onClick={handleAddStaff} className="py-2 px-4 bg-green-600 text-white rounded-md shadow-md font-medium hover:bg-green-700 mt-2">Add Staff to Pool</button>
                        </div>
                    </div>
                    
                    {error && <div className="text-red-600 bg-red-100 p-3 rounded-md mb-4">{error}</div>}

                    {isLoading && <p className="text-center p-4 text-2xl text-blue-600 font-semibold">Loading Staff and Team Data...</p>}
                    
                    {!isLoading && (
                        <div className="flex flex-col gap-2 p-4 rounded-lg border border-gray-200">
                             <div className="flex flex-wrap justify-between items-center mb-4 border-b pb-2">
                                
                                <div className="flex flex-col sm:flex-row items-start sm:items-center gap-2">
                                    <span className="font-bold text-lg text-gray-800">
                                        Total Staff: {staffPool.length} | Scheduled: {localDailyAttendance.length}
                                    </span>
                                    
                                    {/* CRITICAL FIX: Filter Button with Icon and Status */}
                                    <button 
                                        onClick={() => setIsModalOpen(true)}
                                        className="filter-control-button py-2 px-4 text-sm font-semibold rounded-md shadow-sm flex items-center gap-2 transition-colors duration-150 bg-white border border-gray-300 hover:bg-gray-100"
                                    >
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707v7l-4 4v-7a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" /></svg>
                                        <span className="text-gray-800 font-bold">{currentFilterName}</span>
                                    </button>
                                </div>

                                <div className="flex space-x-2 setup-tools mt-2 sm:mt-0">
                                     <button 
                                        onClick={handleScheduleAll}
                                        disabled={status === 'saving' || filteredStaff.length === 0}
                                        className="py-2 px-4 text-sm bg-emerald-600 text-white rounded-md shadow-md hover:bg-emerald-700 disabled:bg-gray-400"
                                        title={filterTeamId ? `Schedule all ${filteredStaff.length} staff in current filter` : `Schedule all ${staffPool.length} staff`}
                                    >
                                        Schedule All ({filteredStaff.length})
                                    </button>
                                    <button 
                                        onClick={handleUnscheduleAll}
                                        disabled={status === 'saving' || filteredStaff.length === 0}
                                        className="py-2 px-4 text-sm bg-red-600 text-white rounded-md shadow-md hover:bg-red-700 disabled:bg-gray-400"
                                        title={filterTeamId ? `Unschedule all ${filteredStaff.length} staff in current filter` : `Unschedule all ${staffPool.length} staff`}
                                    >
                                    Unschedule All ({filteredStaff.length})
                                    </button>
                                </div>
                             </div>
                            
                            <div className="staff-pool-grid grid gap-3">
                                {staffPool.length === 0 && <p className="col-span-full text-center text-gray-500">No employees found in the 'employees' collection. Use 'Add New Employee to Pool' above to populate the list.</p>}
                                
                                {/* Display instruction based on filter */}
                                {filterTeamId === "" && (
                                    <p className="col-span-full text-center text-gray-500 p-8 border rounded-lg bg-gray-100">
                                        No staff visible. Click **Filter: None** to select **Show All Staff**, **Show Only Scheduled Staff**, or a specific team.
                                    </p>
                                )}
                                
                                {filteredStaff.map(staff => {
                                    const isScheduled = scheduledSet.has(staff.id);
                                    
                                    // **CRITICAL FIX: Defensive check for missing staff data**
                                    if (!staff.id || !staff.name) return null;
                                    
                                    return (
                                        <div 
                                            key={staff.id}
                                            className={`p-3 rounded-lg shadow-md transition-all flex flex-col relative ${
                                                isScheduled 
                                                ? 'staff-card-scheduled' 
                                                : 'staff-card-unscheduled'
                                            }`}
                                        >
                                            {/* Top Row: Type Badge and Remove Button */}
                                            <div className="flex justify-between items-center mb-1">
                                                <span className={`text-xs font-semibold px-2 py-0.5 rounded-full ${
                                                    staff.type === 'buffer' ? 'bg-purple-200 text-purple-800' : 'bg-blue-200 text-blue-800'
                                                }`}>
                                                    {staff.type.toUpperCase()} - {staff.team_name}
                                                </span>
                                                {/* **UPDATE**: Added specific delete button for the user's request */}
                                                <button 
                                                    // CRITICAL FIX: Pass the entire staff object for deletion (needed for docId)
                                                    onClick={(e) => { e.stopPropagation(); handleRemoveStaff(staff); }} 
                                                    className="text-red-500 hover:text-red-700 text-lg font-bold transition-opacity print-hidden p-1 -mt-2"
                                                    title={`Permanently Delete ${staff.name} (${staff.id}) from Pool`}
                                                >
                                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                                                      <path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                                    </svg>
                                                </button>
                                            </div>

                                            {/* Main Content: ID and Name */}
                                            <div className="w-full text-center py-2 border-y border-gray-200">
                                                {/* ID is primary */}
                                                <span className="text-xl font-bold text-gray-900 leading-tight block truncate" title={staff.id}>{staff.id}</span>
                                                {/* Name is secondary/extracted */}
                                                {/* Defensive rendering for name */}
                                                <p className="text-sm text-gray-500 truncate" title={staff.name}>{staff.name || 'N/A Name'}</p>
                                            </div>

                                            {/* Bottom Row: Status and Toggle Switch */}
                                            <div className="flex justify-between items-center mt-2">
                                                <p className={`text-xs font-bold ${
                                                    isScheduled ? 'text-emerald-700' : 'text-red-700'
                                                }`}>
                                                    {isScheduled ? 'SCHEDULED' : 'NOT SCHEDULED'}
                                                </p>
                                                
                                                {/* NEW: On/Off Toggle Switch */}
                                                <label className="toggle-switch" title={isScheduled ? "Unschedule Staff" : "Schedule Staff"}>
                                                    <input 
                                                        type="checkbox" 
                                                        checked={isScheduled} 
                                                        onChange={() => handleAttendanceToggle(staff.id)}
                                                    />
                                                    <span className="slider"></span>
                                                </label>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                    
                    <div className="flex justify-end items-center gap-4 mt-6 border-t pt-4 action-buttons">
                        {status === 'saved' && <span className="text-green-600">Attendance Saved!</span>}
                        {status === 'error' && <span className="text-red-600">Save failed!</span>}
                        {isLocalDataDirty && <span className="text-yellow-700">Unsaved attendance changes.</span>}
                        <button
                            onClick={handleSaveAttendance}
                            disabled={status === 'saving' || isLoading || !isLocalDataDirty}
                            className="py-2 px-6 bg-blue-600 text-white rounded-md shadow-md font-medium hover:bg-blue-700 disabled:bg-gray-400"
                        >
                            {status === 'saving' ? "Saving..." : "Save Daily Attendance"}
                        </button>
                    </div>
                </div>
            );
        }

        
        // --- Daily Assignment Component (Section 2 - Compact Grid) ---
        function DailySequenceAssignment({ selectedDate }) {
            const { scheduledStaff: allStaff = [], staffTypeMap = new Map(), loading: staffLoading, dailyAttendance } = useContext(StaffContext); 
            const [rosterMode, setRosterMode] = useState(ROSTER_MODES.AUTO_SEQUENCE); // New State for Roster Mode
            const [sequenceMap, setSequenceMap] = useState({});
            const [locationBufferMap, setLocationBufferMap] = useState({});
            const [loading, setLoading] = useState(true);
            const [status, setStatus] = useState("idle");
            const [error, setError] = useState(null);

            const allAssignmentKeys = useMemo(() => ALL_ASSIGNMENT_KEYS, []);
            
            // Locations that buffer staff can override (whole row)
            const overrideLocations = useMemo(() => [
                "E1", "PATROL 1", "E3", "N1 (CNB)", "PATROL 2", "OE/ STANDBY", VERTICAL_PROWLER_POSITION
            ], []);
            
            // CRITICAL FIX: Available keys change based on Roster Mode
            const availableAssignmentKeys = useMemo(() => {
                let sentryKeys;
                if (rosterMode === ROSTER_MODES.AUTO_SEQUENCE) {
                    // Auto-Sequence mode uses the short sequence keys (E1, OE, P2, etc.)
                    sentryKeys = SENTRY_SEQUENCE_KEYS;
                } else {
                    // Manual Fixed mode uses the full location names (E1, PATROL 1, etc.)
                    sentryKeys = SENTRY_LOCATION_KEYS;
                }
                
                // Always include Foyer and Security keys regardless of mode
                return [...sentryKeys, ...FOYER_ASSIGNMENT_KEYS, ...SECURITY_ASSIGNMENT_KEYS];
            }, [rosterMode]);
            
            const bufferStaff = useMemo(() => allStaff.filter(s => s.type === 'buffer'), [allStaff]);

            // --- 1. Load Assignments (Root Path) ---
            useEffect(() => {
                if (!selectedDate || !db) return;
                setLoading(true);
                const docRef = getDocRef(DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                if (!docRef) return;
                
                const unsubscribe = onSnapshot(docRef, (docSnap) => {
                    
                    const defaultMap = {};
                    allAssignmentKeys.forEach(key => defaultMap[key] = []); 
                    const defaultLocMap = {};

                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        
                        // Load and set the Roster Mode
                        setRosterMode(data.rosterMode || ROSTER_MODES.AUTO_SEQUENCE);
                        
                        const loadedMap = data.sequenceMap || {};
                        const scheduledSet = new Set(dailyAttendance);
                        
                        Object.keys(loadedMap).forEach(key => {
                            if (allAssignmentKeys.includes(key)) { 
                                let staffIds = Array.isArray(loadedMap[key]) ? loadedMap[key] : (loadedMap[key] ? [loadedMap[key]] : []);
                                // Filter assignments by current scheduled staff
                                staffIds = staffIds.map(id => String(id)); // Ensure string comparison
                                defaultMap[key] = staffIds.filter(id => scheduledSet.has(id));
                            }
                        });
                        setSequenceMap(defaultMap);
                        setLocationBufferMap(data.locationBufferMap || {});
                    } else {
                        setRosterMode(ROSTER_MODES.AUTO_SEQUENCE);
                        setSequenceMap(defaultMap);
                        setLocationBufferMap({});
                    }
                    setLoading(false);
                }, (err) => {
                    console.error("Error loading daily assignments: ", err);
                    setError("Failed to load daily assignments. Check authentication/permissions.");
                    setLoading(false);
                });
                
                return () => unsubscribe();
            }, [selectedDate, allAssignmentKeys, dailyAttendance]);

            // --- 2. Assignment Logic ---
            // This map needs to check against ALL assignment keys (Sequence AND Location) 
            // since data could exist from a previous mode.
            const staffToSequenceMap = useMemo(() => {
                const map = {};
                for (const key of ALL_ASSIGNMENT_KEYS) {
                    let staffIds = sequenceMap[key]; 
                    if (staffIds) {
                        if (!Array.isArray(staffIds)) staffIds = [staffIds];
                        staffIds.forEach(staffId => {
                            // Ensure only one assignment per staff member is shown in the card dropdown
                            if (!map[staffId]) {
                                map[staffId] = key; 
                            }
                        });
                    }
                }
                return map;
            }, [sequenceMap, ALL_ASSIGNMENT_KEYS]);


            const handleSequenceChange = (keyToAssign, staffId) => {
                setStatus("unsaved");
                const newMap = { ...sequenceMap };
                const staffType = staffTypeMap.get(staffId);
                
                // Clear assignment from ALL possible slots (Sequence AND Location keys)
                const allUsedKeys = ALL_ASSIGNMENT_KEYS;

                if (staffType !== 'buffer') {
                    // Remove from any other key first (for permanent staff)
                     allUsedKeys.forEach(key => {
                         if (newMap[key] && newMap[key].includes(staffId)) {
                             newMap[key] = newMap[key].filter(id => id !== staffId);
                         }
                     });
                } else {
                    // For buffer staff, we only remove them from the currently selected key
                    // if they are moving to a new key.
                    // IMPORTANT: To prevent accidental clearing of a primary assignment, we rely on the dropdown logic below
                    // which prevents multiple assignments. We only clear the current assignment if they choose a new one.
                    const currentAssignmentKey = staffToSequenceMap[staffId];
                    if (currentAssignmentKey && currentAssignmentKey !== keyToAssign && newMap[currentAssignmentKey]) {
                        newMap[currentAssignmentKey] = newMap[currentAssignmentKey].filter(id => id !== staffId);
                    }
                }

                const currentIdsInSlot = newMap[keyToAssign] || [];
                
                // Add to new slot if not already there
                if (!currentIdsInSlot.includes(staffId)) {
                    newMap[keyToAssign] = [...currentIdsInSlot, staffId];
                }
                
                setSequenceMap(newMap);
            };
            
            const handleUnassign = (staffId) => {
                setStatus("unsaved");
                const newMap = { ...sequenceMap };
                
                // Completely remove staffId from ALL slots
                ALL_ASSIGNMENT_KEYS.forEach(key => {
                     if (newMap[key] && newMap[key].includes(staffId)) {
                         newMap[key] = newMap[key].filter(id => id !== staffId);
                     }
                });
                
                setSequenceMap(newMap);
            };

            const handleLocationBufferChange = (bufferStaffId, location) => {
                setStatus("unsaved");
                const newMap = { ...locationBufferMap };
                
                if (location === "") {
                    delete newMap[bufferStaffId];
                } else {
                    newMap[bufferStaffId] = location;
                }
                setLocationBufferMap(newMap);
            };

            // **UPDATE**: Modified handleClearAll to ONLY remove assignments (sequenceMap and locationBufferMap)
            const handleClearAll = async () => {
                if (!db) return setError("Database not available.");
                
                // Use a custom confirmation dialog replacement
                const confirmClear = window.confirm("Are you sure you want to CLEAR ALL daily assignments and buffer overrides for this date? This action will NOT affect the Scheduled Staff list.");

                if (confirmClear) {
                    setStatus("saving");
                    setError(null);
                    
                    try {
                        const docRef = getDocRef(DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                        if (!docRef) throw new Error("Could not create assignment document reference.");

                        const emptySequenceMap = {};
                        ALL_ASSIGNMENT_KEYS.forEach(key => emptySequenceMap[key] = []);

                        // Only update the assignment fields, preserve other data if it exists (like rosterMode)
                        await updateDoc(docRef, {
                            sequenceMap: emptySequenceMap,
                            locationBufferMap: {},
                            updatedAt: new Date().toISOString(),
                        }, { merge: true }); // Use merge: true to avoid deleting the entire document

                        setSequenceMap(emptySequenceMap);
                        setLocationBufferMap({});
                        setStatus("saved");
                        setTimeout(() => setStatus("idle"), 2000);

                    } catch (err) {
                        console.error("Error clearing daily setup: ", err);
                        setError("Failed to clear daily assignments. Check path/permissions.");
                        setStatus("error");
                    }
                }
            };

            const handleSave = async () => {
                if (!db) return setError("Database not available.");
                setStatus("saving");
                setError(null);
                try {
                    const docRef = getDocRef(DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                    if (!docRef) throw new Error("Could not create assignment document reference.");

                    
                    // Final clean before saving (only scheduled staff remain)
                    const scheduledSet = new Set(allStaff.map(s => s.id));
                    const cleanedSequenceMap = {};
                    
                    // Only save assignments relevant to the selected mode PLUS security/foyer which are always used
                    const keysToSave = new Set(availableAssignmentKeys);
                    
                    Object.entries(sequenceMap).forEach(([key, staffIds]) => {
                        // Only save data assigned to keys relevant in the current mode (or keys in other fixed assignments)
                        if (keysToSave.has(key) || FOYER_ASSIGNMENT_KEYS.includes(key) || SECURITY_ASSIGNMENT_KEYS.includes(key)) {
                            cleanedSequenceMap[key] = staffIds.filter(id => scheduledSet.has(id));
                        }
                    });
                    
                    const cleanedLocationBufferMap = {};
                    Object.entries(locationBufferMap).forEach(([key, location]) => {
                        if (scheduledSet.has(key)) { // Key here is the buffer ID
                             cleanedLocationBufferMap[key] = location;
                        }
                    });
                    
                    await setDoc(docRef, { 
                        rosterMode: rosterMode, // CRITICAL: Save the mode
                        sequenceMap: cleanedSequenceMap,
                        locationBufferMap: cleanedLocationBufferMap 
                    });
                    
                    setSequenceMap(cleanedSequenceMap);
                    setLocationBufferMap(cleanedLocationBufferMap);
                    
                    setStatus("saved");
                    setTimeout(() => setStatus("idle"), 2000);
                } catch (err) {
                    console.error("Error saving daily setup: ", err);
                    setError("Failed to save daily assignments. Check path/permissions.");
                    setStatus("error");
                }
            };
            
            const isLoading = staffLoading || loading;
            const isDirty = status === 'unsaved';
            
            const AssignmentDropdown = ({ staffId }) => {
                const assignedKey = staffToSequenceMap[staffId] || ""; // Will be sequence key OR location name
                const staffType = staffTypeMap.get(staffId);
                const staffDetails = allStaff.find(s => s.id === staffId);
                
                // Defensive check
                if (!staffDetails || !staffDetails.id) return null; 
                
                // --- Group Assignments based on current mode ---
                const isAutoMode = rosterMode === ROSTER_MODES.AUTO_SEQUENCE;
                
                const currentSentryKeys = isAutoMode ? SENTRY_SEQUENCE_KEYS : SENTRY_LOCATION_KEYS;
                
                const sentryAssignmentKeys = availableAssignmentKeys.filter(key => 
                    currentSentryKeys.includes(key)
                ).sort();
                const foyerAssignmentKeys = availableAssignmentKeys.filter(key => FOYER_ASSIGNMENT_KEYS.includes(key)).sort();
                const securityAssignmentKeys = availableAssignmentKeys.filter(key => SECURITY_ASSIGNMENT_KEYS.includes(key)).sort();
                
                const isSentryAssignment = sentryAssignmentKeys.includes(assignedKey);
                const isFoyerAssignment = foyerAssignmentKeys.includes(assignedKey);
                const isSecurityAssignment = securityAssignmentKeys.includes(assignedKey);
                const isMultiple = assignedKey.includes(','); // Should not happen with current logic, but check anyway

                let colorClass = 'bg-white';
                if (staffType === 'buffer' && assignedKey) {
                    colorClass = 'bg-purple-100 border-purple-300';
                }
                else if (isSentryAssignment) colorClass = 'bg-blue-100 border-blue-300';
                else if (isFoyerAssignment) colorClass = 'bg-green-100 border-green-300';
                else if (isSecurityAssignment) colorClass = 'bg-orange-100 border-orange-300';
                else colorClass = 'bg-gray-50 border-gray-300';
                
                // --- Option Rendering Logic (CRITICAL FIX) ---
                const renderOptions = (keys) => {
                    return keys.map(key => {
                        const staffIdsInSlot = sequenceMap[key] || [];
                        const isThisStaffInSlot = staffIdsInSlot.includes(staffId);
                        
                        let isDisabled = false;
                        const currentScheduledStaffInSlot = staffIdsInSlot.filter(id => allStaff.some(s => s.id === id));
                        
                        // Check occupancy rules for non-selected slots
                        if (!isThisStaffInSlot && currentScheduledStaffInSlot.length > 0) {
                            const typesInSlot = currentScheduledStaffInSlot.map(id => staffTypeMap.get(id));
                            
                            if (staffType === 'permanent' || !staffType) {
                                // Permanent staff cannot take occupied slot
                                isDisabled = true;
                            } else if (staffType === 'buffer') {
                                // Buffer can only join a slot with one permanent staff
                                const permCount = typesInSlot.filter(t => t === 'permanent' || !t).length;
                                const bufferCount = typesInSlot.filter(t => t === 'buffer').length;
                                
                                // If the slot already has a permanent and a buffer, or two buffers, deny.
                                if ((permCount >= 1 && bufferCount >= 1) || bufferCount >= 2) {
                                    isDisabled = true;
                                }
                            }
                        }
                        
                        return (
                            <option key={key} value={key} disabled={isDisabled} className="truncate">
                                {key} {currentScheduledStaffInSlot.length > 0 ? `(${currentScheduledStaffInSlot.length} taken)` : ""}
                            </option>
                        );
                    });
                };


                return (
                    <div 
                        key={staffId}
                        className={`p-2 border rounded-lg flex items-start justify-between transition-all ${colorClass}`}
                    >
                        {/* CRITICAL LAYOUT FIX: Use pt-1 for slight vertical alignment and fixed width distribution */}
                        <div className="flex flex-col items-start gap-0 min-w-[50%] max-w-[55%] pt-1"> 
                            {/* Display ID and Name */}
                            <span className="text-base font-bold text-gray-900 leading-tight block truncate" title={staffDetails.id}>{staffDetails.id}</span>
                            {/* Name is secondary/extracted */}
                            {/* Defensive rendering for name */}
                            <p className="text-sm text-gray-500 truncate" title={staffDetails.name}>{staffDetails.name || 'N/A Name'}</p>
                            {staffType === 'buffer' && (
                                <span className="text-xs font-semibold px-1 py-0.5 rounded-full bg-purple-200 text-purple-800 mt-1">
                                    {staffType.toUpperCase()}
                                </span>
                            )}
                        </div>
                        <select
                            value={assignedKey}
                            onChange={(e) => {
                                const newKey = e.target.value;
                                if (newKey === "") {
                                    handleUnassign(staffId);
                                } else {
                                    handleSequenceChange(newKey, staffId);
                                }
                            }}
                            className="p-1 border border-gray-400 rounded-md shadow-sm w-[40%] text-xs truncate bg-white font-semibold"
                        >
                            <option value="">{UNASSIGNED_KEY}</option>
                            
                            {isMultiple && (
                                <option value={assignedKey} disabled>{assignedKey} (Multiple)</option>
                            )}
                            
                            {/* Grouped Options for clarity */}
                            <optgroup label={isAutoMode ? "SENTRY (Rotation Key)" : "SENTRY (Fixed Location)"}>
                                {renderOptions(sentryAssignmentKeys)}
                            </optgroup>

                            <optgroup label="FOYER">
                                {renderOptions(foyerAssignmentKeys)}
                            </optgroup>

                            <optgroup label="SECURITY">
                                {renderOptions(securityAssignmentKeys)}
                            </optgroup>
                            
                        </select>
                    </div>
                );
            };

            return (
                <div className="bg-white p-2 sm:p-6 rounded-lg shadow-lg">
                    <h2 className="text-xl font-bold mb-4 text-gray-800">2. Daily Assignment Setup</h2>
                    
                    {error && <div className="text-red-600 bg-red-100 p-3 rounded-md mb-4">{error}</div>}
                    
                    {/* NEW: Roster Mode Selector */}
                    <div className="roster-mode-selector p-4 mb-6 border rounded-lg bg-yellow-50 shadow-inner">
                        <h3 className="text-base font-semibold text-gray-700 mb-2">Roster Generation Mode:</h3>
                        <p className="text-sm text-gray-600 mb-3 font-medium">This controls the core rostering logic for Sentry and Patrol positions.</p>
                        <div className="radio-group flex flex-wrap gap-4">
                            <input type="radio" id="mode-auto" name="rosterMode" value={ROSTER_MODES.AUTO_SEQUENCE} 
                                checked={rosterMode === ROSTER_MODES.AUTO_SEQUENCE} 
                                onChange={(e) => { setRosterMode(e.target.value); setStatus("unsaved"); }}
                                className="hidden"
                            />
                            <label htmlFor="mode-auto" className="cursor-pointer border border-blue-300 rounded-md py-2 px-4 text-sm font-semibold text-blue-800 bg-white hover:bg-blue-50 transition-all">
                                Auto-Sequence (Standard Rotation)
                                <p className="text-xs font-normal text-gray-500 mt-1">Assign staff to sequence keys (E1, OE, P2, etc.) for rotation.</p>
                            </label>

                            <input type="radio" id="mode-manual" name="rosterMode" value={ROSTER_MODES.MANUAL_LOCATION_FIXED} 
                                checked={rosterMode === ROSTER_MODES.MANUAL_LOCATION_FIXED} 
                                onChange={(e) => { setRosterMode(e.target.value); setStatus("unsaved"); }}
                                className="hidden"
                            />
                            <label htmlFor="mode-manual" className="cursor-pointer border border-blue-300 rounded-md py-2 px-4 text-sm font-semibold text-blue-800 bg-white hover:bg-blue-50 transition-all">
                                Manual (Fixed Location All Night)
                                <p className="text-xs font-normal text-gray-500 mt-1">Assign staff directly to a location (E1, PATROL 1, etc.) for the whole shift.</p>
                            </label>
                        </div>
                    </div>
                    
                    <p className="text-gray-600 mb-4 text-sm font-bold bg-green-50 p-3 rounded-md border border-green-300">
                        Showing only **{allStaff.length}** staff members who are **SCHEDULED** for {selectedDate}. Select their primary assignment.
                    </p>
                    
                    {isLoading && <p className="text-center p-4 text-blue-600 font-semibold">Loading Assignments...</p>}
                    
                    {/* CRITICAL CHANGE: Responsive Grid */}
                    {!isLoading && (
                        <div className="assignment-grid grid gap-3">
                            {allStaff.length === 0 && <p className="text-gray-500 col-span-full">No staff are scheduled for this date (Check Section 1).</p>}
                            {allStaff.map(staff => (
                                <AssignmentDropdown key={staff.id} staffId={staff.id} />
                            ))}
                        </div>
                    )}
                    
                    {/* --- Buffer Overrides (Section 3) --- */}
                    <div className="mt-8 border-t pt-6">
                        <h3 className="text-lg font-bold mb-4 text-gray-800">3. Buffer Location Override (Whole Shift)</h3>
                        <p className="text-gray-600 mb-4 text-sm">
                            Select a Buffer staff (from the scheduled list) to cover an entire location (Row) for the whole night, **overriding all other logic** for that row. 
                        </p>
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 bg-gray-50 p-4 rounded-lg border">
                             {bufferStaff.map(b => (
                                 <div key={b.id} className="flex flex-col gap-1">
                                     <label className="text-xs font-bold text-gray-600 uppercase">{b.name} ({b.id})</label>
                                     <select
                                        value={locationBufferMap[b.id] || ""} // Use staff ID as key for simplicity here
                                        onChange={(e) => handleLocationBufferChange(b.id, e.target.value)}
                                        className={`p-2 border border-gray-300 rounded-md text-sm ${locationBufferMap[b.id] ? 'bg-purple-100 border-purple-400 text-purple-900 font-bold' : 'bg-white'}`}
                                     >
                                         <option value="">-- No Override Location --</option>
                                         {overrideLocations.map(loc => (
                                              <option key={loc} value={loc}>{loc}</option>
                                         ))}
                                     </select>
                                 </div>
                             ))}
                        </div>
                    </div>
                    
                    {/* --- Save Controls --- */}
                    <div className="flex justify-end items-center gap-4 mt-6 border-t pt-4 action-buttons">
                        {/* **UPDATE**: Clear All button now uses the updated function */}
                        <button
                            onClick={handleClearAll}
                            disabled={status === 'saving' || isLoading}
                            className="py-2 px-4 bg-red-500 text-white rounded-md shadow-md font-medium hover:bg-red-600 disabled:bg-gray-400"
                        >
                            Clear All Assignments
                        </button>

                        <div className="flex items-center gap-4">
                            {status === 'saved' && <span className="text-green-600">Assignments Saved!</span>}
                            {status === 'error' && <span className="text-red-600">Save failed!</span>}
                            {isDirty && <span className="text-yellow-700">Unsaved changes.</span>}
                            <button
                                onClick={handleSave}
                                disabled={status === 'saving' || isLoading || !isDirty}
                                className="py-2 px-6 bg-blue-600 text-white rounded-md shadow-md font-medium hover:bg-blue-700 disabled:bg-gray-400"
                            >
                                {status === 'saving' ? "Saving..." : "Save Daily Assignments"}
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        // --- View 2: Roster View (Sequence Logic) ---
        function RosterView({ selectedDate, setSelectedDate }) {
            // Variables are destructure here, correctly, at the top level
            const { staffTypeMap, scheduledStaff } = useContext(StaffContext); 
            const [rosterData, setRosterData] = useState(null);
            const [dailyAssignments, setDailyAssignments] = useState(null); 
            const [loading, setLoading] = useState(true);
            const [isGenerating, setIsGenerating] = useState(false); // NEW: State for generation status
            const [error, setError] = useState(null);
            const [isDirty, setIsDirty] = useState(false);
            
            const [highlightedId, setHighlightedId] = useState(null);
            const [focusView, setFocusView] = useState('all');
            
            // NEW: Matrix Editing Mode State
            const [isMatrixEditMode, setIsMatrixEditMode] = useState(false);

            const handlePrint = () => {
                window.print();
            };
            
            useEffect(() => {
                if (!selectedDate || !db) return; 
                setLoading(true);
                setError(null);
                setIsDirty(false);
                setHighlightedId(null);
                setFocusView('all');

                const assignmentsDocRef = getDocRef(DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                const unsubAssignments = onSnapshot(assignmentsDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        setDailyAssignments(docSnap.data());
                    } else {
                        setDailyAssignments(null);
                    }
                }, (err) => {
                    console.error("Error loading assignments: ", err);
                    setError("Failed to load daily assignments. Check authentication/permissions.");
                });

                const rosterDocRef = getDocRef(DAILY_ROSTER_COLLECTION, selectedDate);
                const unsubRoster = onSnapshot(rosterDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const loadedGrid = docSnap.data().rosterGrid || {};
                        const newRosterData = {};
                        Object.keys(loadedGrid).forEach(pos => {
                            if(Array.isArray(loadedGrid[pos])) {
                                newRosterData[pos] = loadedGrid[pos].map(cell => {
                                    if (typeof cell === 'string' || !cell) {
                                        // Ensure basic cell structure when loading old strings
                                        return { value: cell || "", isAutomated: false }; 
                                    }
                                    return cell;
                                });
                            }
                        });
                        setRosterData(newRosterData);
                    } else {
                        setRosterData(null);
                    }
                    setLoading(false);
                }, (err) => {
                    console.error("Error loading roster: ", err);
                    setError("Failed to load roster data. Check authentication/permissions.");
                    setLoading(false);
                });
                
                return () => {
                    unsubAssignments();
                    unsubRoster();
                };
            }, [selectedDate]);
            
            const manualStandbyRows = useMemo(() => {
                // CRITICAL FIX: Ensure rosterData is an object before accessing keys
                if (!rosterData || typeof rosterData !== 'object') { return []; }
                return Object.keys(rosterData)
                    .filter(key => key.startsWith("OE/ STANDBY-"))
                    .sort(); 
            }, [rosterData]);
            
            const sentryRowsToRender = useMemo(() => {
                 const sentryRows = [...SENTRY_POSITIONS];
                 const standbyRowIndex = sentryRows.indexOf("OE/ STANDBY");
                 if(standbyRowIndex > -1) {
                     sentryRows.splice(standbyRowIndex + 1, 0, ...manualStandbyRows);
                 }
                 return sentryRows;
            }, [manualStandbyRows]);


            const handleGenerateRoster = async (isReset = false) => {
                setIsGenerating(true); // Start generating state
                setError(null);
                
                if (!db) { setError("Database not available."); setIsGenerating(false); return; }
                
                if (!dailyAssignments || !dailyAssignments.sequenceMap || !staffTypeMap || staffTypeMap.size === 0) {
                    setError("No assignments or staff types found. Please check Setup and wait for data.");
                    setIsGenerating(false);
                    return;
                }
                
                try {
                    const { sequenceMap, locationBufferMap = {}, rosterMode = ROSTER_MODES.AUTO_SEQUENCE } = dailyAssignments;
                    
                    // Only merge if not resetting the grid entirely
                    const newRosterGrid = (rosterData && !isReset) ? { ...rosterData } : {};
                    
                    const PATROL_1 = "PATROL 1";
                    const PATROL_2 = "PATROL 2";
                    const PERIMETER_1ST_HALF = "PERIMETER PROWLER (1st Half)";
                    const PERIMETER_2ND_HALF = "PERIMETER PROWLER (2nd Half)";


                    // --- 1. SENTRY DEPLOYMENT (Dynamic based on Roster Mode) ---
                    SENTRY_POSITIONS.forEach(pos => {
                        const positionRoster = [];
                        
                        // Skip the Prowler rows for now, as they are populated in step 2.
                        if (pos.startsWith("PERIMETER PROWLER")) return;

                        if (rosterMode === ROSTER_MODES.AUTO_SEQUENCE) {
                            // --- AUTO-SEQUENCE MODE LOGIC (Rotation) ---
                            const letterSequence = SENTRY_POSITION_SEQUENCES[pos]; 
                            
                            if (letterSequence) { 
                                for (let timeIndex = 0; timeIndex < TIME_SLOTS.length; timeIndex++) {
                                    const sequenceKey = letterSequence[timeIndex % 6];
                                    
                                    let idsInSlot = sequenceMap[sequenceKey];
                                    if (!Array.isArray(idsInSlot)) idsInSlot = idsInSlot ? [idsInSlot] : [];

                                    const permanentStaff = idsInSlot.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                                    const bufferStaff = idsInSlot.find(id => staffTypeMap.get(id) === 'buffer');
                                    
                                    const oldCellData = (newRosterGrid[pos] && newRosterGrid[pos][timeIndex]) ? newRosterGrid[pos][timeIndex] : {};
                                    
                                    if (bufferStaff && permanentStaff !== UNFILLED_SLOT) {
                                        positionRoster.push({
                                            isAutomated: true, permanent: permanentStaff, buffer: bufferStaff,
                                            value: (oldCellData.value === permanentStaff || oldCellData.value === bufferStaff) ? oldCellData.value : permanentStaff,
                                            isPair: true
                                        });
                                    } else {
                                        const onlyStaff = idsInSlot.find(id => id !== UNFILLED_SLOT) || UNFILLED_SLOT;
                                        positionRoster.push({
                                            isAutomated: true, permanent: permanentStaff, buffer: bufferStaff || null,
                                            value: onlyStaff, isPair: false
                                        });
                                    }
                                }
                                newRosterGrid[pos] = positionRoster;
                            }
                        } else {
                            // --- MANUAL-LOCATION-FIXED MODE LOGIC (Whole Shift) ---
                            let idsInSlot = sequenceMap[pos]; // Look up by location name itself
                            if (!Array.isArray(idsInSlot)) idsInSlot = idsInSlot ? [idsInSlot] : [];

                            const permanentStaff = idsInSlot.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                            const bufferStaff = idsInSlot.find(id => staffTypeMap.get(id) === 'buffer');

                            const isPair = bufferStaff && permanentStaff !== UNFILLED_SLOT;
                            const value = permanentStaff !== UNFILLED_SLOT ? permanentStaff : (bufferStaff || UNFILLED_SLOT);
                            
                            for (let timeIndex = 0; timeIndex < TIME_SLOTS.length; timeIndex++) {
                                positionRoster.push({
                                    isAutomated: true, permanent: permanentStaff, buffer: bufferStaff || null,
                                    value: value, isPair: isPair,
                                    isFixed: true // Flag for manual mode clarity
                                });
                            }
                            newRosterGrid[pos] = positionRoster;
                        }
                    });
                    
                    // --- 2. PERIMETER PROWLER ASSIGNMENT (Slot-by-Slot Copy from P1/P2) ---
                    
                    // CRITICAL: Ensure source patrol data exists before trying to copy
                    // The source data needs to be the newly generated data in newRosterGrid
                    const patrol1Roster = newRosterGrid[PATROL_1] || Array(TIME_SLOTS.length).fill({ value: UNFILLED_SLOT, isAutomated: true });
                    const patrol2Roster = newRosterGrid[PATROL_2] || Array(TIME_SLOTS.length).fill({ value: UNFILLED_SLOT, isAutomated: true });
                    
                    // 1st Half Prowler (P1 assignments copied across ALL 12 slots)
                    const prowler1stHalf = Array(TIME_SLOTS.length).fill(null).map((_, index) => {
                        const existingCell = (newRosterGrid[PERIMETER_1ST_HALF] && newRosterGrid[PERIMETER_1ST_HALF][index]);
                        if (existingCell && existingCell.isAutomated === false && !isReset) {
                             return existingCell; // Preserve manual change
                        }

                        // Copy data from the PATROL 1 row for this specific time slot
                        const sourceCell = patrol1Roster[index] || { value: UNFILLED_SLOT };
                         
                        return { 
                            value: sourceCell.value || UNFILLED_SLOT, 
                            isAutomated: true, 
                            isSourceProwler: true,
                            permanent: sourceCell.permanent || sourceCell.value || UNFILLED_SLOT,
                            buffer: sourceCell.buffer || null,
                            isPair: sourceCell.isPair || false
                        };
                    });
                    newRosterGrid[PERIMETER_1ST_HALF] = prowler1stHalf;

                    // 2nd Half Prowler (P2 assignments copied across ALL 12 slots)
                    const prowler2ndHalf = Array(TIME_SLOTS.length).fill(null).map((_, index) => {
                        const existingCell = (newRosterGrid[PERIMETER_2ND_HALF] && newRosterGrid[PERIMETER_2ND_HALF][index]);
                        if (existingCell && existingCell.isAutomated === false && !isReset) {
                            return existingCell; // Preserve manual change
                        }

                        // Copy data from the PATROL 2 row for this specific time slot
                        const sourceCell = patrol2Roster[index] || { value: UNFILLED_SLOT };

                        return { 
                            value: sourceCell.value || UNFILLED_SLOT, 
                            isAutomated: true, 
                            isSourceProwler: true,
                            permanent: sourceCell.permanent || sourceCell.value || UNFILLED_SLOT,
                            buffer: sourceCell.buffer || null,
                            isPair: sourceCell.isPair || false
                        };
                    });
                    newRosterGrid[PERIMETER_2ND_HALF] = prowler2ndHalf;
                    // --- End PERIMETER PROWLER ASSIGNMENT ---


                    // --- 3. FOYER DEPLOYMENT (Always follows fixed pattern) ---
                    let foyer1_ids = sequenceMap["FOYER 1"];
                    if (!Array.isArray(foyer1_ids)) foyer1_ids = foyer1_ids ? [foyer1_ids] : [];
                    let foyer2_ids = sequenceMap["FOYER 2"];
                    if (!Array.isArray(foyer2_ids)) foyer2_ids = foyer2_ids ? [foyer2_ids] : [];

                    const staffA_perm = foyer1_ids.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const staffA_buff = foyer1_ids.find(id => staffTypeMap.get(id) === 'buffer');
                    const staffB_perm = foyer2_ids.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const staffB_buff = foyer2_ids.find(id => staffTypeMap.get(id) === 'buffer');

                    const xraySequence = [];
                    const foyerOESequence = [];
                    
                    for (let i = 0; i < 12; i++) {
                        const isSlotA = !((i >= 3 && i <= 5) || (i >= 9));
                        
                        const permanentStaffA = isSlotA ? staffA_perm : staffB_perm;
                        const bufferStaffA = isSlotA ? staffA_buff : staffB_buff;
                        const permanentStaffB = isSlotA ? staffB_perm : staffA_perm;
                        const bufferStaffB = isSlotA ? staffB_buff : staffA_buff;
                        
                        const isPairA = bufferStaffA && permanentStaffA !== UNFILLED_SLOT;
                        const isPairB = bufferStaffB && permanentStaffB !== UNFILLED_SLOT;

                        const oldXrayCell = (newRosterGrid["XRAY-VISITOR"] && newRosterGrid["XRAY-VISITOR"][i]) ? newRosterGrid["XRAY-VISITOR"][i] : {};
                        const oldOECell = (newRosterGrid["FOYER-OE"] && newRosterGrid["FOYER-OE"][i]) ? newRosterGrid["FOYER-OE"][i] : {};
                        
                        // XRAY (Post A)
                        if (isPairA) {
                            xraySequence.push({ isAutomated: true, permanent: permanentStaffA, buffer: bufferStaffA, value: (oldXrayCell.value === permanentStaffA || oldXrayCell.value === bufferStaffA) ? oldXrayCell.value : permanentStaffA, isPair: true });
                        } else {
                            const onlyStaff = permanentStaffA !== UNFILLED_SLOT ? permanentStaffA : (bufferStaffA || UNFILLED_SLOT);
                            xraySequence.push({ isAutomated: true, permanent: permanentStaffA, buffer: bufferStaffA || null, value: onlyStaff, isPair: false });
                        }
                        
                        // FOYER-OE (Post B)
                        if (isPairB) {
                             foyerOESequence.push({ isAutomated: true, permanent: permanentStaffB, buffer: bufferStaffB, value: (oldOECell.value === permanentStaffB || oldOECell.value === bufferStaffB) ? oldOECell.value : permanentStaffB, isPair: true });
                        } else {
                            const onlyStaff = permanentStaffB !== UNFILLED_SLOT ? permanentStaffB : (bufferStaffB || UNFILLED_SLOT);
                            foyerOESequence.push({ isAutomated: true, permanent: permanentStaffB, buffer: bufferStaffB || null, value: onlyStaff, isPair: false });
                        }
                    }

                    // --- 6-SLOT Vertical Prowler (Uses Foyer-OE Staff for rotation) ---
                    const existingProwlerData = newRosterGrid[VERTICAL_PROWLER_POSITION] || [];
                    const verticalProwlerSequence = [
                        foyerOESequence[0],  foyerOESequence[2], foyerOESequence[4], foyerOESequence[6], foyerOESequence[8], foyerOESequence[10]
                    ];
                    
                    // Remove staff from Foyer-OE positions they are taking up
                    [0, 2, 4, 6, 8, 10].forEach(i => {
                        foyerOESequence[i] = { ...foyerOESequence[i], value: UNFILLED_SLOT, isPair: false, permanent: UNFILLED_SLOT, buffer: null };
                    });
                    
                    newRosterGrid["XRAY-VISITOR"] = xraySequence;
                    newRosterGrid["FOYER-OE"] = foyerOESequence;
                    
                    // Preserve Manual Edit for VP slot 2 (23:00) if it exists
                    const vpManualIndex = 2;
                    if (existingProwlerData[vpManualIndex] && !existingProwlerData[vpManualIndex].isAutomated) {
                        verticalProwlerSequence[vpManualIndex] = existingProwlerData[vpManualIndex];
                    }

                    newRosterGrid[VERTICAL_PROWLER_POSITION] = verticalProwlerSequence.map(cell => ({...cell, isAutomated: true})); 


                    // --- 4. SECURITY CONTROL OFFICE (Fixed all night) ---
                    let leaderIds = sequenceMap["TEAM LEADER (I/C)"];
                    if (!Array.isArray(leaderIds)) leaderIds = leaderIds ? [leaderIds] : [];
                    let icIds = sequenceMap["SECTION I/C"];
                    if (!Array.isArray(icIds)) icIds = icIds ? [icIds] : [];

                    const teamLeaderId = leaderIds.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const sectionIcId = icIds.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const bufferLeader = leaderIds.find(id => staffTypeMap.get(id) === 'buffer');
                    const bufferIc = icIds.find(id => staffTypeMap.get(id) === 'buffer');
                    
                    const isPairLeader = bufferLeader && teamLeaderId !== UNFILLED_SLOT;
                    const isPairIc = bufferIc && sectionIcId !== UNFILLED_SLOT;
                    
                    newRosterGrid["TEAM LEADER (I/C)"] = Array(TIME_SLOTS.length).fill(null).map((_, i) => {
                        const oldCell = (newRosterGrid["TEAM LEADER (I/C)"] && newRosterGrid["TEAM LEADER (I/C)"][i]) ? newRosterGrid["TEAM LEADER (I/C)"][i] : {};
                        if (isPairLeader) {
                            return { isAutomated: true, permanent: teamLeaderId, buffer: bufferLeader, value: (oldCell.value === teamLeaderId || oldCell.value === bufferLeader) ? oldCell.value : teamLeaderId, isPair: true };
                        }
                        const onlyStaff = teamLeaderId !== UNFILLED_SLOT ? teamLeaderId : (bufferLeader || UNFILLED_SLOT);
                        return { isAutomated: true, permanent: teamLeaderId, buffer: bufferLeader || null, value: onlyStaff, isPair: false };
                    });
                    newRosterGrid["SECTION I/C"] = Array(TIME_SLOTS.length).fill(null).map((_, i) => {
                        const oldCell = (newRosterGrid["SECTION I/C"] && newRosterGrid["SECTION I/C"][i]) ? newRosterGrid["SECTION I/C"][i] : {};
                        if (isPairIc) {
                            return { isAutomated: true, permanent: sectionIcId, buffer: bufferIc, value: (oldCell.value === sectionIcId || oldCell.value === bufferIc) ? oldCell.value : sectionIcId, isPair: true };
                        }
                        const onlyStaff = sectionIcId !== UNFILLED_SLOT ? sectionIcId : (bufferIc || UNFILLED_SLOT);
                        return { isAutomated: true, permanent: sectionIcId, buffer: bufferIc || null, value: onlyStaff, isPair: false };
                    });
                    
                    // --- 5. APPLY LOCATION BUFFER OVERRIDES (Overrides all previous logic) ---
                    if (locationBufferMap && Object.keys(locationBufferMap).length > 0) {
                        Object.entries(locationBufferMap).forEach(([bufferId, location]) => {
                             if (newRosterGrid[location]) {
                                 newRosterGrid[location] = newRosterGrid[location].map((cell, index) => {
                                     const permanentStaff = cell.permanent || (cell.value !== bufferId ? cell.value : UNFILLED_SLOT);
                                     
                                     // This logic ensures the permanent staff is placed back on OE/STANDBY if their location is overridden
                                     if (location === "OE/ STANDBY") {
                                          return { ...cell, permanent: UNFILLED_SLOT, buffer: bufferId, isPair: false, value: bufferId, isAutomated: true };
                                     }
                                     
                                     if (permanentStaff !== UNFILLED_SLOT && permanentStaff !== "") {
                                         // Overriding location is a pair (permanent staff stays, buffer acts as dedicated support)
                                         return { ...cell, permanent: permanentStaff, buffer: bufferId, isPair: true, value: permanentStaff };
                                     } else {
                                         // Overriding location has no permanent staff, so buffer takes it solo
                                         return { ...cell, permanent: UNFILLED_SLOT, buffer: bufferId, isPair: false, value: bufferId, isAutomated: true };
                                     }
                                 });
                             }
                        });
                    }
                    
                    const finalRosterGrid = sanitizeForFirestore(newRosterGrid);

                    const docRef = getDocRef(DAILY_ROSTER_COLLECTION, selectedDate);
                    await setDoc(docRef, { rosterGrid: finalRosterGrid, updatedAt: new Date().toISOString() });
                    
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists()) {
                         setRosterData(docSnap.data().rosterGrid || {});
                    }
                    
                    setIsDirty(false);
                    setIsGenerating(false); // Stop generating state
                    
                } catch (err) {
                    console.error("Error generating roster:", err);
                    setError("Failed to generate roster. Check console for details.");
                    setIsGenerating(false); // Stop generating state on error
                }
            };
            
            const handleSaveChanges = async () => {
                if (!rosterData || !isDirty) return;
                if (!db) return setError("Database not available.");
                setLoading(true);
                setError(null);
                try {
                    const cleanRosterData = { ...rosterData };
                    const allKeys = Object.keys(cleanRosterData);
                    
                    const existingRows = [
                        ...SECURITY_POSITIONS, ...FOYER_POSITIONS, VERTICAL_PROWLER_POSITION, ...SENTRY_POSITIONS, ...manualStandbyRows
                    ];
                    
                    allKeys.forEach(key => {
                        // Check if a manual standby row is empty across all slots, and if so, delete it.
                        if (key.startsWith("OE/ STANDBY-")) {
                            const row = cleanRosterData[key];
                            const isEmpty = row.every(cell => !cell.value || cell.value === UNFILLED_SLOT || cell.value === "");
                            if (isEmpty) {
                                delete cleanRosterData[key];
                            }
                        }
                    });

                    // CRITICAL: If Matrix Edit Mode was used, we need to ensure the automated flags are cleared
                    if (isMatrixEditMode) {
                         Object.keys(cleanRosterData).forEach(pos => {
                             if (cleanRosterData[pos] && Array.isArray(cleanRosterData[pos])) {
                                 cleanRosterData[pos] = cleanRosterData[pos].map(cell => ({
                                     // Preserve the user's manual value and ensure automation is off
                                     ...cell,
                                     value: cell.value || UNFILLED_SLOT,
                                     isAutomated: false,
                                     isFixed: true // Mark as manually fixed data
                                 }));
                             }
                         });
                    }

                    const finalCleanData = sanitizeForFirestore(cleanRosterData);

                    const docRef = getDocRef(DAILY_ROSTER_COLLECTION, selectedDate);
                    await setDoc(docRef, { rosterGrid: finalCleanData, updatedAt: new Date().toISOString() });
                    setIsDirty(false);
                    setLoading(false);
                } catch (err) {
                    console.error("Error saving changes: ", err);
                    setError("Failed to save changes. Check console for details.");
                    setLoading(false);
                }
            };

            const handleCellChange = (position, timeIndex, newValue) => {
                setRosterData(prevRoster => {
                    const newRoster = { ...prevRoster };
                    
                    if (!newRoster[position]) {
                        newRoster[position] = Array(TIME_SLOTS.length).fill(null).map(() => ({ value: "", isAutomated: false }));
                    }
                    if (!newRoster[position][timeIndex]) {
                         newRoster[position][timeIndex] = { value: "", isAutomated: false };
                    }
                    
                    const cell = newRoster[position][timeIndex];
                    const oldValue = cell.value;
                    
                    // Mark cell as NOT automated if changed in Matrix Edit Mode or if it's a manual standby row
                    newRoster[position][timeIndex] = { 
                        ...cell, 
                        value: newValue, 
                        isAutomated: isMatrixEditMode ? false : (cell.isAutomated && (cell.isPair || cell.isFixed)) 
                    };
                    
                    const permanentId = cell.permanent;
                    const bufferId = cell.buffer;
                    
                    // Logic for displacing staff when a pair is manually split (Only relevant if not in Matrix Edit Mode)
                    if (!isMatrixEditMode && cell.isPair && permanentId && bufferId) {
                        // Case 1: Perm staff is replaced by Buffer staff (Perm staff displaced)
                        if (newValue === bufferId && oldValue === permanentId) {
                            placeDisplacedStaff(newRoster, permanentId, timeIndex);
                        }
                        // Case 2: Buffer staff is replaced by Perm staff (Buffer staff was displaced, now returns)
                        if (newValue === permanentId && oldValue === bufferId) {
                            removeDisplacedStaff(newRoster, permanentId, timeIndex);
                        }
                    }

                    return newRoster;
                });
                setIsDirty(true);
            };
            
            const placeDisplacedStaff = (roster, staffId, timeIndex) => {
                // Find or create an OE/STANDBY slot for the displaced staff
                const allRows = Object.keys(roster).filter(key => key.startsWith("OE/ STANDBY"));
                allRows.sort((a, b) => {
                    if (a === "OE/ STANDBY") return -1;
                    if (b === "OE/ STANDBY") return 1;
                    const numA = parseInt(a.split('-')[1] || 999);
                    const numB = parseInt(b.split('-')[1] || 999);
                    return numA - numB;
                });
                
                for (const rowName of allRows) {
                    const row = roster[rowName];
                    if (row && row[timeIndex]) {
                        const cell = row[timeIndex];
                        if (!cell.value || cell.value === UNFILLED_SLOT || cell.value === "") {
                            // OE/ STANDBY is the primary standby row, others are manual
                            if (rowName === "OE/ STANDBY") {
                                roster[rowName][timeIndex] = { ...cell, value: staffId, isDisplaced: true, isAutomated: cell.isAutomated };
                            } else {
                                roster[rowName][timeIndex] = { value: staffId, isAutomated: false };
                            }
                            return;
                        }
                    }
                }
                
                // If no standby slot is available, create a new manual standby row
                let nextNum = 2;
                while (roster[`OE/ STANDBY-${nextNum}`]) {
                    nextNum++;
                }
                const newRowName = `OE/ STANDBY-${nextNum}`;
                
                const newRow = Array(TIME_SLOTS.length).fill(null).map(() => ({ value: "", isAutomated: false }));
                newRow[timeIndex] = { value: staffId, isAutomated: false };
                roster[newRowName] = newRow;
            };

            const removeDisplacedStaff = (roster, staffId, timeIndex) => {
                 // Remove staff ID from all OE/STANDBY rows for this time slot
                 const allRows = Object.keys(roster).filter(key => key.startsWith("OE/ STANDBY"));
                 
                 for (const rowName of allRows) {
                    const row = roster[rowName];
                    if (row && row[timeIndex]) {
                         const cell = row[timeIndex];
                         if (cell.value === staffId) {
                             if (rowName === "OE/ STANDBY") {
                                // For the auto OE row, revert to permanent staff (or UNFILLED) if the displaced staff (which is the permanent staff) is the one returning.
                                roster[rowName][timeIndex] = { ...cell, value: cell.permanent || UNFILLED_SLOT, isDisplaced: false };
                            } else {
                                // For manual rows, just clear the cell
                                roster[rowName][timeIndex] = { ...cell, value: "" };
                            }
                            return;
                        }
                    }
                 }
            };

            
            const handleCellClick = (value) => {
                if (!value || value === UNFILLED_SLOT) {
                    setHighlightedId(null);
                    return;
                }
                if (value === highlightedId) {
                    setHighlightedId(null);
                } else {
                    setHighlightedId(value);
                }
            };
            
            const handleAddStandbyRow = () => {
                // CRITICAL FIX: Add check for rosterData existence
                if (!rosterData) return;
                
                let nextNum = 2;
                while (rosterData[`OE/ STANDBY-${nextNum}`]) {
                    nextNum++;
                }
                const newRowName = `OE/ STANDBY-${nextNum}`;
                
                setRosterData(prevData => ({
                    ...prevData,
                    [newRowName]: Array(TIME_SLOTS.length).fill(null).map(() => ({ value: "", isAutomated: false }))
                }));
                setIsDirty(true);
            };

            const handleRemoveStandbyRow = (rowName) => {
                // Use a custom confirmation dialog replacement
                const confirmDelete = window.confirm(`Are you sure you want to remove the row "${rowName}"? Any assignments in this row will be lost.`);
                
                if (confirmDelete) {
                    setRosterData(prevData => {
                        const newData = { ...prevData };
                        delete newData[rowName]; 
                        return newData;
                    });
                    setIsDirty(true);
                }
            };
            
            const renderTableBody = (positions) => {
                // scheduledStaff and staffTypeMap are available from the parent RosterView component scope.
                const scheduledStaffIds = scheduledStaff.map(s => s.id).sort();
                
                // CRITICAL FIX: Guard rendering inside renderTableBody as well
                if (!rosterData || typeof rosterData !== 'object') {
                    return (<tbody><tr><td colSpan={TIME_SLOTS.length + 1}>Roster data is not yet available.</td></tr></tbody>);
                }

                return (
                    <tbody className={`bg-white divide-y divide-gray-200 ${isMatrixEditMode ? 'matrix-edit-active' : ''}`}>
                        {positions.map(pos => {
                            const isProwlerRow = pos.startsWith("PERIMETER PROWLER");
                            const isManualStandbyRow = pos.startsWith("OE/ STANDBY-");
                            
                            let displayName = pos;
                            if (focusView === 'sentry') {
                                if (pos === "PERIMETER PROWLER (1st Half)") { displayName = "1st Half"; } 
                                else if (pos === "PERIMETER PROWLER (2nd Half)") { displayName = "2nd Half"; } 
                                else if (pos === "PATROL 1") { displayName = "P1"; } 
                                else if (pos === "PATROL 2") { displayName = "P2"; } 
                                else if (pos === "N1 (CNB)") { displayName = "N1"; } 
                                else if (pos === "OE/ STANDBY") { displayName = "OE"; } 
                                else if (pos.startsWith("OE/ STANDBY-")) { displayName = pos.replace("OE/ STANDBY", "OE"); }
                            }
                            
                            return (
                                <tr key={pos} className={`${isProwlerRow ? 'bg-gray-100' : isManualStandbyRow ? 'bg-purple-50' : 'bg-white'} hover:bg-gray-200`}>
                                    
                                    <td className={`sticky left-0 p-2 text-sm font-medium text-gray-800 whitespace-nowrap z-10 border-r ${isProwlerRow ? 'bg-gray-100' : isManualStandbyRow ? 'bg-purple-50' : 'bg-white'}`}>
                                        <div className="flex items-center justify-between">
                                            <span>{displayName}</span>
                                            
                                            {pos === "OE/ STANDBY" && (
                                                <button onClick={handleAddStandbyRow} className="ml-2 w-5 h-5 flex items-center justify-center bg-green-500 text-white rounded-full font-bold hover:bg-green-600 print-hidden" title="Add manual standby row"> + </button>
                                            )}
                                            
                                            {isManualStandbyRow && (
                                                <button onClick={() => handleRemoveStandbyRow(pos)} className="ml-2 w-5 h-5 flex items-center justify-center bg-red-500 text-white rounded-full font-bold hover:bg-red-700 print-hidden" title={`Remove row ${pos}`}> - </button>
                                            )}
                                        </div>
                                    </td>
                                    
                                    {TIME_SLOTS.map((time, index) => {
                                        const cell = (rosterData[pos] && rosterData[pos][index]) ? rosterData[pos][index] : { value: "", isAutomated: isManualStandbyRow ? false : true };
                                        const value = cell.value;
                                        const isAutomated = cell.isAutomated;
                                        const isPair = cell.isPair;
                                        const isFixed = cell.isFixed;
                                        
                                        const isMissing = isAutomated && value === UNFILLED_SLOT;
                                        const isHighlighted = highlightedId && value === highlightedId && value !== UNFILLED_SLOT && value !== "";
                                        
                                        // Determine if the cell content is a Buffer ID
                                        const isBufferId = value && value !== UNFILLED_SLOT && staffTypeMap.get(value) === 'buffer';

                                        const getCellClasses = (isSelect = false) => {
                                            let baseClasses = "w-20 p-1 text-xs sm:text-sm border-0 border-r border-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none cursor-pointer text-center";
                                            
                                            if (isHighlighted) { return baseClasses + " highlight-cell"; }
                                            if (isMissing) { return baseClasses + " bg-yellow-100 text-yellow-800 font-bold"; }
                                            
                                            // 1. Apply buffer content style first if it's a buffer ID (highest visual priority after highlight)
                                            if (isBufferId) { return baseClasses + " buffer-id-content"; }
                                            
                                            // 2. Fallback styles
                                            if (isManualStandbyRow) { return baseClasses + " bg-purple-50"; }
                                            
                                            if (isMatrixEditMode && isSelect) { 
                                                // Matrix mode base style
                                                return baseClasses + " bg-blue-100 text-gray-700";
                                            }
                                            
                                            if (isPair) {
                                                // These classes also apply coloring, but buffer-id-content takes priority
                                                if (value === cell.buffer) { return baseClasses + " dropdown-buffer"; }
                                                return baseClasses + " dropdown-permanent";
                                            }
                                            if (isFixed) { // New style for Manual Fixed Mode
                                                return baseClasses + " bg-indigo-100 text-indigo-700 font-bold";
                                            }
                                            if (isAutomated) {
                                                return baseClasses + (isProwlerRow ? ' bg-gray-100 text-gray-700' : ' bg-gray-50 text-gray-700');
                                            }
                                            return baseClasses + " bg-white";
                                        };
                                        
                                        // --- MATRIX EDIT MODE (Dropdown in every cell) ---
                                        if (isMatrixEditMode) {
                                            // Get correct classes, which now includes buffer-id-content if applicable
                                            const classes = getCellClasses(true); 
                                            return (
                                                <td key={time} className="p-0">
                                                    <select
                                                        value={value || ""}
                                                        onChange={(e) => handleCellChange(pos, index, e.target.value)}
                                                        onClick={() => handleCellClick(value)}
                                                        className={classes}
                                                    >
                                                        <option value="">{UNFILLED_SLOT}</option>
                                                        {scheduledStaffIds.map(id => (
                                                            <option key={id} value={id}>{id}</option>
                                                        ))}
                                                    </select>
                                                </td>
                                            );
                                        }

                                        // --- DEFAULT / AUTO MODE (Input/Select based on data type) ---
                                        if (isPair) {
                                            return (
                                                <td key={time} className="p-0">
                                                    <select
                                                        value={value}
                                                        onChange={(e) => handleCellChange(pos, index, e.target.value)}
                                                        onClick={() => handleCellClick(value)}
                                                        className={getCellClasses()}
                                                        disabled={isMatrixEditMode}
                                                    >
                                                        <option value={cell.permanent}>{cell.permanent}</option>
                                                        <option value={cell.buffer}>{cell.buffer}</option>
                                                    </select>
                                                </td>
                                            );
                                        }
                                        
                                        return (
                                            <td key={time} className="p-0">
                                                <input
                                                    type="text"
                                                    value={value}
                                                    onChange={(e) => handleCellChange(pos, index, e.target.value)}
                                                    onClick={() => handleCellClick(value)}
                                                    className={getCellClasses()}
                                                    placeholder="ID"
                                                    readOnly={isAutomated && !isManualStandbyRow && !isFixed}
                                                />
                                            </td>
                                        );
                                    })}
                                </tr>
                            );
                        })}
                    </tbody>
                );
            };

            const renderTableHeader = (customSlots = TIME_SLOTS) => (
                <thead className="bg-gray-100">
                    <tr>
                        <th className="sticky left-0 bg-gray-100 p-1 text-left text-xs font-bold text-gray-600 uppercase tracking-wider z-10">Location/Call-Sign</th>
                        {customSlots.map(time => (
                            <th key={time} className="p-1 text-center text-xs font-bold text-gray-600 uppercase tracking-wider whitespace-nowrap">{time}</th>
                        ))}
                    </tr>
                </thead>
            );

            const renderVerticalProwlerTable = (controlRoomStaff = []) => {
                 // scheduledStaff and staffTypeMap are available from the parent RosterView component scope.
                 const scheduledStaffIds = scheduledStaff.map(s => s.id).sort();

                 const getMatrixDropdown = (pos, index, value) => {
                    // Determine if the cell content is a Buffer ID
                    const isBufferId = value && value !== UNFILLED_SLOT && staffTypeMap.get(value) === 'buffer';

                    let selectClasses = `w-full p-1 text-xs sm:text-sm border-0 border-r border-gray-200 cursor-pointer text-center vp-cell-fix`;
                    
                    // Priority check for buffer styling
                    if (isBufferId) { 
                        selectClasses += " buffer-id-content"; 
                    } else { 
                        // Fallback to generic matrix styling
                        selectClasses += `${isMatrixEditMode ? 'bg-blue-100 text-gray-700 font-semibold' : 'bg-white'}`; 
                    }
                     
                    return (
                        <td key={VERTICAL_PROWLER_SLOTS[index]} className="p-0">
                            <select
                                value={value || ""}
                                onChange={(e) => handleCellChange(pos, index, e.target.value)}
                                onClick={() => handleCellClick(value)}
                                className={selectClasses}
                            >
                                <option value="">{UNFILLED_SLOT}</option>
                                {scheduledStaffIds.map(id => (
                                    <option key={id} value={id}>{id}</option>
                                ))}
                            </select>
                        </td>
                     );
                 };
                 
                // CRITICAL FIX: Guard rendering inside renderVerticalProwlerTable as well
                 if (!rosterData || typeof rosterData !== 'object') {
                     return (
                         <div className="overflow-x-auto shadow-md rounded-lg border roster-section">
                             <table className="min-w-full divide-y divide-gray-200">
                                 {renderTableHeader(VERTICAL_PROWLER_SLOTS)}
                                 <tbody><tr><td colSpan={VERTICAL_PROWLER_SLOTS.length + 1}>Roster data is not yet available.</td></tr></tbody>
                             </table>
                         </div>
                     );
                 }

                return (
                    <div className="overflow-x-auto shadow-md rounded-lg border roster-section">
                        <table className="min-w-full divide-y divide-gray-200">
                            <thead className="bg-gray-100">
                                <tr>
                                    <th className="sticky left-0 bg-gray-100 p-1 text-left text-xs font-bold text-gray-600 uppercase tracking-wider z-10">Location/Call-Sign</th>
                                    {VERTICAL_PROWLER_SLOTS.map(time => (
                                        <th key={time} className="p-1 text-center text-xs font-bold text-gray-600 uppercase tracking-wider whitespace-nowrap vp-cell-fix">{time}</th>
                                    ))}
                                </tr>
                            </thead>
                            <tbody className={`bg-white divide-y divide-gray-200 ${isMatrixEditMode ? 'matrix-edit-active' : ''}`}>
                                <tr className="hover:bg-gray-50">
                                    <td className="sticky left-0 bg-white p-2 text-sm font-medium text-gray-800 whitespace-nowrap z-10 border-r">{VERTICAL_PROWLER_POSITION}</td>
                                    {VERTICAL_PROWLER_SLOTS.map((time, index) => {
                                        const cell = (rosterData[VERTICAL_PROWLER_POSITION] && rosterData[VERTICAL_PROWLER_POSITION][index]) ? rosterData[VERTICAL_PROWLER_POSITION][index] : { value: "", isAutomated: false };
                                        const value = cell.value;
                                        
                                        // NEW: Determine if the cell content is a Buffer ID
                                        const isBufferId = value && value !== UNFILLED_SLOT && staffTypeMap.get(value) === 'buffer';

                                        // If Matrix Edit Mode is on, render dropdown for ALL VP slots
                                        if (isMatrixEditMode) {
                                            return getMatrixDropdown(VERTICAL_PROWLER_POSITION, index, value);
                                        }

                                        // --- DEFAULT / AUTO MODE (Mixed inputs) ---
                                        const isMissing = value === UNFILLED_SLOT;
                                        const isHighlighted = highlightedId && value === highlightedId && value !== UNFILLED_SLOT && value !== "";
                                        const isPair = cell.isPair;
                                        const isAutomated = cell.isAutomated;

                                        let baseClasses = `w-20 p-1 text-xs sm:text-sm border-0 border-r border-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none cursor-pointer text-center vp-cell-fix`;
                                        
                                        if (index === 2) { 
                                            // Slot 2 is still special for manual control room staff selection
                                            let selectClasses = baseClasses;
                                            if (isHighlighted) { selectClasses += " highlight-cell"; } 
                                            else if (isMissing) { selectClasses += " bg-yellow-100 text-yellow-800 font-bold"; } 
                                            else if (isBufferId) { selectClasses += " buffer-id-content"; }
                                            else { selectClasses += " bg-white"; }
                                            
                                            return (
                                                <td key={time} className="p-0">
                                                    <select
                                                        value={value}
                                                        onChange={(e) => handleCellChange(VERTICAL_PROWLER_POSITION, index, e.target.value)}
                                                        onClick={() => handleCellClick(value)}
                                                        className={selectClasses}
                                                        disabled={isMatrixEditMode}
                                                    >
                                                        <option value={UNFILLED_SLOT}>{UNFILLED_SLOT}</option>
                                                        {[...new Set(controlRoomStaff)].map(id => (
                                                            <option key={id} value={id}>{id}</option>
                                                        ))}
                                                        {value && value !== UNFILLED_SLOT && !controlRoomStaff.includes(value) && (
                                                            <option key={value} value={value}>{value} (Old)</option>
                                                        )}
                                                    </select>
                                                </td>
                                            );
                                        }
                                        
                                        if (isPair) {
                                             let selectClasses = baseClasses;
                                             if (isHighlighted) { selectClasses += " highlight-cell"; } 
                                             else if (isBufferId) { selectClasses += " buffer-id-content"; } // Takes priority over pair classes
                                             else {
                                                if (value === cell.buffer) { selectClasses += " dropdown-buffer"; } 
                                                else { selectClasses += " dropdown-permanent"; }
                                            }
                                            return (
                                                <td key={time} className="p-0">
                                                    <select
                                                        value={value}
                                                        onChange={(e) => handleCellChange(VERTICAL_PROWLER_POSITION, index, e.target.value)}
                                                        onClick={() => handleCellClick(value)}
                                                        className={selectClasses}
                                                        disabled={isMatrixEditMode}
                                                    >
                                                        <option value={cell.permanent}>{cell.permanent}</option>
                                                        <option value={cell.buffer}>{cell.buffer}</option>
                                                    </select>
                                                </td>
                                            );
                                        }

                                        let inputClasses = baseClasses;
                                        if (isHighlighted) { inputClasses += " highlight-cell"; } 
                                        else if (isMissing) { inputClasses += " bg-yellow-100 text-yellow-800 font-bold"; } 
                                        else if (isBufferId) { inputClasses += " buffer-id-content"; }
                                        else { inputClasses += " bg-gray-50 text-gray-700"; }
                                        
                                        return (
                                            <td key={time} className="p-0">
                                                <input
                                                    type="text"
                                                    value={value}
                                                    onChange={(e) => handleCellChange(pos, index, e.target.value)}
                                                    onClick={() => handleCellClick(value)}
                                                    className={inputClasses}
                                                    placeholder="ID"
                                                    readOnly={isAutomated}
                                                />
                                            </td>
                                        );
                                    })}
                                </tr>
                            </tbody>
                        </table>
                    </div>
                );
            };
            
            const FocusButton = ({ label, view, icon }) => {
                const isActive = focusView === view;
                const baseClasses = "py-2 px-3 sm:px-4 text-xs sm:text-sm rounded-md font-medium transition-all duration-200 flex items-center gap-1";
                const activeClasses = "bg-blue-600 text-white shadow-md";
                const inactiveClasses = "bg-white text-gray-600 hover:bg-gray-200";
                
                const icons = {
                    all: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" /></svg>,
                    security: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12 12 0 0012 21.697z" /></svg>,
                    foyer: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5.121 17.804A13.937 13.937 0 0112 16c2.5 0 4.847.655 6.879 1.804M15 10a3 3 0 11-6 0 3 3 0 016 0z" /></svg>,
                    sentry: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                };

                return (
                    <button onClick={() => setFocusView(view)} className={`${baseClasses} ${isActive ? activeClasses : inactiveClasses}`}>
                        {icons[icon]}
                        <span className="hidden sm:inline">{label}</span>
                        <span className="sm:hidden">{label === 'SCR' ? 'SCR' : ''}</span>
                    </button>
                );
            };
            
            const handleToggleMatrix = () => {
                // If switching INTO matrix mode, clear highlights
                if (!isMatrixEditMode) {
                    setHighlightedId(null);
                }
                setIsMatrixEditMode(prev => !prev);
            };

            // NEW: Logic to check if assignments are present and enable the Auto-Update button
            const canGenerateRoster = useMemo(() => {
                // Must be authenticated and not currently loading the core data
                if (loading || isGenerating) return false;
                
                // Must have the assignment document loaded
                if (!dailyAssignments) return false;
                
                // Must have at least one assigned slot in the sequenceMap to proceed
                const sequenceMap = dailyAssignments.sequenceMap || {};
                const hasAssignments = Object.values(sequenceMap).some(arr => Array.isArray(arr) && arr.length > 0);
                
                return hasAssignments;
            }, [loading, isGenerating, dailyAssignments]);


            // Determine button label dynamically
            const generateButtonLabel = useMemo(() => {
                if (isGenerating) return "Generating...";
                if (rosterData) return "Update Roster";
                return "Generate Roster";
            }, [rosterData, isGenerating]);


            return (
                <div className="bg-white sm:p-6 rounded-lg shadow-lg">
                    {/* Control Bar: Hidden on Print */}
                    <div className="flex flex-col sm:flex-row justify-between items-center mb-6 gap-4 p-2 sm:p-0 action-buttons">
                        <div className="flex items-center gap-2 date-selector">
                            <label htmlFor="roster-date-main" className="font-medium text-gray-700 text-lg">Roster Date:</label>
                            <input
                                type="date"
                                id="roster-date-main"
                                value={selectedDate}
                                onChange={(e) => setSelectedDate(e.target.value)}
                                className="border-gray-300 rounded-md shadow-sm p-2 text-lg"
                            />
                        </div>
                        <div className="flex space-x-2">
                            <button
                                onClick={handleToggleMatrix}
                                className={`py-2 px-4 rounded-md font-medium text-white shadow-md transition-colors`}
                                style={{ backgroundColor: isMatrixEditMode ? '#DC2626' : '#2563EB' }}
                                disabled={loading || !rosterData}
                            >
                                {isMatrixEditMode ? "Exit Matrix Edit" : "Matrix Edit Mode"}
                            </button>
                            
                            <button
                                onClick={handlePrint}
                                disabled={loading || !rosterData}
                                className="py-2 px-4 bg-purple-600 text-white rounded-md shadow-md font-medium hover:bg-purple-700 disabled:bg-gray-400 disabled:cursor-not-allowed print-hidden"
                            >
                                Print Roster
                            </button>

                            <button
                                onClick={handleSaveChanges}
                                disabled={loading || !isDirty}
                                className="py-2 px-4 bg-green-600 text-white rounded-md shadow-md font-medium hover:bg-green-700 disabled:bg-gray-400 print-hidden"
                            >
                                {loading ? "Saving..." : "Save Changes"}
                            </button>
                        </div>
                    </div>
                    
                    {/* Error, Dirty, Loading messages */}
                    {error && <div className="text-red-600 bg-red-100 p-3 rounded-md mb-4 mx-2 sm:mx-0">
                        {error}
                        <p className="text-sm mt-1">Note: Print View will still attempt to render data even with minor load errors.</p>
                    </div>}
                    {isDirty && <div className="text-yellow-700 bg-yellow-100 p-3 rounded-md mb-4 mx-2 sm:mx-0 unsaved-changes">You have unsaved changes.</div>}
                    {loading && !rosterData && <div className="text-center p-8">Loading Roster and Assignments...</div>}


                    {/* --- FOCUS BUTTONS AND GENERATE BUTTON - MOVED OUTSIDE rosterData check --- */}
                    <div className="space-y-6 p-2 sm:p-0">
                        {/* Focus/Generate Button Row */}
                        <div className="flex space-x-2 p-2 sm:p-0 bg-gray-100 sm:bg-transparent rounded-lg focus-buttons">
                            <FocusButton label="Show All" view="all" icon="all" />
                            <FocusButton label="SCR" view="security" icon="security" />
                            <FocusButton label="Foyer" view="foyer" icon="foyer" />
                            <FocusButton label="Sentry" view="sentry" icon="sentry" />
                            
                            {!isMatrixEditMode && (
                                <button
                                    onClick={() => handleGenerateRoster(false)}
                                    title={canGenerateRoster ? `Click to ${generateButtonLabel} using assignments from Setup tab` : "Requires saved assignments (Setup tab)"}
                                    disabled={!canGenerateRoster || isGenerating} 
                                    className="py-2 px-4 bg-gray-200 text-gray-700 rounded-md shadow-md font-medium hover:bg-gray-300 disabled:bg-gray-400 disabled:cursor-not-allowed"
                                >
                                    {generateButtonLabel}
                                </button>
                            )}
                        </div>
                        
                        {/* Warning/Loading Messages Related to Generation */}
                        {!loading && !canGenerateRoster && (
                            <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-4 mx-2 sm:mx-0 font-medium">
                                <p>Cannot **{generateButtonLabel}**:</p>
                                <p className="text-sm">Please go to **Staff & Roster Setup** tab, make sure staff are scheduled, and set their primary assignments, then save the assignments.</p>
                            </div>
                        )}
                        
                        {isGenerating && (
                            <div className="bg-blue-100 border-l-4 border-blue-500 text-blue-800 p-4 mb-4 mx-2 sm:mx-0 font-medium animate-pulse">
                                Roster generation in progress...
                            </div>
                        )}
                        
                        {/* Tooltip for Matrix Mode */}
                        {isMatrixEditMode && (
                            <div className="bg-blue-50 border-l-4 border-blue-400 text-blue-800 p-4 mb-4 mx-2 sm:mx-0">
                                <p className="font-bold">Matrix Edit Mode Active:</p>
                                <p className="text-sm">Every cell is a direct dropdown for assignment. Use "Save Changes" after editing.</p>
                            </div>
                        )}
                        
                        {/* --- ROSTER TABLES - Rendered if rosterData exists, else show placeholder --- */}
                        {rosterData ? (
                            <div className="space-y-6 p-2 sm:p-0"> 
                                <h2 className="text-xl font-bold mb-4 text-center hidden print:block">DAILY ROSTER - {selectedDate}</h2>
                            
                                {(focusView === 'all' || focusView === 'security') && (
                                    <div className={`roster-section ${focusView !== 'all' ? 'border-t border-gray-300 pt-4' : ''}`}>
                                        <h3 className="text-lg font-semibold mb-2 text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Security Control Office</h3>
                                        <div className="overflow-x-auto shadow-md rounded-lg border">
                                            <table className="min-w-full divide-y divide-gray-200">
                                                {renderTableHeader()}
                                                {renderTableBody(SECURITY_POSITIONS)}
                                            </table>
                                        </div>
                                    </div>
                                )}
                                
                                 {(focusView === 'all' || focusView === 'foyer') && (
                                    <div className="border-t border-gray-300 pt-6 space-y-4 roster-section">
                                        <h3 className="text-lg font-semibold mb-2 text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Vertical Prowler</h3>
                                        {(() => {
                                            const teamLeaderId = (rosterData[SECURITY_POSITIONS[0]]?.[0]?.value || "").trim();
                                            const sectionIcId = (rosterData[SECURITY_POSITIONS[1]]?.[0]?.value || "").trim();
                                            const controlRoomStaff = [...new Set([teamLeaderId, sectionIcId].filter(id => id && id !== UNFILLED_SLOT && id !== ""))];
                                            
                                            return renderVerticalProwlerTable(controlRoomStaff);
                                        })()}
                                    </div>
                                 )}

                                 {(focusView === 'all' || focusView === 'sentry') && (
                                    <div className="border-t border-gray-300 pt-6 roster-section">
                                        <h3 className="text-lg font-semibold mb-2 text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Sentry Deployment / Patrol Duties</h3>
                                        <div className="overflow-x-auto shadow-md rounded-lg border">
                                            <table className="min-w-full divide-y divide-gray-200">
                                                {renderTableHeader()}
                                                {renderTableBody(sentryRowsToRender)}
                                            </table>
                                        </div>
                                    </div>
                                )}
                            </div>
                        ) : (
                            // Placeholder when no roster data is loaded
                            !loading && (
                                <div className="text-center p-8 border rounded-lg bg-gray-50 mt-4">
                                    <p className="text-lg font-semibold text-gray-700">No Roster Data Found for {selectedDate}.</p>
                                    <p className="text-sm text-gray-500 mt-2">Use the **Generate Roster** button above after setting up assignments in the Setup tab.</p>
                                </div>
                            )
                        )}
                    </div>
                </div>
            );
        }

        // --- CRITICAL: Delay React Render until Firebase is ready ---
        
        let attempts = 0;
        const maxAttempts = 20; // Try for up to 2 seconds
        
        function tryRenderApp() {
            if (window.firebase && window.firebase.db && window.firebase.auth) {
                // Firebase is ready, proceed to render
                try {
                    const root = ReactDOM.createRoot(document.getElementById('root'));
                    root.render(React.createElement(App)); // Use React.createElement to prevent Babel interpretation issues during delayed render
                } catch (e) {
                    console.error("React Render Failed:", e);
                    // Display a visible error message if React crashes during initial render
                    document.getElementById('root').innerHTML = '<div style="padding: 20px; color: red; background: #fee2e2; border: 1px solid #f87171; text-align: center;">FATAL ERROR: Failed to start the Roster Application. Check console for details.</div>';
                }
            } else if (attempts < maxAttempts) {
                // Not ready yet, try again soon
                attempts++;
                setTimeout(tryRenderApp, 100);
            } else {
                // Timeout
                console.error("FATAL ERROR: Firebase SDK did not initialize within the expected time.");
                document.getElementById('root').innerHTML = '<div style="padding: 20px; color: red; background: #fee2e2; border: 1px solid #f87171; text-align: center;">FATAL ERROR: Application timeout. Firebase SDK failed to initialize. Please try again.</div>';
            }
        }
        
        // Start the render attempt process on window load
        window.onload = tryRenderApp;

    </script>
</body>
</html>

