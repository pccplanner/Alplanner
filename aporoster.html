<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent Roster System (v16.20 - Final Matrix Vacate Fix P2+)</title>
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Load React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- 3. Load Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- 4. Load Firebase SDKs (v9.6.1 - Older, stable, global exports) -->
    <script type="module">
        // --- Import Core SDK Modules ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, getDoc, setDoc, onSnapshot, 
            collection, deleteDoc, setLogLevel, updateDoc
        } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";

        // --- SDK CONFIGURATION (Must be defined outside the module for the environment to pick up __variables) ---
        const mockFirebaseConfig = {
          apiKey: "AIzaSyAP7b4KcwRYPMZjNc2TWsNqMvC3ywImhOM",
          authDomain: "roster-4a997.firebaseapp.com",
          projectId: "roster-4a997",
          storageBucket: "roster-4a997.firebasestorage.app",
          messagingSenderId: "901381868881",
          appId: "1:901381868881:web:92930481d6c1c85fedd770"
        };
        
        // --- Canvas Environment Variables ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : mockFirebaseConfig;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Set Firebase Log Level for debugging
        setLogLevel('debug');

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // **CRITICAL FIX:** Expose ALL required variables and functions on a single global object
        window.firebase = {
            // Core Instances and Constants
            db: db,
            auth: auth, 
            appId: appId,
            initialAuthToken: initialAuthToken,
            
            // Firestore Functions
            doc: doc,
            getDoc: getDoc,
            setDoc: setDoc,
            onSnapshot: onSnapshot,
            collection: collection,
            deleteDoc: deleteDoc,
            updateDoc: updateDoc,
            
            // Auth Functions
            signInAnonymously: signInAnonymously,
            onAuthStateChanged: onAuthStateChanged,
            signInWithCustomToken: signInWithCustomToken,
            getAuth: getAuth 
        };
        
        // CRITICAL FIX: Delay React Render until Firebase is ready
        let attempts = 0;
        const maxAttempts = 20; 
        
        function tryRenderApp() {
            if (window.firebase && window.firebase.db && window.firebase.auth) {
                try {
                    const root = ReactDOM.createRoot(document.getElementById('root'));
                    root.render(React.createElement(App));
                } catch (e) {
                    console.error("React Render Failed:", e);
                    document.getElementById('root').innerHTML = '<div style="padding: 20px; color: red; background: #fee2e2; border: 1px solid #f87171; text-align: center;">FATAL ERROR: React failed to start. Check console.</div>';
                }
            } else if (attempts < maxAttempts) {
                attempts++;
                setTimeout(tryRenderApp, 100);
            } else {
                console.error("FATAL ERROR: Firebase SDK did not initialize within the expected time.");
                document.getElementById('root').innerHTML = '<div style="padding: 20px; color: red; background: #fee2e2; border: 1px solid #f87171; text-align: center;">FATAL ERROR: Application timeout. Firebase SDK failed to initialize. Please try again.</div>';
            }
        }
        
        // Start the render attempt process on window load
        window.onload = tryRenderApp;

    </script>
    
    <style>
        /* --- General Styling --- */
        .highlight-cell { background-color: #FDE047; border: 2px solid #F59E0B; color: #000; font-weight: bold; }
        
        /* Styles for cells containing permanent/buffer pairs (dropdowns) */
        .dropdown-permanent { font-weight: bold; color: #1D4ED8; background-image: linear-gradient(45deg, #EFF6FF 50%, #DBEAFE 50%); background-size: 8px 8px; }
        .dropdown-buffer { font-weight: bold; color: #581c87; background-color: #d8b4fe; }

        /* ENHANCED: Style for any cell whose VALUE (staff ID) is a buffer, regardless of pairing/mode */
        .buffer-id-content { 
            background-color: #FBCFE8 !important; /* Pink 200 - enhanced visibility */
            color: #9D174D !important; /* Rose 700 - deep contrast text */
            font-weight: 700 !important;
            border: 1px solid #F472B6 !important; /* Pink 400 */
        }

        /* NEW: Style for 2000Hrs column during shuffle */
        .shuffling-highlight { 
            background-color: #FBBF24 !important; /* Amber 400 */
            border: 2px solid #D97706 !important; /* Amber 700 */
            animation: pulse-shuffle 1s infinite alternate; 
        }

        @keyframes pulse-shuffle {
            from { opacity: 1; }
            to { opacity: 0.7; }
        }

        select, input { text-align: center !important; text-align-last: center !important; -moz-text-align-last: center !important; }
        
        /* --- Consolidated Setup Card Styles (Section 1) --- */
        .staff-pool-grid {
             grid-template-columns: repeat(1, minmax(0, 1fr)); /* Use 1 column by default for mobile to maximize vertical space for assignment dropdowns */
        }
        @media (min-width: 400px) { 
            /* On small screens, two columns look good with compact cards */
            .staff-pool-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); } 
        }
        @media (min-width: 768px) { 
            .staff-pool-grid { grid-template-columns: repeat(3, minmax(0, 1fr)); } 
        }
        @media (min-width: 1024px) { 
            .staff-pool-grid { grid-template-columns: repeat(4, minmax(0, 1fr)); } 
        }

        .staff-card-scheduled { border: 1px solid #10B981; background-color: #F0FDF4; }
        .staff-card-unscheduled { border: 1px solid #F87171; background-color: #FEF2F2; }

        /* --- Custom Toggle Switch (for Mobile/Touch) --- */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #3B82F6; /* Blue-500 */
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        
        /* Radio Group for Roster Mode */
        /* COMPACT MODE STYLES */
        .radio-group label {
            transition: all 0.2s;
            min-width: 120px; /* Ensure buttons don't get too small */
            text-align: center;
        }
        .radio-group input[type="radio"]:checked + label {
            background-color: #3B82F6; /* Blue-500 */
            color: white;
            border-color: #3B82F6;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        .modal-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            max-width: 90%;
            width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        /* Matrix Edit Mode Styles */
        .matrix-edit-active td {
            background-color: #f0f9ff !important; /* Blue-50 */
        }
        
        /* CRITICAL FIX: Ensure matrix select inputs can be overridden by buffer style */
        .matrix-edit-active select {
            background-color: #e0f2fe !important; /* Blue-100 */
            font-weight: 600;
            border: 1px solid #93c5fd;
            padding: 1px 1px !important; 
            height: 18px !important;
        }
        
        /* Give buffer content higher specificity than the generic matrix select style */
        .matrix-edit-active .buffer-id-content {
             background-color: #FBCFE8 !important;
             color: #9D174D !important;
             border: 1px solid #F472B6 !important;
        }


        .matrix-edit-active select:focus {
            outline: none;
            box-shadow: 0 0 0 2px #93c5fd;
        }


        /* --- Print Styles --- */
        @media print {
            header, footer, .nav-buttons, .action-buttons, .focus-buttons, .date-selector, .unsaved-changes, .print-hidden, .setup-tools, .roster-mode-selector, .filter-control-button { display: none !important; }
            @page { size: A4 landscape; margin: 0.5cm; }
            body { zoom: 80%; }
            .min-h-screen, #root, main, .container { min-height: auto !important; padding: 0 !important; margin: 0 auto !important; width: 100% !important; max-width: none !important; }
            .shadow-md, .rounded-lg, .border { box-shadow: none !important; border: none !important; border-collapse: collapse !important; }
            .roster-section { break-inside: avoid; margin-bottom: 0.5cm !important; padding: 0 !important; }
            .overflow-x-auto { overflow: visible !important; }
            .min-w-full { width: 100% !important; table-layout: fixed; }
            .min-w-full th:first-child, .min-w-full td:first-child { width: 2.4in !important; max-width: 2.4in !important; min-width: 2.4in !important; white-space: normal !important; text-align: left !important; }
            .min-w-full th:first-child, .min-w-full td:first-child span { font-size: 7.5pt !important; }
            .p-1 { padding: 0.1rem !important; }
            .text-xs, .text-sm { font-size: 8pt !important; line-height: 1.1 !important; }
            .sticky { position: static !important; }
            input, select { -webkit-appearance: none !important; -moz-appearance: none !important; appearance: none !important; border: 0.5px solid #ccc !important; background-color: transparent !important; text-align: center !important; font-weight: bold; color: #000; width: 100% !important; box-sizing: border-box !important; }
            
            /* Print-specific style overrides */
            .dropdown-permanent, .dropdown-buffer, .highlight-cell { background-color: #E0F2FE !important; color: #000 !important; border: 0.5px solid #999 !important; background-image: none !important; }
            .bg-gray-100, .bg-gray-50 { background-color: #f7f7f7 !important; }
            .bg-white { background-color: white !important; }
            .highlight-cell { background-color: #FEF3C7 !important; }
            
            /* NEW: Print-specific style for Buffer ID content (ENHANCED) */
            .buffer-id-content { 
                background-color: #FBCFE8 !important; /* Pink 200 */
                color: #9D174D !important; /* Rose 700 */
                font-weight: 700 !important; 
                border: 0.5px solid #F472B6 !important; /* Pink 400 */
            }

            /* Disable shuffle highlight in print */
            .shuffling-highlight { 
                background-color: #FEF3C7 !important; 
                border: 0.5px solid #999 !important;
                animation: none !important;
            }

            .vp-cell-fix { width: 17% !important; text-align: center !important; padding: 0px !important; margin: 0px !important; }
            .roster-section table td { padding: 0.1rem 0 !important; }
            .roster-section table input.vp-cell-fix, .roster-section table select.vp-cell-fix { margin: 0 !important; padding: 1px 1px !important; height: 14px !important; line-height: 1.2 !important; text-align: center !important; width: 100% !important; box-sizing: border-box !important; }
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div id="root"></div>

    <script type="text/babel">
        // --- REACT COMPONENT CODE STARTS HERE ---
        
        // This is a placeholder structure to grab the global variables set by the module script above
        const FIREBASE_GLOBALS = window.firebase || {};
        
        const { useState, useEffect, useMemo, createContext, useContext } = React;
        
        // Grab dependencies from the global object
        const { 
            doc, getDoc, setDoc, onSnapshot, 
            collection, deleteDoc, updateDoc,
            signInAnonymously, onAuthStateChanged, 
            signInWithCustomToken, initialAuthToken,
            appId, db, auth, getAuth 
        } = FIREBASE_GLOBALS;
        
        // --- Constants (rest of the file remains the same) ---
        const SECURITY_POSITIONS = ["TEAM LEADER (I/C)", "SECTION I/C"];
        const FOYER_POSITIONS = ["XRAY-VISITOR", "FOYER-OE"];
        const VERTICAL_PROWLER_POSITION = "VERTICAL PROWLER";
        
        // All possible rows in the Sentry/Patrol section
        const SENTRY_POSITIONS = ["E1", "PATROL 1", "E3", "N1 (CNB)", "PATROL 2", "OE/ STANDBY", "PERIMETER PROWLER (1st Half)", "PERIMETER PROWLER (2nd Half)"];
        
        const TIME_SLOTS = ["2000Hrs", "2100Hrs", "2200Hrs", "2300Hrs", "2400Hrs", "0100Hrs", "0200Hrs", "0300Hrs", "0400Hrs", "0500Hrs", "0600Hrs", "0700Hrs"];
        const VERTICAL_PROWLER_SLOTS = ["20:30", "23:00", "00:30", "03:00", "04:30", "06:30"];
        
        // Roster Keys (used for Auto-Sequence Assignment)
        const SENTRY_SEQUENCE_KEYS = ["E1", "OE", "P2", "N1", "E3", "P1"];
        
        // Location Keys (used for Manual Fixed Assignment)
        const SENTRY_LOCATION_KEYS = ["E1", "PATROL 1", "E3", "N1 (CNB)", "PATROL 2", "OE/ STANDBY", "PERIMETER PROWLER (1st Half)", "PERIMETER PROWLER (2nd Half)"];
        
        const FOYER_ASSIGNMENT_KEYS = ["FOYER 1", "FOYER 2"];
        const SECURITY_ASSIGNMENT_KEYS = ["TEAM LEADER (I/C)", "SECTION I/C"];
        
        // All possible assignment keys (sequences and locations)
        const ALL_ASSIGNMENT_KEYS = [...SENTRY_SEQUENCE_KEYS, ...SENTRY_LOCATION_KEYS, ...FOYER_ASSIGNMENT_KEYS, ...SECURITY_ASSIGNMENT_KEYS];
        const UNASSIGNED_KEY = "Unassigned";
        const UNFILLED_SLOT = "---";
        
        // Locations that buffer staff can override (whole row)
        const OVERRIDE_LOCATIONS = [
            "E1", "PATROL 1", "E3", "N1 (CNB)", "PATROL 2", "OE/ STANDBY", VERTICAL_PROWLER_POSITION
        ];

        // Logic for Auto-Sequence Mode
        const SENTRY_POSITION_SEQUENCES = {
            "E1": ["E1", "OE", "P2", "N1", "E3", "P1"], "PATROL 1": ["P1", "E1", "OE", "P2", "N1", "E3"],
            "E3": ["E3", "P1", "E1", "OE", "P2", "N1"], "N1 (CNB)": ["N1", "E3", "P1", "E1", "OE", "P2"],
            "PATROL 2": ["P2", "N1", "E3", "P1", "E1", "OE"], "OE/ STANDBY": ["OE", "P2", "N1", "E3", "P1", "E1"],
            // Patrol Prowlers will be handled separately as they are a full shift assignment
            "PERIMETER PROWLER (1st Half)": ["Prowler1"], "PERIMETER PROWLER (2nd Half)": ["Prowler2"]
        };
        
        // Roster Modes for daily operations
        const ROSTER_MODES = {
            AUTO_SEQUENCE: 'Auto-Sequence',
            MANUAL_LOCATION_FIXED: 'Manual-Location-Fixed'
        };
        
        // --- DB Collection Names ---
        const TEAM_COLLECTION = "teams"; 
        const EMPLOYEES_COLLECTION = "employees";
        const DAILY_ASSIGNMENTS_COLLECTION = "dailyAssignments_v7";
        const DAILY_ROSTER_COLLECTION = "dailyRosters_v7";
        const DAILY_ATTENDANCE_COLLECTION = "dailyAttendance_v7"; 
        
        // CRITICAL HELPER: Generates the correct collection reference path
        const getCollectionRef = (collectionName) => {
            // Defensive checks for missing Firebase objects
            if (!db || typeof collection !== 'function') return null;

            // Team and Employee data use the public path prefix
            if (collectionName === TEAM_COLLECTION || collectionName === EMPLOYEES_COLLECTION) {
                // FALLBACK CHECK: If appId is not defined or is 'default-app-id', we try to read from the root collection instead
                if (appId === 'default-app-id' || typeof appId === 'undefined') {
                    console.warn(`[WARNING] Using fallback root path for ${collectionName}. Check if appId is defined correctly.`);
                    return collection(db, collectionName);
                }
                const path = `artifacts/${appId}/public/data/${collectionName}`;
                return collection(db, path);
            }
            // All daily roster data is stored at the root collection path
            return collection(db, collectionName);
        };

        // CRITICAL HELPER: Generates the correct doc reference path
        const getDocRef = (collectionName, docId) => {
            // Defensive checks for missing Firebase objects
            if (!db || typeof doc !== 'function') return null;

            // Team and Employee data use the public path prefix
            if (collectionName === TEAM_COLLECTION || collectionName === EMPLOYEES_COLLECTION) {
                if (appId === 'default-app-id' || typeof appId === 'undefined') {
                    return doc(db, collectionName, String(docId));
                }
                return doc(db, `artifacts/${appId}/public/data/${collectionName}`, String(docId));
            }
            // All daily roster data is stored at the root collection path
            return doc(db, collectionName, String(docId));
        };
        
        // --- Helper: Get today's date ---
        const getTodayDate = () => {
            const today = new Date();
            const offset = today.getTimezoneOffset();
            const adjustedToday = new Date(today.getTime() - (offset*60*1000));
            return adjustedToday.toISOString().split('T')[0];
        };

        // --- CRITICAL: Helper to sanitize data for Firestore ---
        const sanitizeForFirestore = (obj) => {
            if (obj === undefined || obj === null) return null;
            if (Array.isArray(obj)) {
                return obj.map(sanitizeForFirestore);
            }
            if (typeof obj === 'object' && obj !== null) {
                const newObj = {};
                Object.keys(obj).forEach(key => {
                    newObj[key] = sanitizeForFirestore(obj[key]);
                });
                return newObj;
            }
            return obj;
        };

        // --- Helper to extract name after parentheses ---
        const extractName = (fullName) => {
            if (!fullName || typeof fullName !== 'string') return '';
            const match = fullName.match(/\((.*?)\)\s*(.*)/);
            if (match && match[2]) {
                // Returns the part after the closing parenthesis and optional space
                return match[2].trim();
            }
            // If no parentheses are found, return the original name
            return fullName.trim();
        };

        // --- Helper to remove leading 'T' from ID ---
        const cleanStaffId = (id) => {
            if (!id || typeof id !== 'string') return '';
            const trimmedId = id.trim();
            // Check if the ID starts with 'T' (case-insensitive) and remove it.
            if (trimmedId.length > 1 && (trimmedId.startsWith('T') || trimmedId.startsWith('t'))) {
                return trimmedId.substring(1);
            }
            return trimmedId;
        };
        
        // --- React Context for Staff Pool & Attendance ---
        const StaffContext = createContext();
        
        function StaffProvider({ children, selectedDate }) {
            const [employees, setEmployees] = useState([]); 
            const [teams, setTeams] = useState([]); 
            const [dailyAttendance, setDailyAttendance] = useState([]); 
            const [loadingState, setLoadingState] = useState({ teams: true, employees: true, attendance: true });
            const [error, setError] = useState(null);
            
            // 1. Load Teams Data (Uses dynamic public path/fallback)
            useEffect(() => {
                const teamsCollectionRef = getCollectionRef(TEAM_COLLECTION);
                if (!teamsCollectionRef) return;
                
                const unsubscribe = onSnapshot(teamsCollectionRef, (querySnapshot) => {
                    const loadedTeams = [];
                    querySnapshot.forEach(doc => {
                        loadedTeams.push({ docId: doc.id, ...doc.data() });
                    });
                    setTeams(loadedTeams);
                    setLoadingState(prev => ({ ...prev, teams: false }));
                }, (err) => {
                    console.error("Error fetching teams: ", err);
                    setError("Could not load teams data. Data path might be incorrect or missing.");
                    setLoadingState(prev => ({ ...prev, teams: false }));
                });
                return () => unsubscribe();
            }, [appId]);

            // 2. Load Employees/Users Data (Uses dynamic public path/fallback)
            useEffect(() => {
                const employeesCollectionRef = getCollectionRef(EMPLOYEES_COLLECTION);
                if (!employeesCollectionRef) return;
                
                const unsubscribe = onSnapshot(employeesCollectionRef, (querySnapshot) => {
                    const loadedEmployees = [];
                    querySnapshot.forEach(doc => {
                        loadedEmployees.push({ docId: doc.id, ...doc.data() });
                    });
                    setEmployees(loadedEmployees.sort((a, b) => (a.name || '').localeCompare(b.name || '')));
                    setLoadingState(prev => ({ ...prev, employees: false }));
                }, (err) => {
                    console.error("Error fetching users/employees: ", err);
                    setError(`Could not load employee data. Data path might be incorrect or missing.`);
                    setLoadingState(prev => ({ ...prev, employees: false }));
                });
                return () => unsubscribe();
            }, [appId]);
            
            // 3. Load Daily Attendance for selected date (Uses root path)
            useEffect(() => {
                if (!selectedDate || !db) return; 
                setLoadingState(prev => ({ ...prev, attendance: true }));

                const docRef = getDocRef(DAILY_ATTENDANCE_COLLECTION, selectedDate);
                if (!docRef) return;
                
                const unsubscribe = onSnapshot(docRef, (docSnap) => {
                    const scheduledIds = docSnap.exists() ? docSnap.data().scheduledStaff || [] : [];
                    setDailyAttendance(scheduledIds);
                    setLoadingState(prev => ({ ...prev, attendance: false }));
                }, (err) => {
                    console.error("Error fetching daily attendance: ", err);
                    setLoadingState(prev => ({ ...prev, attendance: false }));
                });
                return () => unsubscribe();
            }, [selectedDate]); 
            
            // Processed data for components (CRITICAL for fixing the white screen error)
            const teamMap = useMemo(() => {
                const map = new Map();
                teams.forEach(t => map.set(t.docId, t));
                return map;
            }, [teams]);
            
            const staffPool = useMemo(() => employees.map(emp => {
                // Priority: emp_id > id > docId
                const rawStaffId = emp.emp_id || emp.id || emp.docId; 
                if (!rawStaffId) return null; 

                // Apply ID cleaning logic here
                const staffId = cleanStaffId(String(rawStaffId));

                // Use the name extraction helper
                const rawName = emp.name || String(staffId);
                const extractedName = extractName(rawName);

                return {
                    id: String(staffId), // Use CLEANED ID (for display/roster logic)
                    docId: emp.docId, // **CRITICAL FIX: Keep original Firestore document ID for deletion**
                    name: extractedName || String(staffId), // Ensure name is always set
                    rawName: rawName, // Keep raw name for reference if needed
                    team_id: emp.team_id || '', // **CRITICAL FIX: Ensure team_id is a string, not undefined**
                    team_name: teamMap.get(emp.team_id)?.name || 'N/A Team', 
                    type: emp.is_buffer ? 'buffer' : 'permanent',
                };
            }).filter(s => s !== null), [employees, teamMap]); 

            const staffTypeMap = useMemo(() => {
                const map = new Map();
                staffPool.forEach(staff => {
                    map.set(staff.id, staff.type);
                });
                return map;
            }, [staffPool]);
            
            // Overall loading is only false when all sources are done
            const loading = loadingState.teams || loadingState.employees || loadingState.attendance;

            const scheduledStaff = useMemo(() => {
                const scheduledSet = new Set(dailyAttendance);
                if (loading) return []; 
                
                return staffPool.filter(staff => scheduledSet.has(staff.id));
            }, [staffPool, dailyAttendance, loading]);

            const value = { 
                staffPool, 
                teamMap,   
                staffTypeMap, 
                loading, 
                error,
                dailyAttendance,
                scheduledStaff,
                ALL_ASSIGNMENT_KEYS,
                OVERRIDE_LOCATIONS
            };
            
            return (
                <StaffContext.Provider value={value}>
                    {children}
                </StaffContext.Provider>
            );
        }

        // --- Main App Component ---
        function App() {
            const [view, setView] = useState('roster'); 
            const [userId, setUserId] = useState(null);
            const [authLoading, setAuthLoading] = useState(true);
            const [authError, setAuthError] = useState(null);
            const [selectedDate, setSelectedDate] = useState(getTodayDate());

            // Authentication Handler
            useEffect(() => {
                // Check if auth object is available before proceeding
                if (typeof auth === 'undefined' || auth === null || typeof onAuthStateChanged !== 'function') {
                    setAuthError("Firebase Auth service is still loading or unavailable.");
                    setAuthLoading(false);
                    return;
                }
                
                let isSigningIn = false;
                
                const unsubscribe = onAuthStateChanged(auth, (user) => {
                    if (user) {
                        setUserId(user.uid);
                        setAuthLoading(false);
                    } else if (!isSigningIn) {
                        isSigningIn = true;
                        const signIn = async () => {
                            try {
                                if (initialAuthToken) {
                                    if(typeof signInWithCustomToken !== 'function') throw new Error("signInWithCustomToken is not available.");
                                    await signInWithCustomToken(auth, initialAuthToken);
                                    console.log("Signed in with custom token.");
                                } else {
                                    if(typeof signInAnonymously !== 'function') throw new Error("signInAnonymously is not available.");
                                    await signInAnonymously(auth);
                                    console.log("Signed in anonymously.");
                                }
                            } catch (err) {
                                console.error("Authentication error: ", err);
                                setAuthError("Failed to authenticate. Token might be invalid or services misconfigured.");
                            } finally {
                                if(authLoading) setAuthLoading(false); 
                            }
                        };
                        signIn();
                    }
                });
                
                return () => unsubscribe();
            }, [authLoading]); 

            if (authLoading) return <div className="p-8 text-center text-2xl font-semibold text-blue-600">Connecting to Firebase Server...</div>
            if (authError) return <div className="p-8 text-center text-xl font-semibold text-red-600">Authentication Failed: {authError}</div>
            
            // Render the main content only if authenticated
            return (
                <StaffProvider selectedDate={selectedDate}>
                    <div className="min-h-screen">
                        {/* Header: Hidden on Print */}
                        <header className="bg-white shadow-md">
                            <nav className="container mx-auto px-4 sm:px-6 lg:px-8 flex flex-col sm:flex-row justify-between items-center py-4 gap-4">
                                <h1 className="text-2xl font-bold text-blue-600">Direct Assign Roster (v16.20)</h1>
                                <div className="flex space-x-2 nav-buttons">
                                    <NavButton
                                        label="Daily Roster"
                                        isActive={view === 'roster'}
                                        onClick={() => setView('roster')}
                                    />
                                    <NavButton
                                        label="Staff & Roster Setup"
                                        isActive={view === 'settings'}
                                        onClick={() => setView('settings')}
                                    />
                                </div>
                            </nav>
                        </header>
                        
                        {/* Page Content */}
                        <main className="container mx-auto p-0 sm:p-6 lg:px-8">
                            {view === 'roster' && <RosterView selectedDate={selectedDate} setSelectedDate={setSelectedDate} />}
                            {view === 'settings' && <StaffAndRosterSetupView selectedDate={selectedDate} setSelectedDate={setSelectedDate} />}
                        </main>
                        
                        {/* Footer: Hidden on Print */}
                        <footer className="text-center p-4 text-gray-500 text-sm">
                            User ID (Auth Token): <span className="font-mono bg-gray-200 px-1 rounded">{userId}</span>
                        </footer>
                    </div>
                </StaffProvider>
            );
        }

        function NavButton({ label, isActive, onClick }) {
            const baseClasses = "py-2 px-4 rounded-md font-medium text-sm sm:text-base transition-all duration-200";
            const activeClasses = "bg-blue-600 text-white shadow-md";
            const inactiveClasses = "text-gray-600 hover:bg-gray-200";
            return ( <button onClick={onClick} className={`${baseClasses} ${isActive ? activeClasses : inactiveClasses}`}>{label}</button> );
        }

        // --- View 1: Staff & Roster Setup (Combined and Consolidated) ---
        function StaffAndRosterSetupView({ selectedDate, setSelectedDate }) {
            return (
                <div className="space-y-6">
                    {/* Section 1: Consolidated Staff Pool, Daily Attendance, and Assignment Management */}
                    <ConsolidatedStaffManagement selectedDate={selectedDate} setSelectedDate={setSelectedDate} />
                </div>
            );
        }
        
        // --- Helper: Get Staff Assignments for Display ---
        function getStaffAssignments(staffId, sequenceMap, allAssignmentKeys) {
            const assignedKeys = [];
            
            for (const key of allAssignmentKeys) {
                const staffIds = sequenceMap[key];
                if (staffIds && Array.isArray(staffIds) && staffIds.includes(staffId)) {
                    // Ensure keys are unique even if staffId exists multiple times due to prior bugs
                    if (!assignedKeys.includes(key)) {
                        assignedKeys.push(key);
                    }
                }
            }
            return assignedKeys;
        }


        // --- Reusable Modal Component ---
        function TeamFilterModal({ isOpen, onClose, teamOptions, currentFilter, onSelectTeam }) {
            if (!isOpen) return null;

            const SHOW_ALL_FILTER_VALUE = 'SHOW_ALL';
            const SHOW_SCHEDULED_FILTER_VALUE = 'SHOW_SCHEDULED';

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={e => e.stopPropagation()}>
                        <div className="flex justify-between items-center border-b pb-3 mb-4">
                            <h3 className="text-lg font-bold text-gray-800">Filter Staff by Team</h3>
                            <button onClick={onClose} className="text-gray-500 hover:text-gray-900 text-xl font-bold">&times;</button>
                        </div>

                        <div className="space-y-2">
                            {/* Option 1: Show All (Default) */}
                            <button 
                                onClick={() => { onSelectTeam(SHOW_ALL_FILTER_VALUE); onClose(); }}
                                className={`w-full py-2 px-4 text-left rounded-md font-semibold transition-all ${
                                    currentFilter === SHOW_ALL_FILTER_VALUE 
                                    ? 'bg-blue-600 text-white shadow-md' 
                                    : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                                }`}
                            >
                                Show All Staff
                            </button>
                            
                            {/* **NEW OPTION**: Show Scheduled IDs */}
                            <button 
                                onClick={() => { onSelectTeam(SHOW_SCHEDULED_FILTER_VALUE); onClose(); }}
                                className={`w-full py-2 px-4 text-left rounded-md font-semibold transition-all ${
                                    currentFilter === SHOW_SCHEDULED_FILTER_VALUE 
                                    ? 'bg-green-600 text-white shadow-md' 
                                    : 'bg-white border border-green-300 hover:bg-green-50 text-green-700'
                                }`}
                            >
                                Show Only Scheduled Staff
                            </button>

                            {/* Option 3: Clear Filter / Show None */}
                            <button 
                                onClick={() => { onSelectTeam("")
                                 onClose(); }}
                                className={`w-full py-2 px-4 text-left rounded-md font-semibold transition-all ${
                                    currentFilter === "" 
                                    ? 'bg-red-600 text-white shadow-md' 
                                    : 'bg-white border hover:bg-red-50 text-red-700'
                                }`}
                            >
                                Clear Filter (Show None)
                            </button>


                            <div className="border-t pt-2 mt-2">
                                <p className="text-sm font-bold text-gray-600 my-2">-- Filter by Specific Team --</p>
                                {/* Team Options */}
                                {teamOptions.map(t => (
                                    <button
                                        key={t.docId}
                                        onClick={() => { onSelectTeam(t.docId); onClose(); }}
                                        className={`w-full py-2 px-4 text-left rounded-md font-semibold transition-all ${
                                            currentFilter === t.docId 
                                            ? 'bg-blue-600 text-white shadow-md' 
                                            : 'bg-white border hover:bg-gray-50 text-gray-700'
                                        }`}
                                    >
                                        {t.name}
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }
        
        // --- STAFF ASSIGNMENT CARD (NEW Sub-Component for Cleanliness) ---
        function StaffAssignmentCard({ staff, isScheduled, scheduledSet, handleAttendanceToggle, handleRemoveStaff, staffTypeMap, staffToSequenceMap, sequenceMap, locationBufferMap, rosterMode, handleSequenceChange, handleUnassign, handleLocationBufferChange, availableAssignmentKeys }) {
            
            const { ALL_ASSIGNMENT_KEYS, OVERRIDE_LOCATIONS } = useContext(StaffContext);
            const [isExpanded, setIsExpanded] = useState(false); // State for expansion
            
            const AssignmentDropdown = ({ staffId, isScheduled, scheduledSet }) => {
                // CRITICAL FIX: Use helper function to get current assignments from sequenceMap
                const assignedKeys = getStaffAssignments(staffId, sequenceMap, ALL_ASSIGNMENT_KEYS);
                const assignedKey = assignedKeys.length > 0 ? assignedKeys[0] : "";
                const isMultipleAssignmentDisplay = assignedKeys.length > 1;

                const staffType = staffTypeMap.get(staffId);
                
                // CRITICAL GUARD: If staffId is missing or scheduledSet is undefined, bail out.
                if (!staff.id || !staff.name || !scheduledSet) return null; 
                
                // --- Group Assignments based on current mode ---
                const isAutoMode = rosterMode === ROSTER_MODES.AUTO_SEQUENCE;
                
                const currentSentryKeys = isAutoMode ? SENTRY_SEQUENCE_KEYS : SENTRY_LOCATION_KEYS;
                
                const sentryAssignmentKeys = availableAssignmentKeys.filter(key => 
                    currentSentryKeys.includes(key)
                ).sort();
                const foyerAssignmentKeys = availableAssignmentKeys.filter(key => FOYER_ASSIGNMENT_KEYS.includes(key)).sort();
                const securityAssignmentKeys = availableAssignmentKeys.filter(key => SECURITY_ASSIGNMENT_KEYS.includes(key)).sort();
                
                let colorClass = 'bg-white';
                if (staffType === 'buffer' && assignedKey && !isMultipleAssignmentDisplay) {
                    colorClass = 'bg-purple-100 border-purple-300';
                }
                else if (isMultipleAssignmentDisplay) {
                    // Display the concatenation for multiple assignments
                    colorClass = 'bg-purple-200 border-purple-400 font-bold';
                } else if (assignedKey) {
                    // Standard single assignment colors
                    const isSentry = SENTRY_SEQUENCE_KEYS.includes(assignedKey) || SENTRY_LOCATION_KEYS.includes(assignedKey);
                    const isFoyer = FOYER_ASSIGNMENT_KEYS.includes(assignedKey);
                    const isSecurity = SECURITY_ASSIGNMENT_KEYS.includes(assignedKey);

                    if (isSentry) colorClass = 'bg-blue-100 border-blue-300';
                    else if (isFoyer) colorClass = 'bg-green-100 border-green-300';
                    else if (isSecurity) colorClass = 'bg-orange-100 border-orange-300';
                } else {
                    colorClass = 'bg-gray-50 border-gray-300';
                }

                
                // --- Option Rendering Logic ---
                const renderOptions = (keys) => {
                    return keys.map(key => {
                        // CRITICAL FIX: Ensure sequenceMap[key] is an array, default to empty array
                        const staffIdsInSlot = sequenceMap[key] || [];
                        if (!Array.isArray(staffIdsInSlot)) return null;

                        // Check if the staff ID is currently assigned to this specific key (by looking at the DB map)
                        const isThisStaffInSlot = staffIdsInSlot.includes(staffId);
                        
                        let isDisabled = false;
                        // Use scheduledSet to filter staff *actually* present today
                        const currentScheduledStaffInSlot = staffIdsInSlot.filter(id => scheduledSet.has(id));
                        
                        // Check occupancy rules for non-selected slots
                        if (!isThisStaffInSlot) {
                            const typesInSlot = currentScheduledStaffInSlot.map(id => staffTypeMap.get(id));
                            
                            if (staffType === 'permanent' || !staffType) {
                                // Permanent staff cannot take occupied slot
                                if (currentScheduledStaffInSlot.length > 0) {
                                     isDisabled = true;
                                }
                            } else if (staffType === 'buffer') {
                                // Buffer can only join a slot with one permanent staff
                                const permCount = typesInSlot.filter(t => t === 'permanent' || !t).length;
                                const bufferCount = typesInSlot.filter(t => t === 'buffer').length;
                                
                                // If the slot already has a permanent and a buffer, or two buffers, deny.
                                if ((permCount >= 1 && bufferCount >= 1) || bufferCount >= 2) {
                                    isDisabled = true;
                                }
                            }
                        }
                        
                        return (
                            <option key={key} value={key} disabled={isDisabled} className="truncate">
                                {key} {currentScheduledStaffInSlot.length > 0 ? `(${currentScheduledStaffInSlot.length} taken)` : ""}
                            </option>
                        );
                    }).filter(Boolean); // Filter out nulls from malformed data
                };
                
                // Determine the current selection display 
                let primaryAssignmentDisplay;
                if (isMultipleAssignmentDisplay) {
                    primaryAssignmentDisplay = `${assignedKeys.join(', ')} (Multiple)`;
                } else if (assignedKey) {
                    primaryAssignmentDisplay = assignedKey;
                } else if (!isAutoMode) {
                    primaryAssignmentDisplay = "Fixed Location";
                } else {
                    primaryAssignmentDisplay = "Rotation Key";
                }
                
                // Determine buffer override display
                const bufferOverrideDisplay = locationBufferMap[staffId] ? `Override: ${locationBufferMap[staffId]}` : "-- No Override --";

                // Determine the value to set on the <select> element
                const selectValue = assignedKey || "";

                return (
                    <div className="w-full space-y-2 mt-2">
                        {/* --- Primary Assignment Dropdown (Always Visible when Scheduled) --- */}
                        <select
                            value={selectValue} 
                            onChange={(e) => {
                                const newKey = e.target.value;
                                if (newKey === "") {
                                    handleUnassign(staffId); 
                                } else {
                                    handleSequenceChange(newKey, staffId);
                                }
                            }}
                            // The select's value is the single assigned key, or empty string if multiple/none
                            className={`p-1 border rounded-md shadow-sm w-full text-sm truncate font-semibold transition-all 
                                ${assignedKey || isMultipleAssignmentDisplay ? colorClass : 'bg-gray-50 border-gray-400 text-gray-700'}`}
                            disabled={!isScheduled}
                            title={isAutoMode ? "Primary Assignment (Rotation Key)" : "Primary Assignment (Fixed Location)"}
                        >
                            {/* Display the current assigned key(s) as the selected option */}
                            {/* This option is used for display when multiple are selected or when none is selected */}
                            <option value={selectValue} disabled={isMultipleAssignmentDisplay || assignedKey === ""}>
                                {primaryAssignmentDisplay}
                            </option>
                            
                            {/* Option to clear all when multiple are assigned */}
                            {isMultipleAssignmentDisplay && (
                                <option value="">--- CLEAR ALL ({assignedKeys.join(', ')}) ---</option>
                            )}
                            
                            <optgroup label={isAutoMode ? "SENTRY (Rotation Key)" : "SENTRY (Fixed Location)"}>
                                {renderOptions(sentryAssignmentKeys)}
                            </optgroup>

                            <optgroup label="FOYER">
                                {renderOptions(foyerAssignmentKeys)}
                            </optgroup>

                            <optgroup label="SECURITY">
                                {renderOptions(securityAssignmentKeys)}
                            </optgroup>
                            
                        </select>
                        
                        {/* --- Buffer Override Dropdown (Only for Buffer Staff) --- */}
                        {staffType === 'buffer' && (
                            <select
                                value={locationBufferMap[staffId] || ""}
                                onChange={(e) => handleLocationBufferChange(staffId, e.target.value)}
                                className="p-1 border border-purple-400 rounded-md shadow-sm w-full text-sm truncate font-semibold bg-purple-50 text-purple-800"
                                disabled={!isScheduled}
                                title="Buffer Override (Whole Row)"
                            >
                                <option value="">{bufferOverrideDisplay}</option>
                                {OVERRIDE_LOCATIONS.map(loc => (
                                    <option key={loc} value={loc}>{loc}</option>
                                ))}
                            </select>
                        )}
                    </div>
                );
            };

            return (
                <div 
                    key={staff.id}
                    className={`p-3 rounded-lg shadow-md transition-all flex flex-col relative ${
                        isScheduled 
                        ? 'staff-card-scheduled' 
                        : 'staff-card-unscheduled'
                    }`}
                >
                    {/* --- TOP ROW: Staff ID & Expand Button --- */}
                    <div className="flex justify-between items-center w-full mb-1">
                        {/* Staff ID */}
                        <span className="text-lg font-bold text-gray-900 leading-tight block truncate" title={`ID: ${staff.id}`}>
                            {staff.id}
                        </span>
                        
                        {/* Expand/Collapse Button */}
                        <button 
                            onClick={() => setIsExpanded(prev => !prev)}
                            className="text-gray-500 hover:text-blue-600 transition-transform duration-200 p-1"
                            title={isExpanded ? "Collapse details" : "Expand details"}
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" className={`h-5 w-5 transform ${isExpanded ? 'rotate-180 text-blue-600' : 'rotate-0'}`} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                              <path strokeLinecap="round" strokeLinejoin="round" d="M19 9l-7 7-7-7" />
                            </svg>
                        </button>
                    </div>

                    {/* --- EXPANDABLE AREA: Name, Team, Delete Button --- */}
                    {isExpanded && (
                        <div className="w-full border-y border-gray-300 py-2 my-1 space-y-2">
                            {/* Detailed Name */}
                            <p className="text-sm text-gray-700 font-medium truncate" title={`Full Name: ${staff.rawName}`}>{staff.name || 'N/A Name'}</p>
                            
                            {/* Type Badge and Team Name */}
                            <div className="flex justify-between items-center">
                                <span className={`text-xs font-semibold px-2 py-0.5 rounded-full ${
                                    staff.type === 'buffer' ? 'bg-purple-200 text-purple-800' : 'bg-blue-200 text-blue-800'
                                }`}>
                                    {staff.type.toUpperCase()} - {staff.team_name}
                                
                                </span>
                                
                                {/* Delete Button */}
                                <button 
                                    onClick={(e) => { e.stopPropagation(); handleRemoveStaff(staff); }} 
                                    className="text-xs text-red-500 hover:text-red-700 font-bold transition-opacity print-hidden p-1"
                                    title={`Permanently Delete ${staff.name} (${staff.id}) from Pool`}
                                >
                                    Remove Staff
                                </button>
                            </div>
                        </div>
                    )}
                    
                    {/* --- STATUS/TOGGLE ROW (Always Visible) --- */}
                    <div className="flex justify-between items-center mt-2">
                        <p className={`text-xs font-bold ${
                            isScheduled ? 'text-emerald-700' : 'text-red-700'
                        }`}>
                            {isScheduled ? 'SCHEDULED' : 'NOT SCHEDULED'}
                        </p>
                        
                        {/* On/Off Toggle Switch */}
                        <label className="toggle-switch" title={isScheduled ? "Unschedule Staff" : "Schedule Staff"}>
                            <input 
                                type="checkbox" 
                                checked={isScheduled} 
                                onChange={() => handleAttendanceToggle(staff.id)}
                            />
                            <span className="slider"></span>
                        </label>
                    </div>
                    
                    {/* --- DAILY ASSIGNMENT CONTROLS (Always Visible when Scheduled) --- */}
                    {isScheduled && (
                        <AssignmentDropdown 
                            staffId={staff.id} 
                            isScheduled={isScheduled}
                            scheduledSet={scheduledSet}
                            // Assignment Props
                            staffTypeMap={staffTypeMap}
                            staffToSequenceMap={staffToSequenceMap}
                            sequenceMap={sequenceMap}
                            locationBufferMap={locationBufferMap}
                            rosterMode={rosterMode}
                            handleSequenceChange={handleSequenceChange}
                            handleUnassign={handleUnassign}
                            handleLocationBufferChange={handleLocationBufferChange}
                            availableAssignmentKeys={availableAssignmentKeys}
                        />
                    )}
                </div>
            );
        }

        
        // --- CONSOLIDATED STAFF MANAGEMENT COMPONENT (Section 1) ---
        function ConsolidatedStaffManagement({ selectedDate, setSelectedDate }) {
            const { staffPool, dailyAttendance, teamMap, staffTypeMap, loading: staffLoading, scheduledStaff, ALL_ASSIGNMENT_KEYS } = useContext(StaffContext);
            
            // --- ATTENDANCE MANAGEMENT STATES ---
            const [newStaffId, setNewStaffId] = useState("");
            const [newStaffName, setNewStaffName] = useState("");
            const [newStaffType, setNewStaffType] = useState("permanent");
            const [newStaffTeamId, setNewStaffTeamId] = useState("");
            const [localDailyAttendance, setLocalDailyAttendance] = useState([]);
            const [attendanceStatus, setAttendanceStatus] = useState("idle");
            const [attendanceError, setAttendanceError] = useState(null);
            
            // --- ASSIGNMENT MANAGEMENT STATES (MOVED FROM DAILY SEQUENCE) ---
            const [rosterMode, setRosterMode] = useState(ROSTER_MODES.AUTO_SEQUENCE); 
            const [sequenceMap, setSequenceMap] = useState({});
            const [locationBufferMap, setLocationBufferMap] = useState({});
            const [assignmentLoading, setAssignmentLoading] = useState(true);
            const [assignmentStatus, setAssignmentStatus] = useState("idle");
            const [assignmentError, setAssignmentError] = useState(null);
            
            // Filter constants
            const SHOW_ALL_FILTER_VALUE = 'SHOW_ALL';
            const SHOW_SCHEDULED_FILTER_VALUE = 'SHOW_SCHEDULED';
            
            // Filter state: "" means "Show None", 'SHOW_ALL' means show all staff, 'SHOW_SCHEDULED' means only scheduled, team ID means filter by team.
            const [filterTeamId, setFilterTeamId] = useState(SHOW_SCHEDULED_FILTER_VALUE); // Default to showing scheduled staff
            const [isModalOpen, setIsModalOpen] = useState(false);
            
            // --- ATTENDANCE: Sync Firestore attendance data with local state when it changes from the DB ---
            useEffect(() => {
                setLocalDailyAttendance(dailyAttendance);
                setAttendanceStatus("idle");
            }, [dailyAttendance, selectedDate]);
            
            const isAttendanceDirty = useMemo(() => {
                if (localDailyAttendance.length !== dailyAttendance.length) return true;
                const sortedLocal = [...localDailyAttendance].sort();
                const sortedRemote = [...dailyAttendance].sort();
                
                for(let i = 0; i < sortedLocal.length; i++) {
                    if (sortedLocal[i] !== sortedRemote[i]) return true;
                }
                
                return false;
            }, [localDailyAttendance, dailyAttendance]);

            const scheduledSet = useMemo(() => new Set(localDailyAttendance), [localDailyAttendance]);
            
            // **FILTERING**: Filtering Logic adjusted to handle SHOW_SCHEDULED
            const filteredStaff = useMemo(() => {
                if (filterTeamId === SHOW_SCHEDULED_FILTER_VALUE) {
                     return staffPool.filter(staff => scheduledSet.has(staff.id));
                }
                if (filterTeamId === SHOW_ALL_FILTER_VALUE) return staffPool;
                if (filterTeamId === "") return []; // Show None
                
                return staffPool.filter(staff => staff.team_id === filterTeamId);
            }, [staffPool, filterTeamId, scheduledSet]);

            const teamOptions = useMemo(() => {
                return Array.from(teamMap.values()).sort((a, b) => a.name.localeCompare(b.name));
            }, [teamMap]);

            // CRITICAL FIX: Determine display name for the filter button
            const currentFilterName = useMemo(() => {
                if (filterTeamId === SHOW_ALL_FILTER_VALUE) return "Filter: All Staff";
                if (filterTeamId === SHOW_SCHEDULED_FILTER_VALUE) return "Filter: Scheduled Only"; // New display name
                if (filterTeamId === "") return "Filter: None"; 
                
                const team = teamOptions.find(t => t.docId === filterTeamId);
                return team ? `Filter: ${team.name}` : "Filter: Unknown";
            }, [filterTeamId, teamOptions]);


            // --- ASSIGNMENTS: Load Assignments Effect ---
            const allAssignmentKeys = useMemo(() => ALL_ASSIGNMENT_KEYS, []);

            useEffect(() => {
                if (!selectedDate || !db) return;
                setAssignmentLoading(true);
                const docRef = getDocRef(DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                if (!docRef) return;
                
                const unsubscribe = onSnapshot(docRef, (docSnap) => {
                    
                    const defaultMap = {};
                    allAssignmentKeys.forEach(key => defaultMap[key] = []); 
                    
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        
                        // Load and set the Roster Mode
                        setRosterMode(data.rosterMode || ROSTER_MODES.AUTO_SEQUENCE);
                        
                        const loadedMap = data.sequenceMap || {};
                        const scheduledSet = new Set(dailyAttendance); // Use the currently loaded dailyAttendance
                        
                        const cleanedMap = {};
                        Object.keys(loadedMap).forEach(key => {
                            if (allAssignmentKeys.includes(key)) { 
                                let staffIds = Array.isArray(loadedMap[key]) ? loadedMap[key] : (loadedMap[key] ? [loadedMap[key]] : []);
                                
                                // CRITICAL FIX: Ensure staffIds are unique and scheduled before setting (preventing E1, E1 issue)
                                const uniqueAndScheduledIds = [...new Set(staffIds)]
                                    .map(id => String(id))
                                    .filter(id => scheduledSet.has(id));
                                
                                cleanedMap[key] = uniqueAndScheduledIds;
                            }
                        });
                        setSequenceMap(cleanedMap);
                        setLocationBufferMap(data.locationBufferMap || {});
                    } else {
                        setRosterMode(ROSTER_MODES.AUTO_SEQUENCE);
                        setSequenceMap(defaultMap);
                        setLocationBufferMap({});
                    }
                    setAssignmentLoading(false);
                }, (err) => {
                    console.error("Error loading daily assignments: ", err);
                    setAssignmentError("Failed to load daily assignments. Check authentication/permissions.");
                    setAssignmentLoading(false);
                });
                
                // This effect needs to re-run if dailyAttendance changes to correctly filter assignments
                return () => unsubscribe();
            }, [selectedDate, allAssignmentKeys, dailyAttendance]); 

            // --- ASSIGNMENTS: Memoized Data (Simplifed for Display) ---
            const staffToSequenceMap = useMemo(() => {
                const map = {};
                for (const key of ALL_ASSIGNMENT_KEYS) {
                    let staffIds = sequenceMap[key]; 
                    if (staffIds) {
                        if (!Array.isArray(staffIds)) staffIds = [staffIds];
                        staffIds.forEach(staffId => {
                            // Only store the first assignment key found for display purposes
                            if (!map[staffId]) {
                                map[staffId] = key; 
                            }
                        });
                    }
                }
                return map;
            }, [sequenceMap, ALL_ASSIGNMENT_KEYS]);


            const availableAssignmentKeys = useMemo(() => {
                let sentryKeys;
                if (rosterMode === ROSTER_MODES.AUTO_SEQUENCE) {
                    sentryKeys = SENTRY_SEQUENCE_KEYS;
                } else {
                    sentryKeys = SENTRY_LOCATION_KEYS;
                }
                return [...sentryKeys, ...FOYER_ASSIGNMENT_KEYS, ...SECURITY_ASSIGNMENT_KEYS];
            }, [rosterMode]);
            
            const isAssignmentDirty = useMemo(() => {
                // Determine if assignment data has changed
                // This requires deep comparison of sequenceMap and locationBufferMap against remote data,
                // but for simplicity in a live app, relying on the 'unsaved' status (set by handlers) is sufficient.
                return assignmentStatus === 'unsaved';
            }, [assignmentStatus]);

            // --- ASSIGNMENTS: Handlers (CRITICAL: Buffer multi-assignment logic kept here) ---
            const handleSequenceChange = (keyToAssign, staffId) => {
                setAssignmentStatus("unsaved");
                const newMap = { ...sequenceMap };
                const staffType = staffTypeMap.get(staffId);
                
                // Clear assignment from ALL possible slots (Sequence AND Location keys)
                const allUsedKeys = ALL_ASSIGNMENT_KEYS;

                if (staffType !== 'buffer') {
                    // PERMANENT STAFF: Remove from any other key first (ensuring single assignment)
                     allUsedKeys.forEach(key => {
                         if (newMap[key] && newMap[key].includes(staffId)) {
                             newMap[key] = newMap[key].filter(id => id !== staffId);
                         }
                     });
                } 
                // NOTE: If staffType IS 'buffer', we SKIP the full clearing step entirely, 
                // to restore the desired multi-assignment functionality.
                
                const currentIdsInSlot = newMap[keyToAssign] || [];
                
                // Add to new slot if not already there (prevents E1, E1 duplicates for buffers)
                if (!currentIdsInSlot.includes(staffId)) {
                    newMap[keyToAssign] = [...currentIdsInSlot, staffId];
                }
                
                setSequenceMap(newMap);
            };
            
            const handleUnassign = (staffId) => {
                setAssignmentStatus("unsaved");
                const newMap = { ...sequenceMap };
                
                // Completely remove staffId from ALL slots
                ALL_ASSIGNMENT_KEYS.forEach(key => {
                     if (newMap[key] && newMap[key].includes(staffId)) {
                         newMap[key] = newMap[key].filter(id => id !== staffId);
                     }
                });
                
                setSequenceMap(newMap);
            };

            const handleLocationBufferChange = (bufferStaffId, location) => {
                setAssignmentStatus("unsaved");
                const newMap = { ...locationBufferMap };
                
                if (location === "") {
                    delete newMap[bufferStaffId];
                } else {
                    newMap[bufferStaffId] = location;
                }
                setLocationBufferMap(newMap);
            };

            const handleClearAllAssignments = async () => {
                if (!db) return setAssignmentError("Database not available.");
                
                // Use a custom confirmation dialog replacement
                const confirmClear = window.confirm("Are you sure you want to CLEAR ALL daily assignments and buffer overrides for this date? This action will NOT affect the Scheduled Staff list.");

                if (confirmClear) {
                    setAssignmentStatus("saving");
                    setAssignmentError(null);
                    
                    try {
                        const docRef = getDocRef(DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                        if (!docRef) throw new Error("Could not create assignment document reference.");

                        const emptySequenceMap = {};
                        ALL_ASSIGNMENT_KEYS.forEach(key => emptySequenceMap[key] = []);

                        await updateDoc(docRef, {
                            sequenceMap: emptySequenceMap,
                            locationBufferMap: {},
                            updatedAt: new Date().toISOString(),
                        }, { merge: true });

                        setSequenceMap(emptySequenceMap);
                        setLocationBufferMap({});
                        setAssignmentStatus("saved");
                        setTimeout(() => setAssignmentStatus("idle"), 2000);

                    } catch (err) {
                        console.error("Error clearing daily setup: ", err);
                        setAssignmentError("Failed to clear daily assignments. Check path/permissions.");
                        setAssignmentStatus("error");
                    }
                }
            };

            const handleSaveAssignments = async () => {
                if (!db) return setAssignmentError("Database not available.");
                setAssignmentStatus("saving");
                setAssignmentError(null);
                try {
                    const docRef = getDocRef(DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                    if (!docRef) throw new Error("Could not create assignment document reference.");

                    // Final clean before saving (only scheduled staff remain)
                    const scheduledSet = new Set(scheduledStaff.map(s => s.id));
                    const cleanedSequenceMap = {};
                    
                    // Only save assignments relevant to the selected mode PLUS security/foyer which are always used
                    const keysToSave = new Set(availableAssignmentKeys);
                    
                    Object.entries(sequenceMap).forEach(([key, staffIds]) => {
                        // Only save data assigned to keys relevant in the current mode (or keys in other fixed assignments)
                        if (keysToSave.has(key) || FOYER_ASSIGNMENT_KEYS.includes(key) || SECURITY_ASSIGNMENT_KEYS.includes(key)) {
                            // Ensure data saved to Firestore is cleaned (no duplicates)
                            const uniqueAndScheduledIds = [...new Set(staffIds)]
                                .filter(id => scheduledSet.has(id));
                            cleanedSequenceMap[key] = uniqueAndScheduledIds;
                        }
                    });
                    
                    const cleanedLocationBufferMap = {};
                    Object.entries(locationBufferMap).forEach(([key, location]) => {
                        if (scheduledSet.has(key)) { // Key here is the buffer ID
                             cleanedLocationBufferMap[key] = location;
                        }
                    });
                    
                    await setDoc(docRef, { 
                        rosterMode: rosterMode,
                        sequenceMap: cleanedSequenceMap,
                        locationBufferMap: cleanedLocationBufferMap 
                    });
                    
                    setSequenceMap(cleanedSequenceMap);
                    setLocationBufferMap(cleanedLocationBufferMap);
                    
                    setAssignmentStatus("saved");
                    setTimeout(() => setAssignmentStatus("idle"), 2000);
                } catch (err) {
                    console.error("Error saving daily setup: ", err);
                    setAssignmentError("Failed to save daily assignments. Check path/permissions.");
                    setAssignmentStatus("error");
                }
            };


            // --- POOL MANAGEMENT: Handlers ---
            const handleAddStaff = async () => {
                const id = String(newStaffId.trim());
                const name = newStaffName.trim();
                const team_id = newStaffTeamId;
                const is_buffer = newStaffType === 'buffer';

                if (!id || !name || !team_id) {
                     setAttendanceError("Staff ID, Name, and Team are required.");
                     setTimeout(() => setAttendanceError(null), 3000);
                     return;
                }
                
                const cleanedId = cleanStaffId(id);

                if (staffPool.find(s => s.id === cleanedId)) {
                    setAttendanceError(`Staff ID ${cleanedId} already exists (or T-prefixed version exists).`);
                    setTimeout(() => setAttendanceError(null), 3000);
                    return;
                }
                
                try {
                    const empDocRef = getDocRef(EMPLOYEES_COLLECTION, id); 
                    if (!empDocRef) throw new Error("Could not create employee document reference.");
                    
                    await setDoc(empDocRef, { 
                        emp_id: id, 
                        name: name,
                        team_id: team_id,
                        role: 'member', 
                        is_buffer: is_buffer, 
                        docId: id
                    });
                    
                    setNewStaffId("");
                    setNewStaffName("");
                    setNewStaffTeamId("");
                    
                    // Add the CLEANED ID to the local attendance list
                    setLocalDailyAttendance(prev => [...prev, cleanedId].sort());
                    setAttendanceStatus("unsaved"); 
                    setAttendanceError(null);
                } catch (err) {
                    console.error("Error adding staff: ", err);
                    setAttendanceError(`Failed to add staff ID ${id}. Check data path/permissions.`);
                    setAttendanceStatus("error");
                    setTimeout(() => setAttendanceError(null), 5000);
                }
            };
            
            const handleRemoveStaff = async (staffObject) => {
                if (!db) return setAttendanceError("Database not available.");
                
                // Use a custom confirmation dialog replacement
                const confirmDelete = window.confirm(`Are you absolutely sure you want to permanently DELETE staff ID ${staffObject.id} (${staffObject.name}) from the ENTIRE Staff Pool? This action cannot be undone.`);

                if (confirmDelete) {
                    try {
                        setAttendanceStatus("deleting");
                        
                        // 1. Remove from the Employees Collection (Pool)
                        const empDocRef = getDocRef(EMPLOYEES_COLLECTION, staffObject.docId); 
                        if (!empDocRef) throw new Error("Could not create delete document reference.");
                        await deleteDoc(empDocRef); 
                        
                        // 2. Remove from the local attendance list immediately
                        setLocalDailyAttendance(prev => prev.filter(staffId => staffId !== staffObject.id));
                        
                        // 3. Remove assignment immediately
                        handleUnassign(staffObject.id);
                        
                        setAttendanceStatus("idle");
                        setAttendanceError(null);
                    } catch (err) {
                        console.error("Error removing staff: ", err);
                        setAttendanceError(`Failed to remove staff ID ${staffObject.id}. Check data path/permissions.`);
                        setAttendanceStatus("error");
                        setTimeout(() => setAttendanceError(null), 5000);
                    }
                }
            };

            // --- ATTENDANCE: Handlers ---
            const handleAttendanceToggle = (staffId) => {
                setAttendanceStatus("unsaved");
                let newAttendance;
                if (scheduledSet.has(staffId)) {
                    newAttendance = localDailyAttendance.filter(id => id !== staffId);
                    // Also clear assignment when unscheduling
                    handleUnassign(staffId); 
                } else {
                    newAttendance = [...localDailyAttendance, staffId].sort();
                }
                setLocalDailyAttendance(newAttendance);
            };
            
            const handleUnscheduleAll = () => {
                const filteredIds = new Set(filteredStaff.map(s => s.id));
                const newAttendance = localDailyAttendance.filter(id => !filteredIds.has(id));
                
                // Unassign all removed staff members
                filteredStaff.forEach(staff => handleUnassign(staff.id));
                
                setLocalDailyAttendance(newAttendance); 
                setAttendanceStatus("unsaved"); 
            };
            
            const handleScheduleAll = () => {
                const filteredIds = filteredStaff.map(s => s.id);
                const combinedIds = [...new Set([...localDailyAttendance, ...filteredIds])].sort();
                
                setLocalDailyAttendance(combinedIds);
                setAttendanceStatus("unsaved"); 
            };
            
            const handleSaveAttendance = async () => {
                if (!db) return setAttendanceError("Database not available.");
                setAttendanceStatus("saving");
                setAttendanceError(null);
                try {
                    const docRef = getDocRef(DAILY_ATTENDANCE_COLLECTION, selectedDate);
                    if (!docRef) throw new Error("Could not create attendance document reference.");
                    
                    const currentStaffIds = new Set(staffPool.map(s => s.id));
                    const cleanedAttendance = localDailyAttendance
                                            .filter(id => currentStaffIds.has(id))
                                            .map(id => String(id)); 

                    await setDoc(docRef, { 
                        scheduledStaff: cleanedAttendance,
                        updatedAt: new Date().toISOString(),
                    });
                    
                    setLocalDailyAttendance(cleanedAttendance);
                    setAttendanceStatus("saved");
                    setTimeout(() => setAttendanceStatus("idle"), 2000);
                } catch (err) {
                    console.error("FATAL SAVE ERROR (Attendance): ", err);
                    setAttendanceError("Failed to save daily attendance. Check path/permissions.");
                    setAttendanceStatus("error");
                }
            };
            
            const isLoading = staffLoading || assignmentLoading;

            return (
                <div className="bg-white p-2 sm:p-6 rounded-lg shadow-lg">
                    <h2 className="text-xl font-bold mb-4 text-gray-800">Staff Pool & Daily Assignment Management (Consolidated)</h2>
                    
                    <TeamFilterModal 
                        isOpen={isModalOpen}
                        onClose={() => setIsModalOpen(false)}
                        teamOptions={teamOptions}
                        currentFilter={filterTeamId}
                        onSelectTeam={setFilterTeamId}
                    />

                    <div className="setup-tools">
                        {/* Date Selector */}
                        <div className="mb-4 date-selector flex flex-col sm:flex-row items-start sm:items-center gap-2">
                            <label htmlFor="roster-date-attendance" className="font-medium text-gray-700 text-lg">Date:</label>
                            <input
                                type="date"
                                id="roster-date-attendance"
                                value={selectedDate}
                                onChange={(e) => setSelectedDate(e.target.value)}
                                className="border-gray-300 rounded-md shadow-sm p-2 text-lg"
                            />
                        </div>

                        {/* Roster Mode Selector - COMPRESSED */}
                        <div className="roster-mode-selector p-4 mb-6 border rounded-lg bg-yellow-50 shadow-inner">
                            <h3 className="text-base font-semibold text-gray-700 mb-2">Roster Generation Mode:</h3>
                            <div className="radio-group flex flex-wrap gap-2">
                                <input type="radio" id="mode-auto" name="rosterMode" value={ROSTER_MODES.AUTO_SEQUENCE} 
                                    checked={rosterMode === ROSTER_MODES.AUTO_SEQUENCE} 
                                    onChange={(e) => { setRosterMode(e.target.value); setAssignmentStatus("unsaved"); }}
                                    className="hidden"
                                />
                                <label htmlFor="mode-auto" className="cursor-pointer border border-blue-300 rounded-md py-2 px-3 text-sm font-semibold text-blue-800 bg-white hover:bg-blue-50 transition-all">
                                    Auto-Sequence
                                    <p className="text-xs font-normal text-gray-500 mt-1 hidden sm:block">Standard Rotation</p>
                                </label>

                                <input type="radio" id="mode-manual" name="rosterMode" value={ROSTER_MODES.MANUAL_LOCATION_FIXED} 
                                    checked={rosterMode === ROSTER_MODES.MANUAL_LOCATION_FIXED} 
                                    onChange={(e) => { setRosterMode(e.target.value); setAssignmentStatus("unsaved"); }}
                                    className="hidden"
                                />
                                <label htmlFor="mode-manual" className="cursor-pointer border border-blue-300 rounded-md py-2 px-3 text-sm font-semibold text-blue-800 bg-white hover:bg-blue-50 transition-all">
                                    Manual Fixed
                                    <p className="text-xs font-normal text-gray-500 mt-1 hidden sm:block">Fixed Location All Night</p>
                                </label>
                            </div>
                        </div>

                        {/* Add Staff Tool - COMPRESSED */}
                        <div className="flex flex-col gap-2 mb-6 p-4 border rounded-lg bg-blue-50">
                            <h3 className="text-base font-semibold text-gray-700">Add New Employee to Pool:</h3>
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
                                <input
                                    type="text"
                                    value={newStaffId}
                                    onChange={(e) => setNewStaffId(e.target.value)}
                                    className="p-2 border border-gray-300 rounded-md shadow-sm"
                                    placeholder="Service ID"
                                    title="Service ID (e.g., T12268 or 12268)"
                                />
                                <input
                                    type="text"
                                    value={newStaffName}
                                    onChange={(e) => setNewStaffName(e.target.value)}
                                    className="p-2 border border-gray-300 rounded-md shadow-sm"
                                    placeholder="Employee Name"
                                    title="Employee Name (e.g., CPL (APF) JANE DOE)"
                                />
                                <select 
                                    value={newStaffTeamId}
                                    onChange={(e) => setNewStaffTeamId(e.target.value)}
                                    className="p-2 border border-gray-300 rounded-md shadow-sm bg-white"
                                    disabled={isLoading || teamOptions.length === 0}
                                    title="Select Team"
                                >
                                    <option value="">{isLoading ? 'Loading...' : 'Team'}</option>
                                    {teamOptions.map(t => (
                                        <option key={t.docId} value={t.docId}>{t.name}</option>
                                    ))}
                                </select>
                                <select 
                                    value={newStaffType}
                                    onChange={(e) => setNewStaffType(e.target.value)}
                                    className="p-2 border border-gray-300 rounded-md shadow-sm bg-white"
                                    title="Staff Type"
                                >
                                    <option value="permanent">Permanent</option>
                                    <option value="buffer">Buffer</option>
                                </select>
                            </div>
                            <button onClick={handleAddStaff} className="py-2 px-4 bg-green-600 text-white rounded-md shadow-md font-medium hover:bg-green-700 mt-2">Add Staff to Pool</button>
                        </div>
                    </div>
                    
                    {attendanceError && <div className="text-red-600 bg-red-100 p-3 rounded-md mb-4">{attendanceError}</div>}
                    {assignmentError && <div className="text-red-600 bg-red-100 p-3 rounded-md mb-4">{assignmentError}</div>}

                    {isLoading && <p className="text-center p-4 text-2xl text-blue-600 font-semibold">Loading Staff and Assignment Data...</p>}
                    
                    {!isLoading && (
                        <div className="flex flex-col gap-2 p-4 rounded-lg border border-gray-200">
                             <div className="flex flex-wrap justify-between items-center mb-4 border-b pb-2">
                                
                                <div className="flex flex-col sm:flex-row items-start sm:items-center gap-2">
                                    <span className="font-bold text-lg text-gray-800">
                                        Total Staff: {staffPool.length} | Scheduled: {localDailyAttendance.length}
                                    </span>
                                    
                                    {/* Filter Button */}
                                    <button 
                                        onClick={() => setIsModalOpen(true)}
                                        className="filter-control-button py-2 px-4 text-sm font-semibold rounded-md shadow-sm flex items-center gap-2 transition-colors duration-150 bg-white border border-gray-300 hover:bg-gray-100"
                                    >
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707v7l-4 4v-7a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" /></svg>
                                        <span className="text-gray-800 font-bold">{currentFilterName}</span>
                                    </button>
                                </div>

                                <div className="flex space-x-2 setup-tools mt-2 sm:mt-0">
                                     <button 
                                        onClick={handleScheduleAll}
                                        disabled={attendanceStatus === 'saving' || filteredStaff.length === 0}
                                        className="py-2 px-4 text-sm bg-emerald-600 text-white rounded-md shadow-md hover:bg-emerald-700 disabled:bg-gray-400"
                                        title={filterTeamId ? `Schedule all ${filteredStaff.length} staff in current filter` : `Schedule all ${staffPool.length} staff`}
                                    >
                                        Schedule All ({filteredStaff.length})
                                    </button>
                                    <button 
                                        onClick={handleUnscheduleAll}
                                        disabled={attendanceStatus === 'saving' || filteredStaff.length === 0}
                                        className="py-2 px-4 text-sm bg-red-600 text-white rounded-md shadow-md hover:bg-red-700 disabled:bg-gray-400"
                                        title={filterTeamId ? `Unschedule all ${filteredStaff.length} staff in current filter` : `Unschedule all ${staffPool.length} staff`}
                                    >
                                    Unschedule All ({filteredStaff.length})
                                    </button>
                                </div>
                             </div>
                            
                            <div className="staff-pool-grid grid gap-3">
                                {staffPool.length === 0 && <p className="col-span-full text-center text-gray-500">No employees found in the 'employees' collection.</p>}
                                
                                {/* Display instruction based on filter */}
                                {filterTeamId === "" && (
                                    <p className="col-span-full text-center text-gray-500 p-8 border rounded-lg bg-gray-100">
                                        No staff visible. Click **Filter: None** to select **Show All Staff**, **Show Only Scheduled Staff**, or a specific team.
                                    </p>
                                )}
                                
                                {filteredStaff.map(staff => {
                                    const isScheduled = scheduledSet.has(staff.id);
                                    
                                    if (!staff.id || !staff.name) return null;
                                    
                                    return (
                                        <StaffAssignmentCard 
                                            key={staff.id}
                                            staff={staff}
                                            isScheduled={isScheduled}
                                            scheduledSet={scheduledSet}
                                            handleAttendanceToggle={handleAttendanceToggle}
                                            handleRemoveStaff={handleRemoveStaff}
                                            
                                            // Assignment Props
                                            staffTypeMap={staffTypeMap}
                                            staffToSequenceMap={staffToSequenceMap}
                                            sequenceMap={sequenceMap}
                                            locationBufferMap={locationBufferMap}
                                            rosterMode={rosterMode}
                                            handleSequenceChange={handleSequenceChange}
                                            handleUnassign={handleUnassign}
                                            handleLocationBufferChange={handleLocationBufferChange}
                                            availableAssignmentKeys={availableAssignmentKeys}
                                        />
                                    );
                                })}
                            </div>
                        </div>
                    )}
                    
                    {/* --- Save Controls for Attendance and Assignments (SINGLE-LINE SAVE BAR) --- */}
                    <div className="mt-6 border-t pt-4 action-buttons">
                        
                        <div className="flex flex-wrap justify-end items-center gap-2 sm:gap-4 p-2 sm:p-0">
                            
                            {/* Clear Button (Left-most, wraps first) */}
                            <button
                                onClick={handleClearAllAssignments}
                                disabled={assignmentStatus === 'saving' || isLoading}
                                className="order-1 py-2 px-3 sm:px-4 bg-red-600 text-white rounded-md shadow-md font-medium hover:bg-red-700 disabled:bg-gray-400 text-sm flex items-center gap-1"
                                title="Clear all primary assignments and overrides"
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
                                <span className="hidden sm:inline">Clear All</span>
                            </button>


                            {/* Attendance Save Button/Status (Middle/Right) */}
                            <div className="order-2 flex items-center gap-1 bg-gray-50 p-1 rounded-md sm:bg-transparent sm:p-0">
                                <span className={`text-xs font-semibold w-10 text-right ${isAttendanceDirty ? 'text-yellow-700' : attendanceStatus === 'saved' ? 'text-green-600' : 'text-gray-500'}`}>
                                    {isAttendanceDirty ? 'Unsaved' : attendanceStatus === 'saved' ? 'Saved!' : ''}
                                </span>
                                <button
                                    onClick={handleSaveAttendance}
                                    disabled={attendanceStatus === 'saving' || isLoading || !isAttendanceDirty}
                                    className="py-2 px-3 sm:px-4 bg-blue-600 text-white rounded-md shadow-md font-medium hover:bg-blue-700 disabled:bg-gray-400 text-sm"
                                >
                                    Save Attendance
                                </button>
                            </div>

                            {/* Assignment Save Button/Status (Right-most) */}
                            <div className="order-3 flex items-center gap-1 bg-gray-50 p-1 rounded-md sm:bg-transparent sm:p-0">
                                <span className={`text-xs font-semibold w-10 text-right ${isAssignmentDirty ? 'text-yellow-700' : assignmentStatus === 'saved' ? 'text-green-600' : 'text-gray-500'}`}>
                                    {isAssignmentDirty ? 'Unsaved' : assignmentStatus === 'saved' ? 'Saved!' : ''}
                                </span>
                                <button
                                    onClick={handleSaveAssignments}
                                    disabled={assignmentStatus === 'saving' || isLoading || !isAssignmentDirty}
                                    className="py-2 px-3 sm:px-4 bg-indigo-600 text-white rounded-md shadow-md font-medium hover:bg-indigo-700 disabled:bg-gray-400 text-sm"
                                >
                                    Save Assignments
                                </button>
                            </div>

                        </div>
                    </div>
                </div>
            );
        }

        // --- View 2: Roster View (Sequence Logic) ---
        function RosterView({ selectedDate, setSelectedDate }) {
            // Variables are destructure here, correctly, at the top level
            const { staffTypeMap, scheduledStaff } = useContext(StaffContext); 
            const [rosterData, setRosterData] = useState(null);
            const [dailyAssignments, setDailyAssignments] = useState(null); 
            const [loading, setLoading] = useState(true);
            const [isGenerating, setIsGenerating] = useState(false); 
            const [isShuffling, setIsShuffling] = useState(false); // NEW: State for shuffle status
            const [error, setError] = useState(null);
            const [isDirty, setIsDirty] = useState(false);
            
            const [highlightedId, setHighlightedId] = useState(null);
            const [focusView, setFocusView] = useState('all');
            
            // NEW: Matrix Editing Mode State
            const [isMatrixEditMode, setIsMatrixEditMode] = useState(false);

            const rosterMode = dailyAssignments?.rosterMode || ROSTER_MODES.AUTO_SEQUENCE;
            
            const handlePrint = () => {
                window.print();
            };
            
            useEffect(() => {
                if (!selectedDate || !db) return; 
                setLoading(true);
                setError(null);
                setIsDirty(false);
                setHighlightedId(null);
                setFocusView('all');

                const assignmentsDocRef = getDocRef(DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                const unsubAssignments = onSnapshot(assignmentsDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        setDailyAssignments(docSnap.data());
                    } else {
                        setDailyAssignments(null);
                    }
                }, (err) => {
                    console.error("Error loading assignments: ", err);
                    setError("Failed to load daily assignments. Check authentication/permissions.");
                });

                const rosterDocRef = getDocRef(DAILY_ROSTER_COLLECTION, selectedDate);
                const unsubRoster = onSnapshot(rosterDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const loadedGrid = docSnap.data().rosterGrid || {};
                        const newRosterData = {};
                        Object.keys(loadedGrid).forEach(pos => {
                            if(Array.isArray(loadedGrid[pos])) {
                                newRosterData[pos] = loadedGrid[pos].map(cell => {
                                    if (typeof cell === 'string' || !cell) {
                                        // Ensure basic cell structure when loading old strings
                                        return { value: cell || "", isAutomated: false }; 
                                    }
                                    return cell;
                                });
                            }
                        });
                        setRosterData(newRosterData);
                    } else {
                        setRosterData(null);
                    }
                    setLoading(false);
                }, (err) => {
                    console.error("Error loading roster: ", err);
                    setError("Failed to load roster data. Check authentication/permissions.");
                    setLoading(false);
                });
                
                return () => {
                    unsubAssignments();
                    unsubRoster();
                };
            }, [selectedDate]);
            
            const manualStandbyRows = useMemo(() => {
                // CRITICAL FIX: Ensure rosterData is an object before accessing keys
                if (!rosterData || typeof rosterData !== 'object') { return []; }
                return Object.keys(rosterData)
                    .filter(key => key.startsWith("OE/ STANDBY-"))
                    .sort(); 
            }, [rosterData]);
            
            const sentryRowsToRender = useMemo(() => {
                 const sentryRows = [...SENTRY_POSITIONS];
                 const standbyRowIndex = sentryRows.indexOf("OE/ STANDBY");
                 if(standbyRowIndex > -1) {
                     sentryRows.splice(standbyRowIndex + 1, 0, ...manualStandbyRows);
                 }
                 return sentryRows;
            }, [manualStandbyRows]);


            const handleGenerateRoster = async (isReset = false) => {
                setIsGenerating(true); // Start generating state
                setError(null);
                
                if (!db) { setError("Database not available."); setIsGenerating(false); return; }
                
                // CRITICAL FIX: If no staff are scheduled, clear the existing roster grid immediately
                if (scheduledStaff.length === 0) {
                     try {
                        const docRef = getDocRef(DAILY_ROSTER_COLLECTION, selectedDate);
                        await setDoc(docRef, { rosterGrid: {}, updatedAt: new Date().toISOString() });
                        setRosterData({});
                        setIsDirty(false);
                        setIsGenerating(false);
                        return;
                    } catch (err) {
                        console.error("Error clearing roster on zero scheduled staff:", err);
                        setError("Failed to clear roster due to a DB error.");
                        setIsGenerating(false);
                        return;
                    }
                }

                if (!dailyAssignments || !dailyAssignments.sequenceMap || !staffTypeMap || staffTypeMap.size === 0) {
                    setError("No assignments or staff types found. Please check Setup and wait for data.");
                    setIsGenerating(false);
                    return;
                }
                
                try {
                    const { sequenceMap, locationBufferMap = {}, rosterMode = ROSTER_MODES.AUTO_SEQUENCE } = dailyAssignments;
                    
                    // Only merge if not resetting the grid entirely
                    const newRosterGrid = (rosterData && !isReset) ? { ...rosterData } : {};
                    
                    const PATROL_1 = "PATROL 1";
                    const PATROL_2 = "PATROL 2";
                    const PERIMETER_1ST_HALF = "PERIMETER PROWLER (1st Half)";
                    const PERIMETER_2ND_HALF = "PERIMETER PROWLER (2nd Half)";


                    // --- 1. SENTRY DEPLOYMENT (Dynamic based on Roster Mode) ---
                    SENTRY_POSITIONS.forEach(pos => {
                        const positionRoster = [];
                        
                        // Skip the Prowler rows for now, as they are populated in step 2.
                        if (pos.startsWith("PERIMETER PROWLER")) return;

                        if (rosterMode === ROSTER_MODES.AUTO_SEQUENCE) {
                            // --- AUTO-SEQUENCE MODE LOGIC (Rotation) ---
                            const letterSequence = SENTRY_POSITION_SEQUENCES[pos]; 
                            
                            if (letterSequence) { 
                                for (let timeIndex = 0; timeIndex < TIME_SLOTS.length; timeIndex++) {
                                    const sequenceKey = letterSequence[timeIndex % 6];
                                    
                                    let idsInSlot = sequenceMap[sequenceKey];
                                    if (!Array.isArray(idsInSlot)) idsInSlot = idsInSlot ? [idsInSlot] : [];

                                    const permanentStaff = idsInSlot.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                                    // CRITICAL: Find ALL buffer staff in the slot, as multiple assignments are possible
                                    const bufferStaff = idsInSlot.filter(id => staffTypeMap.get(id) === 'buffer');
                                    
                                    const oldCellData = (newRosterGrid[pos] && newRosterGrid[pos][timeIndex]) ? newRosterGrid[pos][timeIndex] : {};
                                    
                                    if (bufferStaff.length > 0 && permanentStaff !== UNFILLED_SLOT) {
                                        // Paired slot: Permanent staff is primary, buffer staff is stored in `buffer` field (taking the first one)
                                        positionRoster.push({
                                            isAutomated: true, 
                                            permanent: permanentStaff, 
                                            buffer: bufferStaff[0], // Only display the first buffer in the pair dropdown
                                            value: (oldCellData.value === permanentStaff || oldCellData.value === bufferStaff[0]) ? oldCellData.value : permanentStaff,
                                            isPair: true
                                        });
                                    } else {
                                        // Solo slot: Permanent staff or first buffer staff takes the slot
                                        const onlyStaff = permanentStaff !== UNFILLED_SLOT ? permanentStaff : (bufferStaff[0] || UNFILLED_SLOT);
                                        positionRoster.push({
                                            isAutomated: true, 
                                            permanent: permanentStaff, 
                                            buffer: bufferStaff[0] || null,
                                            value: onlyStaff, isPair: false
                                        });
                                    }
                                }
                                newRosterGrid[pos] = positionRoster;
                            }
                        } else {
                            // --- MANUAL-LOCATION-FIXED MODE LOGIC (Whole Shift) ---
                            let idsInSlot = sequenceMap[pos]; // Look up by location name itself
                            if (!Array.isArray(idsInSlot)) idsInSlot = idsInSlot ? [idsInSlot] : [];

                            const permanentStaff = idsInSlot.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                            const bufferStaff = idsInSlot.filter(id => staffTypeMap.get(id) === 'buffer');

                            const isPair = bufferStaff.length > 0 && permanentStaff !== UNFILLED_SLOT;
                            const value = permanentStaff !== UNFILLED_SLOT ? permanentStaff : (bufferStaff[0] || UNFILLED_SLOT);
                            
                            for (let timeIndex = 0; timeIndex < TIME_SLOTS.length; timeIndex++) {
                                positionRoster.push({
                                    isAutomated: true, 
                                    permanent: permanentStaff, 
                                    buffer: bufferStaff[0] || null,
                                    value: value, 
                                    isPair: isPair,
                                    isFixed: true // Flag for manual mode clarity
                                });
                            }
                            newRosterGrid[pos] = positionRoster;
                        }
                    });
                    
                    // --- 2. PERIMETER PROWLER ASSIGNMENT (Slot-by-Slot Copy from P1/P2) ---
                    
                    // CRITICAL: Ensure source patrol data exists before trying to copy
                    // The source data needs to be the newly generated data in newRosterGrid
                    const patrol1Roster = newRosterGrid[PATROL_1] || Array(TIME_SLOTS.length).fill({ value: UNFILLED_SLOT, isAutomated: true });
                    const patrol2Roster = newRosterGrid[PATROL_2] || Array(TIME_SLOTS.length).fill({ value: UNFILLED_SLOT, isAutomated: true });
                    
                    // 1st Half Prowler (P1 assignments copied across ALL 12 slots)
                    const prowler1stHalf = Array(TIME_SLOTS.length).fill(null).map((_, index) => {
                        const existingCell = (newRosterGrid[PERIMETER_1ST_HALF] && newRosterGrid[PERIMETER_1ST_HALF][index]);
                        if (existingCell && existingCell.isAutomated === false && !isReset) {
                             return existingCell; // Preserve manual change
                        }

                        // **FIX IMPLEMENTATION**: Copy ONLY the final value from PATROL 1 cell
                        const sourceCell = patrol1Roster[index] || { value: UNFILLED_SLOT, permanent: UNFILLED_SLOT, buffer: null, isPair: false };
                        const sourceValue = sourceCell.value || UNFILLED_SLOT; 

                        return { 
                            value: sourceValue, 
                            isAutomated: true, 
                            isSourceProwler: true,
                            // Retain complex data only for reference/display if necessary, but value is key here
                            permanent: sourceCell.permanent,
                            buffer: sourceCell.buffer,
                            isPair: sourceCell.isPair
                        };
                    });
                    newRosterGrid[PERIMETER_1ST_HALF] = prowler1stHalf;

                    // 2nd Half Prowler (P2 assignments copied across ALL 12 slots)
                    const prowler2ndHalf = Array(TIME_SLOTS.length).fill(null).map((_, index) => {
                        const existingCell = (newRosterGrid[PERIMETER_2ND_HALF] && newRosterGrid[PERIMETER_2ND_HALF][index]);
                        if (existingCell && existingCell.isAutomated === false && !isReset) {
                            return existingCell; // Preserve manual change
                        }

                        // **FIX IMPLEMENTATION**: Copy ONLY the final value from PATROL 2 cell
                        const sourceCell = patrol2Roster[index] || { value: UNFILLED_SLOT, permanent: UNFILLED_SLOT, buffer: null, isPair: false };
                        const sourceValue = sourceCell.value || UNFILLED_SLOT; 

                        return { 
                            value: sourceValue, 
                            isAutomated: true, 
                            isSourceProwler: true,
                            // Retain complex data only for reference/display if necessary, but value is key here
                            permanent: sourceCell.permanent,
                            buffer: sourceCell.buffer,
                            isPair: sourceCell.isPair
                        };
                    });
                    newRosterGrid[PERIMETER_2ND_HALF] = prowler2ndHalf;
                    // --- End PERIMETER PROWLER ASSIGNMENT ---


                    // --- 3. FOYER DEPLOYMENT (Always follows fixed pattern) ---
                    let foyer1_ids = sequenceMap["FOYER 1"];
                    if (!Array.isArray(foyer1_ids)) foyer1_ids = foyer1_ids ? [foyer1_ids] : [];
                    let foyer2_ids = sequenceMap["FOYER 2"];
                    if (!Array.isArray(foyer2_ids)) foyer2_ids = foyer2_ids ? [foyer2_ids] : [];

                    const staffA_perm = foyer1_ids.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const staffA_buff = foyer1_ids.filter(id => staffTypeMap.get(id) === 'buffer');
                    const staffB_perm = foyer2_ids.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const staffB_buff = foyer2_ids.filter(id => staffTypeMap.get(id) === 'buffer');

                    const xraySequence = [];
                    const foyerOESequence = [];
                    
                    for (let i = 0; i < 12; i++) {
                        // Rotation logic based on the original script: Staff A handles 20-22, 02-04. Staff B handles 23-01, 05-07.
                        const isStaffA_Xray = !((i >= 3 && i <= 5) || (i >= 9)); 
                        
                        const permanentStaffXray = isStaffA_Xray ? staffA_perm : staffB_perm;
                        const bufferStaffXray = isStaffA_Xray ? staffA_buff : staffB_buff;
                        const permanentStaffOE = isStaffA_Xray ? staffB_perm : staffA_perm;
                        const bufferStaffOE = isStaffA_Xray ? staffB_buff : staffA_buff;
                        
                        const isPairXray = bufferStaffXray.length > 0 && permanentStaffXray !== UNFILLED_SLOT;
                        const isPairOE = bufferStaffOE.length > 0 && permanentStaffOE !== UNFILLED_SLOT;

                        const oldXrayCell = (newRosterGrid["XRAY-VISITOR"] && newRosterGrid["XRAY-VISITOR"][i]) ? newRosterGrid["XRAY-VISITOR"][i] : {};
                        const oldOECell = (newRosterGrid["FOYER-OE"] && newRosterGrid["FOYER-OE"][i]) ? newRosterGrid["FOYER-OE"][i] : {};
                        
                        // XRAY (Post A / Fixed Post)
                        if (isPairXray) {
                            xraySequence.push({ isAutomated: true, permanent: permanentStaffXray, buffer: bufferStaffXray[0], value: (oldXrayCell.value === permanentStaffXray || oldXrayCell.value === bufferStaffXray[0]) ? oldXrayCell.value : permanentStaffXray, isPair: true });
                        } else {
                            const onlyStaff = permanentStaffXray !== UNFILLED_SLOT ? permanentStaffXray : (bufferStaffXray[0] || UNFILLED_SLOT);
                            xraySequence.push({ isAutomated: true, permanent: permanentStaffXray, buffer: bufferStaffXray[0] || null, value: onlyStaff, isPair: false });
                        }
                        
                        // FOYER-OE (Post B / Roaming/Standby)
                        if (isPairOE) {
                             foyerOESequence.push({ isAutomated: true, permanent: permanentStaffOE, buffer: bufferStaffOE[0], value: (oldOECell.value === permanentStaffOE || oldOECell.value === bufferStaffOE[0]) ? oldOECell.value : permanentStaffOE, isPair: true });
                        } else {
                            const onlyStaff = permanentStaffOE !== UNFILLED_SLOT ? permanentStaffOE : (bufferStaffOE[0] || UNFILLED_SLOT);
                            foyerOESequence.push({ isAutomated: true, permanent: permanentStaffOE, buffer: bufferStaffOE[0] || null, value: onlyStaff, isPair: false });
                        }
                    }

                    // --- 6-SLOT Vertical Prowler (Uses Foyer-OE Staff for rotation) ---
                    const existingProwlerData = newRosterGrid[VERTICAL_PROWLER_POSITION] || [];
                    const verticalProwlerSequence = [
                        foyerOESequence[0],  foyerOESequence[2], foyerOESequence[4], foyerOESequence[6], foyerOESequence[8], foyerOESequence[10]
                    ];
                    
                    // Remove staff from Foyer-OE positions they are taking up for VP duty
                    [0, 2, 4, 6, 8, 10].forEach(i => {
                        foyerOESequence[i] = { ...foyerOESequence[i], value: UNFILLED_SLOT, isPair: false, permanent: UNFILLED_SLOT, buffer: null };
                    });
                    
                    newRosterGrid["XRAY-VISITOR"] = xraySequence;
                    newRosterGrid["FOYER-OE"] = foyerOESequence;
                    
                    // Preserve Manual Edit for VP slot 2 (23:00) if it exists
                    const vpManualIndex = 2;
                    if (existingProwlerData[vpManualIndex] && !existingProwlerData[vpManualIndex].isAutomated) {
                        verticalProwlerSequence[vpManualIndex] = existingProwlerData[vpManualIndex];
                    }

                    newRosterGrid[VERTICAL_PROWLER_POSITION] = verticalProwlerSequence.map(cell => ({...cell, isAutomated: true})); 


                    // --- 4. SECURITY CONTROL OFFICE (Fixed all night) ---
                    let leaderIds = sequenceMap["TEAM LEADER (I/C)"];
                    if (!Array.isArray(leaderIds)) leaderIds = leaderIds ? [leaderIds] : [];
                    let icIds = sequenceMap["SECTION I/C"];
                    if (!Array.isArray(icIds)) icIds = icIds ? [icIds] : [];

                    const teamLeaderId = leaderIds.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const sectionIcId = icIds.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const bufferLeader = leaderIds.filter(id => staffTypeMap.get(id) === 'buffer');
                    const bufferIc = icIds.filter(id => staffTypeMap.get(id) === 'buffer');
                    
                    const isPairLeader = bufferLeader.length > 0 && teamLeaderId !== UNFILLED_SLOT;
                    const isPairIc = bufferIc.length > 0 && sectionIcId !== UNFILLED_SLOT;
                    
                    newRosterGrid["TEAM LEADER (I/C)"] = Array(TIME_SLOTS.length).fill(null).map((_, i) => {
                        const oldCell = (newRosterGrid["TEAM LEADER (I/C)"] && newRosterGrid["TEAM LEADER (I/C)"][i]) ? newRosterGrid["TEAM LEADER (I/C)"][i] : {};
                        if (isPairLeader) {
                            return { isAutomated: true, permanent: teamLeaderId, buffer: bufferLeader[0], value: (oldCell.value === teamLeaderId || oldCell.value === bufferLeader[0]) ? oldCell.value : teamLeaderId, isPair: true };
                        }
                        const onlyStaff = teamLeaderId !== UNFILLED_SLOT ? teamLeaderId : (bufferLeader[0] || UNFILLED_SLOT);
                        return { isAutomated: true, permanent: teamLeaderId, buffer: bufferLeader[0] || null, value: onlyStaff, isPair: false };
                    });
                    newRosterGrid["SECTION I/C"] = Array(TIME_SLOTS.length).fill(null).map((_, i) => {
                        const oldCell = (newRosterGrid["SECTION I/C"] && newRosterGrid["SECTION I/C"][i]) ? newRosterGrid["SECTION I/C"][i] : {};
                        if (isPairIc) {
                            return { isAutomated: true, permanent: sectionIcId, buffer: bufferIc[0], value: (oldOECell.value === sectionIcId || oldOECell.value === bufferIc[0]) ? oldOECell.value : sectionIcId, isPair: true };
                        }
                        const onlyStaff = sectionIcId !== UNFILLED_SLOT ? sectionIcId : (bufferIc[0] || UNFILLED_SLOT);
                        return { isAutomated: true, permanent: sectionIcId, buffer: bufferIc[0] || null, value: onlyStaff, isPair: false };
                    });
                    
                    // --- 5. APPLY LOCATION BUFFER OVERRIDES (Overrides all previous logic) ---
                    if (locationBufferMap && Object.keys(locationBufferMap).length > 0) {
                        Object.entries(locationBufferMap).forEach(([bufferId, location]) => {
                             if (newRosterGrid[location]) {
                                 newRosterGrid[location] = newRosterGrid[location].map((cell, index) => {
                                     // Ensure we get the *actual* permanent staff ID from the cell or use UNFILLED_SLOT
                                     const permanentStaff = cell.permanent || (cell.value && cell.value !== bufferId && staffTypeMap.get(cell.value) === 'permanent' ? cell.value : UNFILLED_SLOT);
                                     
                                     // This logic ensures the permanent staff is placed back on OE/STANDBY if their location is overridden
                                     if (location === "OE/ STANDBY") {
                                          return { ...cell, permanent: UNFILLED_SLOT, buffer: bufferId, isPair: false, value: bufferId, isAutomated: true };
                                     }
                                     
                                     if (permanentStaff !== UNFILLED_SLOT && permanentStaff !== "") {
                                         // Overriding location is a pair (permanent staff stays, buffer acts as dedicated support)
                                         return { ...cell, permanent: permanentStaff, buffer: bufferId, isPair: true, value: permanentStaff };
                                     } else {
                                         // Overriding location has no permanent staff, so buffer takes it solo
                                         return { ...cell, permanent: UNFILLED_SLOT, buffer: bufferId, isPair: false, value: bufferId, isAutomated: true };
                                     }
                                 });
                             }
                        });
                    }
                    
                    const finalRosterGrid = sanitizeForFirestore(newRosterGrid);

                    const docRef = getDocRef(DAILY_ROSTER_COLLECTION, selectedDate);
                    await setDoc(docRef, { rosterGrid: finalRosterGrid, updatedAt: new Date().toISOString() });
                    
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists()) {
                         setRosterData(docSnap.data().rosterGrid || {});
                    }
                    
                    setIsDirty(false);
                    setIsGenerating(false); // Stop generating state
                    
                } catch (err) {
                    console.error("Error generating roster:", err);
                    setError("Failed to generate roster. Check console for details.");
                    setIsGenerating(false); // Stop generating state on error
                }
            };
            
            // The 6 sequence keys that are cyclically shifted for the rotation start
            const ROTATION_KEYS = ["E1", "OE", "P2", "N1", "E3", "P1"];

            const handleShuffle = async () => {
                if (!db || !dailyAssignments) { 
                    setError("Database or daily assignments not available for shuffle."); 
                    return; 
                }
                
                setIsShuffling(true);
                setError(null);
                
                try {
                    const { sequenceMap } = dailyAssignments;
                    
                    if (rosterMode !== ROSTER_MODES.AUTO_SEQUENCE) {
                        setError("Shuffle is only applicable in Auto-Sequence Mode.");
                        setIsShuffling(false);
                        return;
                    }

                    // 1. Extract the current content (array of IDs) for the 6 rotation keys
                    const keyContents = ROTATION_KEYS.map(key => sequenceMap[key] || []);

                    // 2. Perform a cyclic shift (right shift: last element moves to the front)
                    // [ [A], [B], [C], [D], [E], [F] ] -> [ [F], [A], [B], [C], [D], [E] ]
                    const lastElement = keyContents.pop();
                    const newKeyContents = [lastElement, ...keyContents];

                    // 3. Write back to a new sequence map
                    const newSequenceMap = { ...sequenceMap };
                    ROTATION_KEYS.forEach((key, index) => {
                        newSequenceMap[key] = newKeyContents[index];
                    });

                    // 4. Save the new sequence map back to Firestore
                    const docRef = getDocRef(DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                    if (!docRef) throw new Error("Could not create assignment document reference.");

                    // Note: We use updateDoc to only modify the sequenceMap, preserving other fields
                    await updateDoc(docRef, { 
                        sequenceMap: newSequenceMap,
                        updatedAt: new Date().toISOString(),
                    });
                    
                    // 5. Rerender the roster based on the new assignments (false = Keep Edits)
                    // We delay the call slightly to ensure the onSnapshot listener updates dailyAssignments first.
                    setTimeout(() => {
                        handleGenerateRoster(false);
                        setIsShuffling(false);
                    }, 500); 
                    
                } catch (err) {
                    console.error("Error shuffling roster:", err);
                    setError("Failed to shuffle roster. Check console for details.");
                    setIsShuffling(false);
                }
            };

            const handleSaveChanges = async () => {
                if (!rosterData || !isDirty) return;
                if (!db) return setError("Database not available.");
                setLoading(true);
                setError(null);
                try {
                    const cleanRosterData = { ...rosterData };
                    const allKeys = Object.keys(cleanRosterData);
                    
                    const existingRows = [
                        ...SECURITY_POSITIONS, ...FOYER_POSITIONS, VERTICAL_PROWLER_POSITION, ...SENTRY_POSITIONS, ...manualStandbyRows
                    ];
                    
                    allKeys.forEach(key => {
                        // Check if a manual standby row is empty across all slots, and if so, delete it.
                        if (key.startsWith("OE/ STANDBY-")) {
                            const row = cleanRosterData[key];
                            const isEmpty = row.every(cell => !cell.value || cell.value === UNFILLED_SLOT || cell.value === "");
                            if (isEmpty) {
                                delete cleanRosterData[key];
                            }
                        }
                    });

                    // CRITICAL: If Matrix Edit Mode was used, we need to ensure the automated flags are cleared
                    if (isMatrixEditMode) {
                         Object.keys(cleanRosterData).forEach(pos => {
                             if (cleanRosterData[pos] && Array.isArray(cleanRosterData[pos])) {
                                 cleanRosterData[pos] = cleanRosterData[pos].map(cell => ({
                                     // Preserve the user's manual value and ensure automation is off
                                     ...cell,
                                     value: cell.value || UNFILLED_SLOT,
                                     isAutomated: false,
                                     isFixed: true // Mark as manually fixed data
                                 }));
                             }
                         });
                    }

                    const finalCleanData = sanitizeForFirestore(cleanRosterData);

                    const docRef = getDocRef(DAILY_ROSTER_COLLECTION, selectedDate);
                    await setDoc(docRef, { rosterGrid: finalCleanData, updatedAt: new Date().toISOString() });
                    setIsDirty(false);
                    setLoading(false);
                } catch (err) {
                    console.error("Error saving changes: ", err);
                    setError("Failed to save changes. Check console for details.");
                    setLoading(false);
                }
            };
            
            // --- ID SWAP/VACATE LOGIC (Simplified from previous steps to only manage placement) ---
            const handleCellChange = (position, timeIndex, newValue) => {
                setRosterData(prevRoster => {
                    const newRoster = { ...prevRoster };
                    
                    // --- 0. Initialize Target Cell (if new row/column) ---
                    if (!newRoster[position]) {
                        newRoster[position] = Array(TIME_SLOTS.length).fill(null).map(() => ({ value: "", isAutomated: false }));
                    }
                    // Create a mutable copy of the destination row
                    const newRow = [...newRoster[position]];
                    
                    if (!newRow[timeIndex]) {
                         newRow[timeIndex] = { value: "", isAutomated: false };
                    }
                    
                    // CRITICAL SWAP VARIABLE: ID that was displaced from the DESTINATION cell.
                    const destinationOldCell = newRow[timeIndex];
                    const ID_B_TO_SWAP_BACK = destinationOldCell.value; 
                    
                    // ID that the user just selected at the destination.
                    const ID_A_FROM_SOURCE = newValue; 
                    
                    // --- 1. Handle ID SWAP/VACATE in Matrix Edit Mode (Source Cell) ---
                    if (isMatrixEditMode && ID_A_FROM_SOURCE && ID_A_FROM_SOURCE !== UNFILLED_SLOT) {
                        
                        // Define ALL positions to check
                        const allRosterPositions = [
                            ...SECURITY_POSITIONS, 
                            ...FOYER_POSITIONS, 
                            VERTICAL_PROWLER_POSITION, 
                            ...SENTRY_POSITIONS, 
                            ...Object.keys(newRoster).filter(key => key.startsWith("OE/ STANDBY-"))
                        ].filter(p => !!newRoster[p]); 
                        
                        const positionsToSweep = [...new Set(allRosterPositions)];

                        for (const posKey of positionsToSweep) {
                            
                            const row = newRoster[posKey];
                            const targetCell = row?.[timeIndex]; // This is the SOURCE cell
                            
                            // If the staff ID is found in the SOURCE cell at the same time slot
                            if (targetCell?.value === ID_A_FROM_SOURCE) {
                                
                                // We found the source of ID_A. Apply the swap value (ID_B) or vacancy (---).
                                const rowToUpdate = [...newRoster[posKey]];
                                
                                // SWAP or VACATE SOURCE: 
                                const swapValue = (ID_B_TO_SWAP_BACK && ID_B_TO_SWAP_BACK !== UNFILLED_SLOT) ? ID_B_TO_SWAP_BACK : UNFILLED_SLOT;

                                rowToUpdate[timeIndex] = {
                                    ...targetCell, 
                                    value: swapValue,
                                    isAutomated: false, // Mark as manually fixed
                                    isFixed: true, 
                                };
                                
                                // Apply the modified row back to the working roster copy
                                newRoster[posKey] = rowToUpdate;
                                
                                // Crucial: Break the loop after finding and updating the *one* source cell.
                                break; 
                            }
                        }
                    }
                    
                    // --- 2. Place ID_A into the DESTINATION cell (always happens last) ---
                    
                    // Update the new cell copy with the new value (ID_A)
                    const updatedTargetCell = { 
                        ...destinationOldCell, 
                        value: ID_A_FROM_SOURCE, 
                        // Mark as manually edited in matrix mode
                        isAutomated: isMatrixEditMode ? false : destinationOldCell.isAutomated,
                        isFixed: isMatrixEditMode ? true : destinationOldCell.isFixed
                    };
                    newRow[timeIndex] = updatedTargetCell;
                    newRoster[position] = newRow;


                    // --- 3. Standard Post-Matrix Logic (Original displacement logic for non-matrix mode) ---
                    // This logic handles pair splitting in Auto/Default mode.
                    const permanentId = updatedTargetCell.permanent;
                    const bufferId = updatedTargetCell.buffer;
                    const oldValue = destinationOldCell.value; 
                    const newValueForDisplacedCheck = updatedTargetCell.value;

                    if (!isMatrixEditMode && updatedTargetCell.isPair && permanentId && bufferId) {
                        // Case 1: Perm staff is replaced by Buffer staff (Perm staff displaced)
                        if (newValueForDisplacedCheck === bufferId && oldValue === permanentId) {
                            placeDisplacedStaff(newRoster, permanentId, timeIndex);
                        }
                        // Case 2: Buffer staff is replaced by Perm staff (Buffer staff was displaced, now returns)
                        if (newValueForDisplacedCheck === permanentId && oldValue === bufferId) {
                            removeDisplacedStaff(newRoster, permanentId, timeIndex);
                        }
                    }

                    return newRoster;
                });
                setIsDirty(true);
            };
            
            const placeDisplacedStaff = (roster, staffId, timeIndex) => {
                // Find or create an OE/STANDBY slot for the displaced staff
                const allRows = Object.keys(roster).filter(key => key.startsWith("OE/ STANDBY"));
                allRows.sort((a, b) => {
                    if (a === "OE/ STANDBY") return -1;
                    if (b === "OE/ STANDBY") return 1;
                    const numA = parseInt(a.split('-')[1] || 999);
                    const numB = parseInt(b.split('-')[1] || 999);
                    return numA - numB;
                });
                
                for (const rowName of allRows) {
                    const row = roster[rowName];
                    if (row && row[timeIndex]) {
                        const cell = row[timeIndex];
                        if (!cell.value || cell.value === UNFILLED_SLOT || cell.value === "") {
                            // Create mutable row copy for update
                            const rowToUpdate = [...roster[rowName]];
                            
                            // OE/ STANDBY is the primary standby row, others are manual
                            if (rowName === "OE/ STANDBY") {
                                rowToUpdate[timeIndex] = { ...cell, value: staffId, isDisplaced: true, isAutomated: cell.isAutomated };
                            } else {
                                rowToUpdate[timeIndex] = { value: staffId, isAutomated: false };
                            }
                            roster[rowName] = rowToUpdate;
                            return;
                        }
                    }
                }
                
                // If no standby slot is available, create a new manual standby row
                let nextNum = 2;
                while (rosterData[`OE/ STANDBY-${nextNum}`]) {
                    nextNum++;
                }
                const newRowName = `OE/ STANDBY-${nextNum}`;
                
                const newRow = Array(TIME_SLOTS.length).fill(null).map(() => ({ value: "", isAutomated: false }));
                newRow[timeIndex] = { value: staffId, isAutomated: false };
                roster[newRowName] = newRow;
            };

            const removeDisplacedStaff = (roster, staffId, timeIndex) => {
                 // Remove staff ID from all OE/STANDBY rows for this time slot
                 const allRows = Object.keys(roster).filter(key => key.startsWith("OE/ STANDBY"));
                 
                 for (const rowName of allRows) {
                    const row = roster[rowName];
                    if (row && row[timeIndex]) {
                         const cell = row[timeIndex];
                         if (cell.value === staffId) {
                             // Create mutable row copy for update
                             const rowToUpdate = [...roster[rowName]];
                             
                             if (rowName === "OE/ STANDBY") {
                                // For the auto OE row, revert to permanent staff (or UNFILLED) if the displaced staff (which is the permanent staff) is the one returning.
                                rowToUpdate[timeIndex] = { ...cell, value: cell.permanent || UNFILLED_SLOT, isDisplaced: false };
                            } else {
                                // For manual rows, just clear the cell
                                rowToUpdate[timeIndex] = { ...cell, value: "" };
                            }
                            roster[rowName] = rowToUpdate;
                            return;
                        }
                    }
                 }
            };

            
            const handleCellClick = (value) => {
                if (!value || value === UNFILLED_SLOT) {
                    setHighlightedId(null);
                    return;
                }
                if (value === highlightedId) {
                    setHighlightedId(null);
                } else {
                    setHighlightedId(value);
                }
            };
            
            const handleAddStandbyRow = () => {
                // CRITICAL FIX: Add check for rosterData existence
                if (!rosterData) return;
                
                let nextNum = 2;
                while (rosterData[`OE/ STANDBY-${nextNum}`]) {
                    nextNum++;
                }
                const newRowName = `OE/ STANDBY-${nextNum}`;
                
                setRosterData(prevData => ({
                    ...prevData,
                    [newRowName]: Array(TIME_SLOTS.length).fill(null).map(() => ({ value: "", isAutomated: false }))
                }));
                setIsDirty(true);
            };

            const handleRemoveStandbyRow = (rowName) => {
                // Use a custom confirmation dialog replacement
                const confirmDelete = window.confirm(`Are you sure you want to remove the row "${rowName}"? Any assignments in this row will be lost.`);

                if (confirmDelete) {
                    setRosterData(prevData => {
                        const newData = { ...prevData };
                        delete newData[rowName]; 
                        return newData;
                    });
                    setIsDirty(true);
                }
            };
            
            const renderTableBody = (positions) => {
                // scheduledStaff and staffTypeMap are available from the parent RosterView component scope.
                const scheduledStaffIds = scheduledStaff.map(s => s.id).sort();
                
                // CRITICAL FIX: Guard rendering inside renderTableBody as well
                if (!rosterData || typeof rosterData !== 'object') {
                    return (<tbody><tr><td colSpan={TIME_SLOTS.length + 1}>Roster data is not yet available.</td></tr></tbody>);
                }

                return (
                    <tbody className={`bg-white divide-y divide-gray-200 ${isMatrixEditMode ? 'matrix-edit-active' : ''}`}>
                        {positions.map(pos => {
                            const isProwlerRow = pos.startsWith("PERIMETER PROWLER");
                            const isManualStandbyRow = pos.startsWith("OE/ STANDBY-");
                            
                            let displayName = pos;
                            if (focusView === 'sentry') {
                                if (pos === "PERIMETER PROWLER (1st Half)") { displayName = "1st Half"; } 
                                else if (pos === "PERIMETER PROWLER (2nd Half)") { displayName = "2nd Half"; } 
                                else if (pos === "PATROL 1") { displayName = "P1"; } 
                                else if (pos === "PATROL 2") { displayName = "P2"; } 
                                else if (pos === "N1 (CNB)") { displayName = "N1"; } 
                                else if (pos === "OE/ STANDBY") { displayName = "OE"; } 
                                else if (pos.startsWith("OE/ STANDBY-")) { displayName = pos.replace("OE/ STANDBY", "OE"); }
                            }
                            
                            return (
                                <tr key={pos} className={`${isProwlerRow ? 'bg-gray-100' : isManualStandbyRow ? 'bg-purple-50' : 'bg-white'} hover:bg-gray-200`}>
                                    
                                    <td className={`sticky left-0 p-2 text-sm font-medium text-gray-800 whitespace-nowrap z-10 border-r ${isProwlerRow ? 'bg-gray-100' : isManualStandbyRow ? 'bg-purple-50' : 'bg-white'}`}>
                                        <div className="flex items-center justify-between">
                                            <span>{displayName}</span>
                                            
                                            {pos === "OE/ STANDBY" && (
                                                <button onClick={handleAddStandbyRow} className="ml-2 w-5 h-5 flex items-center justify-center bg-green-500 text-white rounded-full font-bold hover:bg-green-600 print-hidden" title="Add manual standby row"> + </button>
                                            )}
                                            
                                            {isManualStandbyRow && (
                                                <button onClick={() => handleRemoveStandbyRow(pos)} className="ml-2 w-5 h-5 flex items-center justify-center bg-red-500 text-white rounded-full font-bold hover:bg-red-700 print-hidden" title={`Remove row ${pos}`}> - </button>
                                            )}
                                        </div>
                                    </td>
                                    
                                    {TIME_SLOTS.map((time, index) => {
                                        const cell = (rosterData[pos] && rosterData[pos][index]) ? rosterData[pos][index] : { value: "", isAutomated: isManualStandbyRow ? false : true };
                                        const value = cell.value;
                                        const isAutomated = cell.isAutomated;
                                        const isPair = cell.isPair;
                                        const isFixed = cell.isFixed;
                                        
                                        const isMissing = isAutomated && value === UNFILLED_SLOT;
                                        const isHighlighted = highlightedId && value === highlightedId && value !== UNFILLED_SLOT && value !== "";
                                        
                                        // NEW: Check for shuffle highlight (applies only to the 2000Hrs column and Sentry/OE rows)
                                        const isShuffleHighlight = isShuffling && index === 0 && (SENTRY_POSITIONS.includes(pos) || isManualStandbyRow);

                                        // Determine if the cell content is a Buffer ID
                                        const isBufferId = value && value !== UNFILLED_SLOT && staffTypeMap.get(value) === 'buffer';

                                        const getCellClasses = (isSelect = false) => {
                                            let baseClasses = "w-20 p-1 text-xs sm:text-sm border-0 border-r border-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none cursor-pointer text-center";
                                            
                                            // NEW: Shuffle highlight has highest priority
                                            if (isShuffleHighlight) { return baseClasses + " shuffling-highlight"; } 
                                            
                                            if (isHighlighted) { return baseClasses + " highlight-cell"; }
                                            if (isMissing) { return baseClasses + " bg-yellow-100 text-yellow-800 font-bold"; }
                                            
                                            // 1. Apply buffer content style first if it's a buffer ID (highest visual priority after highlight)
                                            if (isBufferId) { return baseClasses + " buffer-id-content"; }
                                            
                                            // 2. Fallback styles
                                            if (isManualStandbyRow) { return baseClasses + " bg-purple-50"; }
                                            
                                            if (isMatrixEditMode && isSelect) { 
                                                // Matrix mode base style
                                                return baseClasses + " bg-blue-100 text-gray-700";
                                            }
                                            
                                            if (isPair) {
                                                // These classes also apply coloring, but buffer-id-content takes priority
                                                if (value === cell.buffer) { return baseClasses + " dropdown-buffer"; }
                                                return baseClasses + " dropdown-permanent";
                                            }
                                            if (isFixed) { // New style for Manual Fixed Mode
                                                return baseClasses + " bg-indigo-100 text-indigo-700 font-bold";
                                            }
                                            if (isAutomated) {
                                                return baseClasses + (isProwlerRow ? ' bg-gray-100 text-gray-700' : ' bg-gray-50 text-gray-700');
                                            }
                                            return baseClasses + " bg-white";
                                        };
                                        
                                        // --- MATRIX EDIT MODE (Dropdown in every cell) ---
                                        if (isMatrixEditMode) {
                                            // Get correct classes, which now includes buffer-id-content if applicable
                                            const classes = getCellClasses(true); 
                                            return (
                                                <td key={time} className="p-0">
                                                    <select
                                                        value={value || ""}
                                                        onChange={(e) => handleCellChange(pos, index, e.target.value)}
                                                        onClick={() => handleCellClick(value)}
                                                        className={classes}
                                                    >
                                                        <option value="">{UNFILLED_SLOT}</option>
                                                        {scheduledStaffIds.map(id => (
                                                            <option key={id} value={id}>{id}</option>
                                                        ))}
                                                    </select>
                                                </td>
                                            );
                                        }

                                        // --- DEFAULT / AUTO MODE (Input/Select based on data type) ---
                                        if (isPair) {
                                            return (
                                                <td key={time} className="p-0">
                                                    <select
                                                        value={value}
                                                        onChange={(e) => handleCellChange(pos, index, e.target.value)}
                                                        onClick={() => handleCellClick(value)}
                                                        className={getCellClasses()}
                                                        disabled={isMatrixEditMode}
                                                    >
                                                        <option value={cell.permanent}>{cell.permanent}</option>
                                                        <option value={cell.buffer}>{cell.buffer}</option>
                                                    </select>
                                                </td>
                                            );
                                        }
                                        
                                        return (
                                            <td key={time} className="p-0">
                                                <input
                                                    type="text"
                                                    value={value}
                                                    onChange={(e) => handleCellChange(pos, index, e.target.value)}
                                                    onClick={() => handleCellClick(value)}
                                                    className={getCellClasses()}
                                                    placeholder="ID"
                                                    readOnly={isAutomated && !isManualStandbyRow && !isFixed}
                                                />
                                            </td>
                                        );
                                    })}
                                </tr>
                            );
                        })}
                    </tbody>
                );
            };

            const renderTableHeader = (customSlots = TIME_SLOTS) => (
                <thead className="bg-gray-100">
                    <tr>
                        <th className="sticky left-0 bg-gray-100 p-1 text-left text-xs font-bold text-gray-600 uppercase tracking-wider z-10">Location/Call-Sign</th>
                        {customSlots.map(time => (
                            <th key={time} className="p-1 text-center text-xs font-bold text-gray-600 uppercase tracking-wider whitespace-nowrap">{time}</th>
                        ))}
                    </tr>
                </thead>
            );

            const renderVerticalProwlerTable = (controlRoomStaff = []) => {
                 // scheduledStaff and staffTypeMap are available from the parent RosterView component scope.
                 const scheduledStaffIds = scheduledStaff.map(s => s.id).sort();

                 const getMatrixDropdown = (pos, index, value) => {
                    // Determine if the cell content is a Buffer ID
                    const isBufferId = value && value !== UNFILLED_SLOT && staffTypeMap.get(value) === 'buffer';

                    let selectClasses = `w-full p-1 text-xs sm:text-sm border-0 border-r border-gray-200 cursor-pointer text-center vp-cell-fix`;
                    
                    // Priority check for buffer styling
                    if (isBufferId) { 
                        selectClasses += " buffer-id-content"; 
                    } else { 
                        // Fallback to generic matrix styling
                        selectClasses += `${isMatrixEditMode ? 'bg-blue-100 text-gray-700 font-semibold' : 'bg-white'}`; 
                    }
                     
                    return (
                        <td key={VERTICAL_PROWLER_SLOTS[index]} className="p-0">
                            <select
                                value={value || ""}
                                onChange={(e) => handleCellChange(pos, index, e.target.value)}
                                onClick={() => handleCellClick(value)}
                                className={selectClasses}
                            >
                                <option value="">{UNFILLED_SLOT}</option>
                                {scheduledStaffIds.map(id => (
                                    <option key={id} value={id}>{id}</option>
                                ))}
                            </select>
                        </td>
                     );
                 };
                 
                // CRITICAL FIX: Guard rendering inside renderVerticalProwlerTable as well
                 if (!rosterData || typeof rosterData !== 'object') {
                     return (
                         <div className="overflow-x-auto shadow-md rounded-lg border roster-section">
                             <table className="min-w-full divide-y divide-gray-200">
                                 {renderTableHeader(VERTICAL_PROWLER_SLOTS)}
                                 <tbody><tr><td colSpan={VERTICAL_PROWLER_SLOTS.length + 1}>Roster data is not yet available.</td></tr></tbody>
                             </table>
                         </div>
                     );
                 }

                return (
                    <div className="overflow-x-auto shadow-md rounded-lg border roster-section">
                        <table className="min-w-full divide-y divide-gray-200">
                            <thead className="bg-gray-100">
                                <tr>
                                    <th className="sticky left-0 bg-gray-100 p-1 text-left text-xs font-bold text-gray-600 uppercase tracking-wider z-10">Location/Call-Sign</th>
                                    {VERTICAL_PROWLER_SLOTS.map(time => (
                                        <th key={time} className="p-1 text-center text-xs font-bold text-gray-600 uppercase tracking-wider whitespace-nowrap vp-cell-fix">{time}</th>
                                    ))}
                                </tr>
                            </thead>
                            <tbody className={`bg-white divide-y divide-gray-200 ${isMatrixEditMode ? 'matrix-edit-active' : ''}`}>
                                <tr className="hover:bg-gray-50">
                                    <td className="sticky left-0 bg-white p-2 text-sm font-medium text-gray-800 whitespace-nowrap z-10 border-r">{VERTICAL_PROWLER_POSITION}</td>
                                    {VERTICAL_PROWLER_SLOTS.map((time, index) => {
                                        const cell = (rosterData[VERTICAL_PROWLER_POSITION] && rosterData[VERTICAL_PROWLER_POSITION][index]) ? rosterData[VERTICAL_PROWLER_POSITION][index] : { value: "", isAutomated: false };
                                        const value = cell.value;
                                        
                                        // NEW: Determine if the cell content is a Buffer ID
                                        const isBufferId = value && value !== UNFILLED_SLOT && staffTypeMap.get(value) === 'buffer';

                                        // If Matrix Edit Mode is on, render dropdown for ALL VP slots
                                        if (isMatrixEditMode) {
                                            return getMatrixDropdown(VERTICAL_PROWLER_POSITION, index, value);
                                        }

                                        // --- DEFAULT / AUTO MODE (Mixed inputs) ---
                                        const isMissing = value === UNFILLED_SLOT;
                                        const isHighlighted = highlightedId && value === highlightedId && value !== UNFILLED_SLOT && value !== "";
                                        const isPair = cell.isPair;
                                        const isAutomated = cell.isAutomated;

                                        let baseClasses = `w-20 p-1 text-xs sm:text-sm border-0 border-r border-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none cursor-pointer text-center vp-cell-fix`;
                                        
                                        if (index === 2) { 
                                            // Slot 2 is still special for manual control room staff selection
                                            let selectClasses = baseClasses;
                                            if (isHighlighted) { selectClasses += " highlight-cell"; } 
                                            else if (isMissing) { selectClasses += " bg-yellow-100 text-yellow-800 font-bold"; } 
                                            else if (isBufferId) { selectClasses += " buffer-id-content"; }
                                            else { selectClasses += " bg-white"; }
                                            
                                            return (
                                                <td key={time} className="p-0">
                                                    <select
                                                        value={value}
                                                        onChange={(e) => handleCellChange(VERTICAL_PROWLER_POSITION, index, e.target.value)}
                                                        onClick={() => handleCellClick(value)}
                                                        className={selectClasses}
                                                        disabled={isMatrixEditMode}
                                                    >
                                                        <option value={UNFILLED_SLOT}>{UNFILLED_SLOT}</option>
                                                        {[...new Set(controlRoomStaff)].map(id => (
                                                            <option key={id} value={id}>{id}</option>
                                                        ))}
                                                        {value && value !== UNFILLED_SLOT && !controlRoomStaff.includes(value) && (
                                                            <option key={value} value={value}>{value} (Old)</option>
                                                        )}
                                                    </select>
                                                </td>
                                            );
                                        }
                                        
                                        if (isPair) {
                                             let selectClasses = baseClasses;
                                             if (isHighlighted) { selectClasses += " highlight-cell"; } 
                                             else if (isBufferId) { selectClasses += " buffer-id-content"; } // Takes priority over pair classes
                                             else {
                                                if (value === cell.buffer) { selectClasses += " dropdown-buffer"; } 
                                                else { selectClasses += " dropdown-permanent"; }
                                            }
                                            return (
                                                <td key={time} className="p-0">
                                                    <select
                                                        value={value}
                                                        onChange={(e) => handleCellChange(VERTICAL_PROWLER_POSITION, index, e.target.value)}
                                                        onClick={() => handleCellClick(value)}
                                                        className={selectClasses}
                                                        disabled={isMatrixEditMode}
                                                    >
                                                        <option value={cell.permanent}>{cell.permanent}</option>
                                                        <option value={cell.buffer}>{cell.buffer}</option>
                                                    </select>
                                                </td>
                                            );
                                        }

                                        let inputClasses = baseClasses;
                                        if (isHighlighted) { inputClasses += " highlight-cell"; } 
                                        else if (isMissing) { inputClasses += " bg-yellow-100 text-yellow-800 font-bold"; } 
                                        else if (isBufferId) { inputClasses += " buffer-id-content"; }
                                        else { inputClasses += " bg-gray-50 text-gray-700"; }
                                        
                                        return (
                                            <td key={time} className="p-0">
                                                <input
                                                    type="text"
                                                    value={value}
                                                    onChange={(e) => handleCellChange(pos, index, e.target.value)}
                                                    onClick={() => handleCellClick(value)}
                                                    className={inputClasses}
                                                    placeholder="ID"
                                                    readOnly={isAutomated}
                                                />
                                            </td>
                                        );
                                    })}
                                </tr>
                            </tbody>
                        </table>
                    </div>
                );
            };
            
            const FocusButton = ({ label, view, icon }) => {
                const isActive = focusView === view;
                const baseClasses = "py-2 px-3 sm:px-4 text-xs sm:text-sm rounded-md font-medium transition-all duration-200 flex items-center gap-1";
                const activeClasses = "bg-blue-600 text-white shadow-md";
                const inactiveClasses = "bg-white text-gray-600 hover:bg-gray-200";
                
                const icons = {
                    all: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" /></svg>,
                    security: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12 12 0 0012 21.697z" /></svg>,
                    foyer: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5.121 17.804A13.937 13.937 0 0112 16c2.5 0 4.847.655 6.879 1.804M15 10a3 3 0 11-6 0 3 3 0 016 0z" /></svg>,
                    sentry: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                };

                return (
                    <button onClick={() => setFocusView(view)} className={`${baseClasses} ${isActive ? activeClasses : inactiveClasses}`}>
                        {icons[icon]}
                        <span className="hidden sm:inline">{label}</span>
                        <span className="sm:hidden">{label === 'SCR' ? 'SCR' : ''}</span>
                    </button>
                );
            };
            
            const handleToggleMatrix = () => {
                // If switching INTO matrix mode, clear highlights
                if (!isMatrixEditMode) {
                    setHighlightedId(null);
                }
                setIsMatrixEditMode(prev => !prev);
            };

            // Logic to check if assignments are present and enable the Auto-Update button
            const canGenerateRoster = useMemo(() => {
                // Must be authenticated and not currently loading the core data
                if (loading || isGenerating) return false;
                
                // Must have the assignment document loaded
                if (!dailyAssignments) return false;
                
                // Must have at least one scheduled staff member
                if (scheduledStaff.length === 0) return false; 

                // Must have at least one assigned slot in the sequenceMap to proceed
                const sequenceMap = dailyAssignments.sequenceMap || {};
                const hasAssignments = Object.values(sequenceMap).some(arr => Array.isArray(arr) && arr.length > 0);
                
                return hasAssignments;
            }, [loading, isGenerating, dailyAssignments, scheduledStaff.length]);


            // Determine button label dynamically
            const generateButtonLabel = useMemo(() => {
                if (isGenerating) return "Generating...";
                if (rosterData) return "Update (Keep Edits)";
                return "Generate Roster";
            }, [rosterData, isGenerating]);
            
            const resetButtonLabel = useMemo(() => {
                return "Reset Grid";
            }, []);


            return (
                <div className="bg-white sm:p-6 rounded-lg shadow-lg">
                    {/* Control Bar: Hidden on Print */}
                    <div className="flex flex-col sm:flex-row justify-between items-center mb-6 gap-4 p-2 sm:p-0 action-buttons">
                        <div className="flex items-center gap-2 date-selector">
                            <label htmlFor="roster-date-main" className="font-medium text-gray-700 text-lg">Roster Date:</label>
                            <input
                                type="date"
                                id="roster-date-main"
                                value={selectedDate}
                                onChange={(e) => setSelectedDate(e.target.value)}
                                className="border-gray-300 rounded-md shadow-sm p-2 text-lg"
                            />
                        </div>
                        <div className="flex space-x-2">
                            <button
                                onClick={handleToggleMatrix}
                                className={`py-2 px-4 rounded-md font-medium text-white shadow-md transition-colors`}
                                style={{ backgroundColor: isMatrixEditMode ? '#DC2626' : '#2563EB' }}
                                disabled={loading || !rosterData}
                            >
                                {isMatrixEditMode ? "Exit Matrix Edit" : "Matrix Edit Mode"}
                            </button>
                            
                            <button
                                onClick={handlePrint}
                                disabled={loading || !rosterData}
                                className="py-2 px-4 bg-purple-600 text-white rounded-md shadow-md font-medium hover:bg-purple-700 disabled:bg-gray-400 disabled:cursor-not-allowed print-hidden"
                            >
                                Print Roster
                            </button>

                            <button
                                onClick={handleSaveChanges}
                                disabled={loading || !isDirty}
                                className="py-2 px-4 bg-green-600 text-white rounded-md shadow-md font-medium hover:bg-green-700 disabled:bg-gray-400 print-hidden"
                            >
                                {loading ? "Saving..." : "Save Changes"}
                            </button>
                        </div>
                    </div>
                    
                    {/* Error, Dirty, Loading messages */}
                    {error && <div className="text-red-600 bg-red-100 p-3 rounded-md mb-4 mx-2 sm:mx-0">
                        {error}
                        <p className="text-sm mt-1">Note: Print View will still attempt to render data even with minor load errors.</p>
                    </div>}
                    {isDirty && <div className="text-yellow-700 bg-yellow-100 p-3 rounded-md mb-4 mx-2 sm:mx-0 unsaved-changes">You have unsaved changes.</div>}
                    {loading && !rosterData && <div className="text-center p-8">Loading Roster and Assignments...</div>}


                    {/* --- FOCUS BUTTONS AND GENERATE/UPDATE BUTTONS --- */}
                    <div className="space-y-6 p-2 sm:p-0">
                        {/* Focus/Generate Button Row */}
                        <div className="flex space-x-2 p-2 sm:p-0 bg-gray-100 sm:bg-transparent rounded-lg focus-buttons">
                            <FocusButton label="Show All" view="all" icon="all" />
                            <FocusButton label="SCR" view="security" icon="security" />
                            <FocusButton label="Foyer" view="foyer" icon="foyer" />
                            <FocusButton label="Sentry" view="sentry" icon="sentry" />
                            
                            {!isMatrixEditMode && (
                                <>
                                    <button
                                        onClick={() => handleGenerateRoster(false)}
                                        title={canGenerateRoster ? `Click to ${generateButtonLabel} using assignments from Setup tab` : (scheduledStaff.length === 0 ? "Cannot update: No staff are currently scheduled." : "Requires saved assignments (Setup tab)")}
                                        disabled={!canGenerateRoster || isGenerating} 
                                        className="py-2 px-4 bg-blue-500 text-white rounded-md shadow-md font-medium hover:bg-blue-600 disabled:bg-gray-400 disabled:cursor-not-allowed"
                                    >
                                        {generateButtonLabel}
                                    </button>
                                    <button
                                        onClick={() => {
                                            // Use a custom confirmation dialog replacement
                                            if(window.confirm("WARNING: This will wipe ALL manual edits in the roster grid and regenerate it from the assignments in the Setup tab. Are you sure you want to proceed?")) {
                                                handleGenerateRoster(true);
                                            }
                                        }}
                                        title="Wipes grid and regenerates using assignments."
                                        disabled={loading || !dailyAssignments || isGenerating || !rosterData} 
                                        className="py-2 px-4 bg-gray-200 text-gray-700 rounded-md shadow-md font-medium hover:bg-gray-300 disabled:bg-gray-400 disabled:cursor-not-allowed"
                                    >
                                        {resetButtonLabel}
                                    </button>
                                </>
                            )}
                        </div>
                        
                        {/* Warning/Loading Messages Related to Generation */}
                        {!loading && scheduledStaff.length === 0 && (
                            <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-4 mx-2 sm:mx-0 font-medium">
                                <p>Cannot **{generateButtonLabel}**:</p>
                                <p className="text-sm">No staff are currently scheduled. Please go to the **Setup tab** to schedule staff.</p>
                            </div>
                        )}
                        
                        {!loading && scheduledStaff.length > 0 && !canGenerateRoster && (
                            <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-4 mx-2 sm:mx-0 font-medium">
                                <p>Cannot **{generateButtonLabel}**:</p>
                                <p className="text-sm">Please go to **Staff & Roster Setup** tab, set staff assignments, and then save the assignments.</p>
                            </div>
                        )}
                        
                        {isGenerating && (
                            <div className="bg-blue-100 border-l-4 border-blue-500 text-blue-800 p-4 mb-4 mx-2 sm:mx-0 font-medium animate-pulse">
                                Roster generation in progress...
                            </div>
                        )}

                        {isShuffling && (
                            <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-800 p-4 mb-4 mx-2 sm:mx-0 font-medium animate-pulse">
                                Roster **Shuffle** in progress. Assignments are being rotated and the grid is being regenerated.
                            </div>
                        )}
                        
                        {/* Tooltip for Matrix Mode */}
                        {isMatrixEditMode && (
                            <div className="bg-blue-50 border-l-4 border-blue-400 text-blue-800 p-4 mb-4 mx-2 sm:mx-0">
                                <p className="font-bold">Matrix Edit Mode Active:</p>
                                <p className="text-sm">Every cell is a direct dropdown for assignment. Moving a staff ID will **SWAP** positions with the ID already occupying the cell. Use "Save Changes" after editing.</p>
                            </div>
                        )}
                        
                        {/* --- ROSTER TABLES - Rendered if rosterData exists, else show placeholder --- */}
                        {rosterData ? (
                            <div className="space-y-6 p-2 sm:p-0"> 
                                <h2 className="text-xl font-bold mb-4 text-center hidden print:block">DAILY ROSTER - {selectedDate}</h2>
                            
                                {(focusView === 'all' || focusView === 'security') && (
                                    <div className={`roster-section ${focusView !== 'all' ? 'border-t border-gray-300 pt-4' : ''}`}>
                                        <h3 className="text-lg font-semibold mb-2 text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Security Control Office</h3>
                                        <div className="overflow-x-auto shadow-md rounded-lg border">
                                            <table className="min-w-full divide-y divide-gray-200">
                                                {renderTableHeader()}
                                                {renderTableBody(SECURITY_POSITIONS)}
                                            </table>
                                        </div>
                                    </div>
                                )}
                                
                                 {(focusView === 'all' || focusView === 'foyer') && (
                                     <>
                                        <div className="border-t border-gray-300 pt-6 roster-section">
                                            <h3 className="text-lg font-semibold mb-2 text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Foyer Deployment</h3>
                                            <div className="overflow-x-auto shadow-md rounded-lg border">
                                                <table className="min-w-full divide-y divide-gray-200">
                                                    {renderTableHeader()}
                                                    {renderTableBody(FOYER_POSITIONS)}
                                                </table>
                                            </div>
                                        </div>

                                        <div className="space-y-4 roster-section">
                                            <h3 className="text-lg font-semibold mb-2 text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Vertical Prowler</h3>
                                            {(() => {
                                                const teamLeaderId = (rosterData[SECURITY_POSITIONS[0]]?.[0]?.value || "").trim();
                                                const sectionIcId = (rosterData[SECURITY_POSITIONS[1]]?.[0]?.value || "").trim();
                                                const controlRoomStaff = [...new Set([teamLeaderId, sectionIcId].filter(id => id && id !== UNFILLED_SLOT && id !== ""))];
                                                
                                                return renderVerticalProwlerTable(controlRoomStaff);
                                            })()}
                                        </div>
                                    </>
                                 )}

                                 {(focusView === 'all' || focusView === 'sentry') && (
                                    <div className="border-t border-gray-300 pt-6 roster-section">
                                        {/* Roster Shuffle Button (As requested, placed before the Sentry Deployment table) */}
                                        <div className="flex justify-between items-center mb-2">
                                            <h3 className="text-lg font-semibold text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Sentry Deployment / Patrol Duties</h3>
                                            
                                            {!isMatrixEditMode && (
                                                <button
                                                    onClick={handleShuffle}
                                                    disabled={isShuffling || isGenerating || rosterMode !== ROSTER_MODES.AUTO_SEQUENCE}
                                                    className={`py-2 px-4 text-sm font-medium rounded-md shadow-md transition-colors print-hidden flex items-center gap-1 ${
                                                        isShuffling ? 'bg-yellow-500 text-white animate-pulse' : 
                                                        rosterMode === ROSTER_MODES.AUTO_SEQUENCE ? 'bg-orange-500 text-white hover:bg-orange-600' : 
                                                        'bg-gray-400 text-gray-600 disabled:cursor-not-allowed'
                                                    }`}
                                                    title={rosterMode === ROSTER_MODES.AUTO_SEQUENCE ? "Cyclically shifts the 6 rotation assignments (E1, P1, E3, N1, P2, OE) and regenerates the roster." : "Only available in Auto-Sequence Mode."}
                                                >
                                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m5.676 11.528A8.001 8.001 0 0019.418 15v-5h.582" /></svg>
                                                    {isShuffling ? "Shuffling..." : "Roster Shuffle"}
                                                </button>
                                            )}
                                        </div>
                                        <div className="overflow-x-auto shadow-md rounded-lg border">
                                            <table className="min-w-full divide-y divide-gray-200">
                                                {renderTableHeader()}
                                                {renderTableBody(sentryRowsToRender)}
                                            </table>
                                        </div>
                                    </div>
                                )}
                            </div>
                        ) : (
                            // Placeholder when no roster data is loaded
                            !loading && (
                                <div className="text-center p-8 border rounded-lg bg-gray-50 mt-4">
                                    <p className="text-lg font-semibold text-gray-700">No Roster Data Found for {selectedDate}.</p>
                                    <p className="text-sm text-gray-500 mt-2">Use the **Generate Roster** button above after setting up assignments in the Setup tab.</p>
                                </div>
                            )
                        )}
                    </div>
                </div>
            );
        }

    </script>
</body>
</html>

