import sqlite3
from flask import Flask, request, jsonify, render_template
from datetime import datetime, timedelta
from waitress import serve
from flask_cors import CORS  # Enable cross-origin requests
import jwt
from passlib.hash import bcrypt

app = Flask(__name__)
CORS(app)  # Allow requests from any origin (adjust as needed)

# Set your secret key (store securely in production)
app.config['SECRET_KEY'] = 'YOUR_SECRET_KEY'

# Database for leave management
DATABASE = 'leave_management.db'
# Authentication database for user credentials
AUTH_DATABASE = 'users_password.db'

def get_db_connection():
    conn = sqlite3.connect(DATABASE)
    conn.row_factory = sqlite3.Row
    conn.execute('PRAGMA foreign_keys = ON;')
    return conn

def get_auth_db_connection():
    conn = sqlite3.connect(AUTH_DATABASE)
    conn.row_factory = sqlite3.Row
    return conn

@app.route('/')
def index():
    return render_template('index.html')

# New JWT login endpoint
@app.route('/api/login', methods=['POST'])
def login():
    data = request.get_json()
    staff_id = data.get('staff_id')
    password = data.get('password')

    if not staff_id or not password:
        return jsonify({'status': 'error', 'message': 'Missing staff_id or password.'}), 400

    conn = get_auth_db_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM users WHERE staff_id = ?', (staff_id,))
    user = cursor.fetchone()
    conn.close()

    if not user:
        return jsonify({'status': 'error', 'message': 'Invalid credentials.'}), 401

    stored_hash = user['password_hash']
    if not bcrypt.verify(password, stored_hash):
        return jsonify({'status': 'error', 'message': 'Invalid credentials.'}), 401

    # Generate JWT token with an expiration time of 1 hour
    token_payload = {
        'staff_id': user['staff_id'],
        'is_admin': user['is_admin'],
        'exp': datetime.utcnow() + timedelta(hours=1)
    }
    token = jwt.encode(token_payload, app.config['SECRET_KEY'], algorithm='HS256')

    return jsonify({'status': 'success', 'token': token})

@app.route('/api/submit_leave', methods=['POST'])
def submit_leave():
    data = request.get_json()
    staff_name = data.get('staffName')
    staff_id = data.get('staffID')
    from_date = data.get('fromDate')
    to_date = data.get('toDate')

    if not all([staff_name, staff_id, from_date, to_date]):
        return jsonify({'status': 'error', 'message': 'Missing fields.'}), 400

    try:
        start_dt = datetime.strptime(from_date, '%Y-%m-%d').date()
        end_dt = datetime.strptime(to_date, '%Y-%m-%d').date()
    except ValueError:
        return jsonify({'status': 'error', 'message': 'Invalid date format.'}), 400

    if end_dt < start_dt:
        return jsonify({'status': 'error', 'message': 'End date cannot be before start date.'}), 400

    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO leave_requests (staff_name, staff_id, from_date, to_date, submission_date)
        VALUES (?, ?, ?, ?, ?)
    ''', (staff_name, staff_id, from_date, to_date, datetime.now().isoformat()))
    request_id = cursor.lastrowid

    # Insert each day in the range
    current_date = start_dt
    while current_date <= end_dt:
        cursor.execute('''
            INSERT INTO leave_request_days (request_id, date, status)
            VALUES (?, ?, ?)
        ''', (request_id, current_date.isoformat(), 'Pending'))
        current_date += timedelta(days=1)

    conn.commit()
    conn.close()
    return jsonify({'status': 'success', 'message': 'Leave request submitted.'})

@app.route('/api/get_leaves', methods=['GET'])
def get_leaves():
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM leave_requests')
    requests_rows = cursor.fetchall()

    results = []
    for req in requests_rows:
        req_dict = dict(req)
        request_id = req_dict['id']
        from_date = datetime.strptime(req_dict['from_date'], '%Y-%m-%d').date()
        to_date = datetime.strptime(req_dict['to_date'], '%Y-%m-%d').date()

        # Rename database keys to camelCase for the front end
        req_dict["staffName"] = req_dict.pop("staff_name", None)
        req_dict["staffID"] = req_dict.pop("staff_id", None)

        # Fetch existing days from the leave_request_days table
        cursor.execute('SELECT id, date, status FROM leave_request_days WHERE request_id = ?', (request_id,))
        days_rows = cursor.fetchall()
        day_dicts = {row['date']: dict(row) for row in days_rows}

        # Generate all days in the range and fill in missing ones
        day_list = []
        current_date = from_date
        while current_date <= to_date:
            date_str = current_date.isoformat()
            if date_str in day_dicts:
                day = day_dicts[date_str]
                # Rename "Management" to "Write-in" before returning JSON
                if day.get("status") == "Management":
                    day["status"] = "Write-in"
                day_list.append(day)
            else:
                # Add a placeholder for missing days
                day_list.append({
                    "id": None,
                    "date": date_str,
                    "status": "Pending"
                })
            current_date += timedelta(days=1)

        req_dict["days"] = day_list
        results.append(req_dict)

    conn.close()
    return jsonify(results)

@app.route('/api/update_day_status', methods=['POST'])
def update_day_status():
    """
    Expects JSON: { "day_id": <int>, "status": "Approved"/"Rejected"/"Pending"/"Write-in" }
    Updates a single day's status in the database.
    """
    data = request.get_json()
    day_id = data.get('day_id')
    new_status = data.get('status')
    if not day_id or not new_status:
        return jsonify({'status': 'error', 'message': 'Missing day_id or status.'}), 400

    # Convert "Management" to "Write-in" if accidentally sent
    if new_status == "Management":
        new_status = "Write-in"

    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('UPDATE leave_request_days SET status = ? WHERE id = ?', (new_status, day_id))
    conn.commit()
    conn.close()
    return jsonify({'status': 'success', 'message': 'Day status updated.'})

@app.route('/api/delete_request', methods=['POST'])
def delete_request():
    """
    Expects JSON: { "request_id": <int> }
    Deletes the leave request (and, if ON DELETE CASCADE is active, its associated days).
    """
    data = request.get_json()
    req_id = data.get('request_id')
    if not req_id:
        return jsonify({'status': 'error', 'message': 'Missing request_id.'}), 400

    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('DELETE FROM leave_requests WHERE id = ?', (req_id,))
    conn.commit()
    conn.close()
    return jsonify({'status': 'success', 'message': 'Request deleted.'})

@app.route('/api/update_leave_request', methods=['POST'])
def update_leave_request():
    """
    OPTIONAL: Update an entire leave request.
    Expects JSON: {
      "request_id": <int>,
      "staffName": "string",
      "staffID": "string",
      "fromDate": "YYYY-MM-DD",
      "toDate": "YYYY-MM-DD"
    }
    """
    data = request.get_json()
    req_id = data.get('request_id')
    staff_name = data.get('staffName')
    staff_id = data.get('staffID')
    from_date = data.get('fromDate')
    to_date = data.get('toDate')
    if not req_id or not all([staff_name, staff_id, from_date, to_date]):
        return jsonify({'status': 'error', 'message': 'Missing fields.'}), 400
    try:
        start_dt = datetime.strptime(from_date, '%Y-%m-%d').date()
        end_dt = datetime.strptime(to_date, '%Y-%m-%d').date()
    except ValueError:
        return jsonify({'status': 'error', 'message': 'Invalid date format.'}), 400
    if end_dt < start_dt:
        return jsonify({'status': 'error', 'message': 'End date cannot be before start date.'}), 400

    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('''
        UPDATE leave_requests
        SET staff_name = ?, staff_id = ?, from_date = ?, to_date = ?
        WHERE id = ?
    ''', (staff_name, staff_id, from_date, to_date, req_id))
    conn.commit()
    conn.close()
    return jsonify({'status': 'success', 'message': 'Request updated.'})

if __name__ == '__main__':
    # For production, run as Administrator on Windows to bind to port 80:
    serve(app, host='0.0.0.0', port=80)
    # For development, you can use:
    # app.run(debug=True, host='0.0.0.0', port=5000)