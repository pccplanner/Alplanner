Attached my app.py for my leave management system: please refine it for this new direction:

import sqlite3
from flask import Flask, request, jsonify, render_template
from datetime import datetime, timedelta
from waitress import serve
from flask_cors import CORS
import jwt
from passlib.hash import bcrypt
from functools import wraps
import os

app = Flask(__name__)

# Configure CORS for API routes (allowing the Authorization header)
app.config['CORS_HEADERS'] = 'Content-Type,Authorization'
CORS(
    app,
    resources={r"/api/*": {"origins": "*"}},
    allow_headers=["Content-Type", "Authorization"],
    expose_headers=["Authorization"]
)

# Set secret key (replace with a secure value in production)
app.config['SECRET_KEY'] = 'YOUR_SECRET_KEY'

# Database names
DATABASE = 'leave_management.db'
AUTH_DATABASE = 'users_password.db'
print("DEBUG: AUTH_DATABASE =>", os.path.abspath(AUTH_DATABASE))

def get_db_connection():
    """Connect to the leave_management.db database."""
    conn = sqlite3.connect(DATABASE)
    conn.row_factory = sqlite3.Row
    conn.execute('PRAGMA foreign_keys = ON;')
    return conn

def get_auth_db_connection():
    """Connect to the users_password.db database."""
    conn = sqlite3.connect(AUTH_DATABASE)
    conn.row_factory = sqlite3.Row
    return conn

# ------------------------------
# Decorator to require admin JWT token
# ------------------------------
def token_required_admin(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = None
        if 'Authorization' in request.headers:
            auth_header = request.headers['Authorization']
            if auth_header.startswith('Bearer '):
                token = auth_header[7:]
        if not token:
            print("DEBUG: No token found in request headers.")
            return jsonify({'status': 'error', 'message': 'Token is missing!'}), 401

        try:
            payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            if not payload.get('is_admin'):
                print("DEBUG: Token valid but is_admin=False.")
                return jsonify({'status': 'error', 'message': 'Admin privileges required.'}), 403
        except Exception as e:
            print("DEBUG: Token decode error =>", e)
            return jsonify({'status': 'error', 'message': 'Token is invalid!'}), 401

        return f(*args, **kwargs)
    return decorated

@app.route('/')
def index():
    return render_template('index.html')

# ------------------------------
# Authentication Endpoint
# ------------------------------
@app.route('/api/login', methods=['POST'])
def login():
    data = request.get_json()
    staff_id = data.get('staff_id')
    password = data.get('password')
    if not staff_id or not password:
        return jsonify({'status': 'error', 'message': 'Missing credentials.'}), 400

    conn = get_auth_db_connection()
    user = conn.execute('SELECT * FROM users WHERE staff_id = ?', (staff_id,)).fetchone()
    conn.close()

    if not user:
        return jsonify({'status': 'error', 'message': 'Invalid credentials.'}), 401

    # Verify password with passlib (bcrypt)
    if not bcrypt.verify(password, user['password_hash']):
        return jsonify({'status': 'error', 'message': 'Invalid credentials.'}), 401

    # Generate JWT token
    token = jwt.encode({
        'staff_id': user['staff_id'],
        'is_admin': user['is_admin'],
        'exp': datetime.utcnow() + timedelta(hours=1)
    }, app.config['SECRET_KEY'], algorithm='HS256')

    return jsonify({'status': 'success', 'token': token})

# ------------------------------
# Leave Management Endpoints
# ------------------------------
@app.route('/api/submit_leave', methods=['POST'])
def submit_leave():
    """Handles creation of a new leave request, inserting
       staff_name, staff_id, from_date, to_date, etc."""
    data = request.get_json()
    staff_name = data.get('staffName')  # typed name
    staff_id = data.get('staffID')      # unique staff ID
    from_date = data.get('fromDate')
    to_date = data.get('toDate')

    if not all([staff_name, staff_id, from_date, to_date]):
        return jsonify({'status': 'error', 'message': 'Missing fields.'}), 400

    try:
        start_dt = datetime.strptime(from_date, '%Y-%m-%d').date()
        end_dt = datetime.strptime(to_date, '%Y-%m-%d').date()
    except ValueError:
        return jsonify({'status': 'error', 'message': 'Invalid date format.'}), 400

    if end_dt < start_dt:
        return jsonify({'status': 'error', 'message': 'End date cannot be before start date.'}), 400

    conn = get_db_connection()
    cursor = conn.cursor()
    # Insert main leave request record
    cursor.execute('''
        INSERT INTO leave_requests (staff_name, staff_id, from_date, to_date, submission_date)
        VALUES (?, ?, ?, ?, ?)
    ''', (staff_name, staff_id, from_date, to_date, datetime.now().isoformat()))
    request_id = cursor.lastrowid

    # Insert each day's entry in leave_request_days
    current_date = start_dt
    while current_date <= end_dt:
        cursor.execute('''
            INSERT INTO leave_request_days (request_id, date, status)
            VALUES (?, ?, ?)
        ''', (request_id, current_date.isoformat(), 'Pending'))
        current_date += timedelta(days=1)

    conn.commit()
    conn.close()
    return jsonify({'status': 'success', 'message': 'Leave request submitted.'})

@app.route('/api/get_leaves', methods=['GET'])
def get_leaves():
    """Returns a list of all leave requests, including the daily breakdown."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM leave_requests')
    requests_rows = cursor.fetchall()
    results = []

    for req in requests_rows:
        req_dict = dict(req)
        request_id = req_dict['id']
        from_date = datetime.strptime(req_dict['from_date'], '%Y-%m-%d').date()
        to_date = datetime.strptime(req_dict['to_date'], '%Y-%m-%d').date()

        # Convert DB columns to JSON keys staffName/staffID
        req_dict["staffName"] = req_dict.pop("staff_name", None)
        req_dict["staffID"] = req_dict.pop("staff_id", None)

        # Fetch daily entries
        cursor.execute('SELECT id, date, status FROM leave_request_days WHERE request_id = ?', (request_id,))
        days_rows = cursor.fetchall()
        day_dicts = {row['date']: dict(row) for row in days_rows}
        day_list = []

        # Build a day_list from from_date..to_date
        current_date = from_date
        while current_date <= to_date:
            date_str = current_date.isoformat()
            if date_str in day_dicts:
                day = day_dicts[date_str]
                # Rename "Management" to "Write-in" for display
                if day.get("status") == "Management":
                    day["status"] = "Write-in"
                day_list.append(day)
            else:
                day_list.append({"id": None, "date": date_str, "status": "Pending"})
            current_date += timedelta(days=1)

        req_dict["days"] = day_list
        results.append(req_dict)

    conn.close()
    return jsonify(results)

@app.route('/api/update_day_status', methods=['POST'])
def update_day_status():
    """Updates the status of a single day (by day_id)."""
    data = request.get_json()
    day_id = data.get('day_id')
    new_status = data.get('status')

    if not day_id or not new_status:
        return jsonify({'status': 'error', 'message': 'Missing day_id or status.'}), 400

    print(f"DEBUG: Updating day_id={day_id} to status '{new_status}'")
    # If new_status was "Management", rename it to "Write-in"
    if new_status == "Management":
        new_status = "Write-in"

    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute('UPDATE leave_request_days SET status = ? WHERE id = ?', (new_status, day_id))
        if cursor.rowcount == 0:
            conn.close()
            return jsonify({'status': 'error', 'message': 'No matching day record found.'}), 400
        conn.commit()
        conn.close()
    except Exception as e:
        return jsonify({'status': 'error', 'message': str(e)}), 500

    return jsonify({'status': 'success', 'message': 'Day status updated.'})

@app.route('/api/delete_request', methods=['POST'])
def delete_request():
    """Deletes an entire leave request (by request_id)."""
    data = request.get_json()
    req_id = data.get('request_id')
    if not req_id:
        return jsonify({'status': 'error', 'message': 'Missing request_id.'}), 400

    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('DELETE FROM leave_requests WHERE id = ?', (req_id,))
    conn.commit()
    conn.close()

    return jsonify({'status': 'success', 'message': 'Request deleted.'})

@app.route('/api/update_leave_request', methods=['POST'])
def update_leave_request():
    """Updates the main details of an existing leave request (staff_name, staff_id, date range)."""
    data = request.get_json()
    req_id = data.get('request_id')
    staff_name = data.get('staffName')
    staff_id = data.get('staffID')
    from_date = data.get('fromDate')
    to_date = data.get('toDate')

    if not req_id or not all([staff_name, staff_id, from_date, to_date]):
        return jsonify({'status': 'error', 'message': 'Missing fields.'}), 400

    try:
        start_dt = datetime.strptime(from_date, '%Y-%m-%d').date()
        end_dt = datetime.strptime(to_date, '%Y-%m-%d').date()
    except ValueError:
        return jsonify({'status': 'error', 'message': 'Invalid date format.'}), 400

    if end_dt < start_dt:
        return jsonify({'status': 'error', 'message': 'End date cannot be before start date.'}), 400

    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('''
        UPDATE leave_requests
        SET staff_name = ?, staff_id = ?, from_date = ?, to_date = ?
        WHERE id = ?
    ''', (staff_name, staff_id, from_date, to_date, req_id))
    conn.commit()
    conn.close()

    return jsonify({'status': 'success', 'message': 'Request updated.'})

# ------------------------------
# User Management Endpoints (Admin Only)
# ------------------------------
@app.route('/api/users', methods=['GET'])
@token_required_admin
def list_users():
    """Lists all users in users_password.db (admin route)."""
    print("DEBUG: /api/users [GET] invoked (admin route).")
    conn = get_auth_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT id, username, staff_id, is_admin FROM users")
    rows = cursor.fetchall()
    conn.close()

    users = []
    for row in rows:
        users.append({
            "id": row["id"],
            "username": row["username"],
            "staffID": row["staff_id"],
            "isAdmin": bool(row["is_admin"])
        })
    return jsonify(users)

@app.route('/api/users', methods=['POST'])
@token_required_admin
def create_user():
    """Creates a new user in the users_password.db (admin route)."""
    print("DEBUG: /api/users [POST] invoked (admin route).")
    data = request.get_json()
    username = data.get('username')
    staff_id = data.get('staffID')
    password = data.get('password')
    is_admin = data.get('isAdmin', False)

    if not all([username, staff_id, password]):
        return jsonify({'status': 'error', 'message': 'Missing fields.'}), 400

    password_hash = bcrypt.hash(password)

    try:
        conn = get_auth_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO users (username, staff_id, password_hash, is_admin) VALUES (?, ?, ?, ?)",
            (username, staff_id, password_hash, 1 if is_admin else 0)
        )
        conn.commit()
        conn.close()
    except sqlite3.IntegrityError:
        return jsonify({'status': 'error', 'message': 'User already exists.'}), 400

    return jsonify({'status': 'success', 'message': 'User added successfully.'})

@app.route('/api/users/<int:user_id>', methods=['PUT'])
@token_required_admin
def update_user(user_id):
    """Updates a user's username/staff_id in users_password.db (admin route)."""
    print(f"DEBUG: /api/users/{user_id} [PUT] invoked (admin route).")
    data = request.get_json()
    username = data.get('username')
    staff_id = data.get('staffID')

    if not all([username, staff_id]):
        return jsonify({'status': 'error', 'message': 'Missing fields.'}), 400

    conn = get_auth_db_connection()
    cursor = conn.cursor()
    try:
        cursor.execute("UPDATE users SET username = ?, staff_id = ? WHERE id = ?", (username, staff_id, user_id))
        conn.commit()
    except sqlite3.IntegrityError:
        conn.close()
        return jsonify({'status': 'error', 'message': 'Staff ID already in use.'}), 400

    conn.close()
    return jsonify({'status': 'success', 'message': 'User updated successfully.'})

@app.route('/api/users/<int:user_id>', methods=['DELETE'])
@token_required_admin
def delete_user(user_id):
    """Deletes a user in users_password.db (admin route)."""
    print(f"DEBUG: /api/users/{user_id} [DELETE] invoked (admin route).")
    conn = get_auth_db_connection()
    cursor = conn.cursor()
    cursor.execute("DELETE FROM users WHERE id = ?", (user_id,))
    conn.commit()
    conn.close()
    return jsonify({'status': 'success', 'message': 'User deleted successfully.'})

@app.route('/api/users/<int:user_id>/toggle_admin', methods=['POST'])
@token_required_admin
def toggle_admin(user_id):
    """Toggles a user's is_admin status in users_password.db (admin route)."""
    print(f"DEBUG: /api/users/{user_id}/toggle_admin [POST] invoked (admin route).")
    conn = get_auth_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT is_admin FROM users WHERE id = ?", (user_id,))
    row = cursor.fetchone()
    if not row:
        conn.close()
        return jsonify({'status': 'error', 'message': 'User not found.'}), 404

    new_status = 0 if row['is_admin'] else 1
    cursor.execute("UPDATE users SET is_admin = ? WHERE id = ?", (new_status, user_id))
    conn.commit()
    conn.close()
    return jsonify({'status': 'success', 'message': 'User admin status updated.'})

@app.route('/api/users/<int:user_id>/reset_password', methods=['POST'])
@token_required_admin
def reset_password(user_id):
    """Resets a user's password in users_password.db (admin route)."""
    print(f"DEBUG: /api/users/{user_id}/reset_password [POST] invoked (admin route).")
    data = request.get_json()
    new_password = data.get('newPassword')
    if not new_password:
        return jsonify({'status': 'error', 'message': 'Missing new password.'}), 400

    new_password_hash = bcrypt.hash(new_password)
    conn = get_auth_db_connection()
    cursor = conn.cursor()
    cursor.execute("UPDATE users SET password_hash = ? WHERE id = ?", (new_password_hash, user_id))
    conn.commit()
    conn.close()
    return jsonify({'status': 'success', 'message': 'Password reset successfully.'})

if __name__ == '__main__':
    # For production, run with waitress on port 80 (requires admin privileges on Windows)
    serve(app, host='0.0.0.0', port=5002)
    # For development/testing, you could do:
    # app.run(debug=True, host='0.0.0.0', port=5000)
